# Generated by Haxe 3.4.0
# coding: utf-8

from datetime import datetime as python_lib_datetime_Datetime
import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import os;
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import subprocess as python_lib_Subprocess
import sys as python_lib_Sys
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
import timeit as python_lib_Timeit
try:
    import tty as python_lib_Tty
except:
    pass

class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields

gsBaseFolderPath = os.path.dirname(__file__);

class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")



class cBrotli:
    sDictionaryFilePath = os.path.join(gsBaseFolderPath, "dictionary.txt");
    sDictionaryHashFilePath = os.path.join(gsBaseFolderPath, "DictionaryHash.txt");
    sDictionaryWordsFilePath = os.path.join(gsBaseFolderPath, "DictionaryWords.txt");
    sDictionaryBucketsFilePath = os.path.join(gsBaseFolderPath, "DictionaryBuckets.txt");
    _hx_class_name = "cBrotli"
    __slots__ = ()
    _hx_methods = ["decompress", "compress", "decompressArray", "compressArray"]
    _hx_statics = ["OpenInputFile", "OpenOutputFile", "OpenInputBinary"]

    def __init__(self):
        dictionary = cBrotli.OpenInputBinary(self.sDictionaryFilePath)
        DictionaryHash = cBrotli.OpenInputBinary(self.sDictionaryHashFilePath)
        DictionaryWords = cBrotli.OpenInputBinary(self.sDictionaryWordsFilePath)
        DictionaryBuckets = cBrotli.OpenInputBinary(self.sDictionaryBucketsFilePath)
        decode_Dictionary.kBrotliDictionary = dictionary
        encode_Dictionary.kBrotliDictionary = dictionary
        kStaticDictionaryHash = encode_Dictionary_hash.kStaticDictionaryHash
        kStaticDictionaryBuckets = encode_Static_dict_lut.kStaticDictionaryBuckets
        _g = 0
        while (_g < 32768):
            i = _g
            _g = (_g + 1)
            x = ((DictionaryHash[((i * 2) + 1)] << 8) | DictionaryHash[(i * 2)])
            kStaticDictionaryHash.append(x)
            x1 = (((DictionaryBuckets[((i * 3) + 2)] << 16) | (DictionaryBuckets[((i * 3) + 1)] << 8)) | DictionaryBuckets[(i * 3)])
            kStaticDictionaryBuckets.append(x1)
        kStaticDictionaryWords = encode_Static_dict_lut.kStaticDictionaryWords
        _g1 = 0
        while (_g1 < 31704):
            i1 = _g1
            _g1 = (_g1 + 1)
            _hx_len = HxOverrides.rshift(DictionaryWords[((i1 * 3) + 1)], 3)
            idx = ((((DictionaryWords[((i1 * 3) + 1)] & 7)) << 8) | DictionaryWords[(i1 * 3)])
            x2 = encode_static_dict_lut_DictWord(_hx_len,DictionaryWords[((i1 * 3) + 2)],idx)
            kStaticDictionaryWords.append(x2)

    def decompress(self,content):
        fin = list()
        _g1 = 0
        _g = Reflect.field(content,"length")
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(fin, i, Reflect.field(content,"charCodeAt")(i))
        fout = list()
        input = decode_Streams.BrotliInitMemInput(fin,len(fin))
        output = decode_Streams.BrotliInitMemOutput(fout)
        decode_Decode.BrotliDecompress(input,output)
        _hx_bytes = haxe_io_Bytes.alloc(Reflect.field(output.data_,"pos"))
        _g11 = 0
        _g2 = Reflect.field(output.data_,"pos")
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            _hx_bytes.b[i1] = (HxOverrides.arrayGet(Reflect.field(output.data_,"buffer"), i1) & 255)
        return _hx_bytes.getString(0,Reflect.field(output.data_,"pos"))

    def compress(self,content,quality):
        if ((quality < 0) or ((quality > 11))):
            print("Quality 0...11")
            return None
        fin = list()
        _g1 = 0
        _g = Reflect.field(content,"length")
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(fin, i, Reflect.field(content,"charCodeAt")(i))
        fout = list()
        params = encode_encode_BrotliParams()
        params.quality = quality
        output = encode_streams_BrotliMemOut(fout)
        encode_Encode.BrotliCompress(params,encode_streams_BrotliMemIn(fin,len(fin)),output)
        _hx_bytes = haxe_io_Bytes.alloc(output.position())
        _g11 = 0
        _g2 = output.position()
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            _hx_bytes.b[i1] = ((output.buf_[i1] if i1 >= 0 and i1 < len(output.buf_) else None) & 255)
        return _hx_bytes.getString(0,output.position())

    def decompressArray(self,content):
        fin = content
        fout = list()
        input = decode_Streams.BrotliInitMemInput(fin,len(fin))
        output = decode_Streams.BrotliInitMemOutput(fout)
        decode_Decode.BrotliDecompress(input,output)
        return Reflect.field(Reflect.field(output.data_,"buffer"),"slice")(0,Reflect.field(output.data_,"pos"))

    def compressArray(self,content,quality):
        if ((quality < 0) or ((quality > 11))):
            print("Quality 0...11")
            return None
        fin = content
        fout = list()
        params = encode_encode_BrotliParams()
        params.quality = quality
        output = encode_streams_BrotliMemOut(fout)
        encode_Encode.BrotliCompress(params,encode_streams_BrotliMemIn(fin,len(fin)),output)
        _hx_bytes = haxe_io_Bytes.alloc(output.position())
        _g1 = 0
        _g = output.position()
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            _hx_bytes.b[i] = ((output.buf_[i] if i >= 0 and i < len(output.buf_) else None) & 255)
        return output.buf_[0:output.position()]

    @staticmethod
    def OpenInputFile(input_path):
        return sys_io_File.read(input_path,True)

    @staticmethod
    def OpenOutputFile(output_path,force):
        return sys_io_File.write(output_path,True)

    @staticmethod
    def OpenInputBinary(input_path):
        input = sys_io_File.getBytes(input_path)
        content = [None]*input.length
        _g1 = 0
        _g = input.length
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            val = input.b[i]
            content[i] = ord(val)
        return content



class Date:
    _hx_class_name = "Date"
    __slots__ = ("date",)
    _hx_fields = ["date"]
    _hx_statics = ["now"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0)

    @staticmethod
    def now():
        d = Date(1970,0,1,0,0,0)
        d.date = python_lib_datetime_Datetime.now()
        return d



class DefaultFunctions:
    _hx_class_name = "DefaultFunctions"
    __slots__ = ()
    _hx_statics = ["memcpy_Int", "memset_Int", "memcpy_UInt", "memset_UInt", "memcpyArray", "memcpyVectorArray", "memcpyArrayVector"]

    def __init__(self):
        pass

    @staticmethod
    def memcpy_Int(dst,dst_offset,src,src_offset,count):
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            val = src[(src_offset + i)]
            dst[(dst_offset + i)] = val

    @staticmethod
    def memset_Int(b,offset,v,count):
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            b[(offset + i)] = v

    @staticmethod
    def memcpy_UInt(dst,dst_offset,src,src_offset,count):
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            val = src[(src_offset + i)]
            dst[(dst_offset + i)] = val

    @staticmethod
    def memset_UInt(b,offset,v,count):
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            b[(offset + i)] = v

    @staticmethod
    def memcpyArray(dst,dst_offset,src,src_offset,count):
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(dst, (dst_offset + i), python_internal_ArrayImpl._get(src, (src_offset + i)))

    @staticmethod
    def memcpyVectorArray(dst,dst_offset,src,src_offset,count):
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            val = python_internal_ArrayImpl._get(src, (src_offset + i))
            dst[(dst_offset + i)] = val

    @staticmethod
    def memcpyArrayVector(dst,dst_offset,src,src_offset,count):
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(dst, (dst_offset + i), src[(src_offset + i)])


class EnumValue:
    _hx_class_name = "EnumValue"


class FunctionMalloc:
    _hx_class_name = "FunctionMalloc"
    __slots__ = ()
    _hx_statics = ["mallocArray_encode_hash_BackwardMatch", "malloc_encode_backward_references_ZopfliNode", "malloc2__encode_backward_references_Pair", "malloc2_decode_huffman_HuffmanCode", "malloc_decode_huffman_HuffmanTreeGroup", "mallocUInt", "mallocInt", "mallocFloat", "mallocBool"]

    def __init__(self):
        pass

    @staticmethod
    def mallocArray_encode_hash_BackwardMatch(t,a):
        arr = list()
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(arr, i, encode_hash_BackwardMatch())
        return arr

    @staticmethod
    def malloc_encode_backward_references_ZopfliNode(t,a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            val = encode_backward_references_ZopfliNode()
            arr[i] = val
        return arr

    @staticmethod
    def malloc2__encode_backward_references_Pair(t,a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            val = encode_backward_references_Pair(0,0)
            arr[i] = val
        return arr

    @staticmethod
    def malloc2_decode_huffman_HuffmanCode(t,a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            val = decode_huffman_HuffmanCode(0,0)
            arr[i] = val
        return arr

    @staticmethod
    def malloc_decode_huffman_HuffmanTreeGroup(t,a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            val = decode_huffman_HuffmanTreeGroup()
            arr[i] = val
        return arr

    @staticmethod
    def mallocUInt(a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            arr[i] = 0
        return arr

    @staticmethod
    def mallocInt(a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            arr[i] = 0
        return arr

    @staticmethod
    def mallocFloat(a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            arr[i] = 0
        return arr

    @staticmethod
    def mallocBool(a):
        arr = [None]*a
        _g1 = 0
        while (_g1 < a):
            i = _g1
            _g1 = (_g1 + 1)
            arr[i] = False
        return arr


class decode_Decode:
    _hx_class_name = "decode.Decode"
    __slots__ = ()
    _hx_statics = ["BROTLI_FAILURE", "BROTLI_LOG_UINT", "BROTLI_LOG_ARRAY_INDEX", "BROTLI_LOG", "BROTLI_LOG_UCHAR_VECTOR", "kDefaultCodeLength", "kCodeLengthRepeatCode", "kNumLiteralCodes", "kNumInsertAndCopyCodes", "kNumBlockLengthCodes", "kLiteralContextBits", "kDistanceContextBits", "HUFFMAN_TABLE_BITS", "HUFFMAN_TABLE_MASK", "CODE_LENGTH_CODES", "kCodeLengthCodeOrder", "NUM_DISTANCE_SHORT_CODES", "kDistanceShortCodeIndexOffset", "kDistanceShortCodeValueOffset", "DecodeWindowBits", "DecodeVarLenUint8", "JumpToByteBoundary", "DecodeMetaBlockLength", "ReadSymbol", "ReadHuffmanCodeLengths", "ReadHuffmanCode", "ReadBlockLength", "TranslateShortCodes", "InverseMoveToFrontTransform", "HuffmanTreeGroupDecode", "DecodeContextMap", "DecodeBlockType", "DecodeBlockTypeWithContext", "CopyUncompressedBlockToOutput", "BrotliDecompressedSize", "BrotliDecompressStreaming", "BrotliDecompress"]

    @staticmethod
    def BROTLI_FAILURE():
        return 0

    @staticmethod
    def BROTLI_LOG_UINT(x):
        pass

    @staticmethod
    def BROTLI_LOG_ARRAY_INDEX(array_name,idx):
        pass

    @staticmethod
    def BROTLI_LOG(x):
        print(str(x))

    @staticmethod
    def BROTLI_LOG_UCHAR_VECTOR(v,_hx_len):
        pass

    @staticmethod
    def DecodeWindowBits(br):
        n = None
        if (decode_BitReader.BrotliReadBits(br,1) == 0):
            return 16
        n = decode_BitReader.BrotliReadBits(br,3)
        if (n > 0):
            return (17 + n)
        n = decode_BitReader.BrotliReadBits(br,3)
        if (n > 0):
            return (8 + n)
        return 17

    @staticmethod
    def DecodeVarLenUint8(br):
        if (decode_BitReader.BrotliReadBits(br,1) == 1):
            nbits = decode_BitReader.BrotliReadBits(br,3)
            if (nbits == 0):
                return 1
            else:
                return (decode_BitReader.BrotliReadBits(br,nbits) + ((1 << nbits)))
        return 0

    @staticmethod
    def JumpToByteBoundary(br):
        return (decode_BitReader.BrotliReadBits(br,((((br.bit_pos_ + 7) & -8)) - br.bit_pos_)) == 0)

    @staticmethod
    def DecodeMetaBlockLength(br,meta_block_length,input_end,is_metadata,is_uncompressed):
        size_nibbles = None
        size_bytes = None
        python_internal_ArrayImpl._set(input_end, 0, decode_BitReader.BrotliReadBits(br,1))
        python_internal_ArrayImpl._set(meta_block_length, 0, 0)
        python_internal_ArrayImpl._set(is_uncompressed, 0, 0)
        python_internal_ArrayImpl._set(is_metadata, 0, 0)
        if (((input_end[0] if 0 < len(input_end) else None) == 1) and ((decode_BitReader.BrotliReadBits(br,1) == 1))):
            return True
        size_nibbles = (decode_BitReader.BrotliReadBits(br,2) + 4)
        if (size_nibbles == 7):
            python_internal_ArrayImpl._set(is_metadata, 0, 1)
            if (decode_BitReader.BrotliReadBits(br,1) != 0):
                return False
            size_bytes = decode_BitReader.BrotliReadBits(br,2)
            if (size_bytes == 0):
                return True
            _g1 = 0
            while (_g1 < size_bytes):
                i = _g1
                _g1 = (_g1 + 1)
                next_byte = decode_BitReader.BrotliReadBits(br,8)
                if ((((i + 1) == size_bytes) and ((size_bytes > 1))) and ((next_byte == 0))):
                    return False
                _hx_local_0 = meta_block_length
                _hx_local_1 = 0
                _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
                python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 | ((next_byte << ((i * 8))))))
                (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
        else:
            _g11 = 0
            while (_g11 < size_nibbles):
                i1 = _g11
                _g11 = (_g11 + 1)
                next_nibble = decode_BitReader.BrotliReadBits(br,4)
                if ((((i1 + 1) == size_nibbles) and ((size_nibbles > 4))) and ((next_nibble == 0))):
                    return False
                _hx_local_3 = meta_block_length
                _hx_local_4 = 0
                _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
                python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 | ((next_nibble << ((i1 * 4))))))
                (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
        _hx_local_6 = meta_block_length
        _hx_local_7 = 0
        _hx_local_8 = (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)
        python_internal_ArrayImpl._set(_hx_local_6, _hx_local_7, (_hx_local_8 + 1))
        (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)
        if (((input_end[0] if 0 < len(input_end) else None) != 1) and (((is_metadata[0] if 0 < len(is_metadata) else None) != 1))):
            python_internal_ArrayImpl._set(is_uncompressed, 0, decode_BitReader.BrotliReadBits(br,1))
        return True

    @staticmethod
    def ReadSymbol(table,table_off,br):
        nbits = None
        decode_BitReader.BrotliFillBitWindow(br)
        table_off = (table_off + ((HxOverrides.rshift(br.val_, br.bit_pos_) & 255)))
        a = table[table_off].bits
        aNeg = (a < 0)
        if (aNeg if ((aNeg != False)) else (a > 8)):
            br.bit_pos_ = (br.bit_pos_ + 8)
            nbits = (table[table_off].bits - 8)
            table_off = (table_off + table[table_off].value)
            table_off = (table_off + ((HxOverrides.rshift(br.val_, br.bit_pos_) & (((1 << nbits)) - 1))))
        br.bit_pos_ = (br.bit_pos_ + table[table_off].bits)
        return table[table_off].value

    @staticmethod
    def ReadHuffmanCodeLengths(code_length_code_lengths,num_symbols,code_lengths,s):
        br = s.br
        if (s.sub_state[1] == 60):
            s.symbol = 0
            s.prev_code_len = 8
            s.repeat = 0
            s.repeat_code_len = 0
            s.space = 32768
            if (decode_Huffman.BrotliBuildHuffmanTable(s.table,0,5,code_length_code_lengths,18) <= 1):
                print("[ReadHuffmanCodeLengths] Building code length tree failed: ")
                return 0
            s.sub_state[1] = 61
        if (s.sub_state[1] == 61):
            while ((s.symbol < num_symbols) and ((s.space > 0))):
                p = s.table
                p_off = 0
                code_len = None
                if (not decode_BitReader.BrotliReadMoreInput(br)):
                    return 2
                decode_BitReader.BrotliFillBitWindow(br)
                p_off = (0 + ((HxOverrides.rshift(br.val_, br.bit_pos_) & 31)))
                br.bit_pos_ = (br.bit_pos_ + p[p_off].bits)
                code_len = p[p_off].value
                code_lengths[s.symbol] = code_len
                if (False if ((False != ((code_len < 0)))) else (16 > code_len)):
                    s.repeat = 0
                    if (code_len != 0):
                        s.prev_code_len = code_len
                        s.space = (s.space - ((32768 >> code_len)))
                    s.symbol = (s.symbol + 1)
                else:
                    extra_bits = (code_len - 14)
                    old_repeat = None
                    repeat_delta = None
                    new_len = 0
                    if (code_len == 16):
                        new_len = s.prev_code_len
                    if (s.repeat_code_len != new_len):
                        s.repeat = 0
                        s.repeat_code_len = new_len
                    old_repeat = s.repeat
                    if (s.repeat > 0):
                        def _hx_local_3():
                            s.repeat = (s.repeat - 2)
                            return s.repeat
                        s.repeat = ((_hx_local_3()) << extra_bits)
                    s.repeat = (s.repeat + ((decode_BitReader.BrotliReadBits(br,extra_bits) + 3)))
                    repeat_delta = (s.repeat - old_repeat)
                    if ((s.symbol + repeat_delta) > num_symbols):
                        return 0
                    DefaultFunctions.memset_UInt(code_lengths,s.symbol,s.repeat_code_len,repeat_delta)
                    s.symbol = (s.symbol + repeat_delta)
                    if (s.repeat_code_len != 0):
                        s.space = (s.space - ((repeat_delta << (15 - s.repeat_code_len))))
            if (s.space != 0):
                print(str((("[ReadHuffmanCodeLengths] s.space = " + Std.string(s.space)) + "\n")))
                return 0
            DefaultFunctions.memset_UInt(code_lengths,s.symbol,0,(num_symbols - s.symbol))
            s.sub_state[1] = 50
            return 1
        return 0

    @staticmethod
    def ReadHuffmanCode(alphabet_size,table,table_off,opt_table_size,s):
        br = s.br
        result = 1
        table_size = 0
        while True:
            if (s.sub_state[1] == 50):
                if (not decode_BitReader.BrotliReadMoreInput(br)):
                    return 2
                s.code_lengths = [None]*alphabet_size
                if (s.code_lengths is None):
                    return 0
                s.simple_code_or_skip = decode_BitReader.BrotliReadBits(br,2)
                if (s.simple_code_or_skip == 1):
                    max_bits_counter = (alphabet_size - 1)
                    max_bits = 0
                    symbols = [0, 0, 0, 0]
                    num_symbols = (decode_BitReader.BrotliReadBits(br,2) + 1)
                    while (max_bits_counter > 0):
                        max_bits_counter = (max_bits_counter >> 1)
                        max_bits = (max_bits + 1)
                    DefaultFunctions.memset_UInt(s.code_lengths,0,0,alphabet_size)
                    _g1 = 0
                    _g = num_symbols
                    while (_g1 < _g):
                        i = _g1
                        _g1 = (_g1 + 1)
                        python_internal_ArrayImpl._set(symbols, i, decode_BitReader.BrotliReadBits(br,max_bits))
                        if ((symbols[i] if i >= 0 and i < len(symbols) else None) >= alphabet_size):
                            return 0
                        s.code_lengths[(symbols[i] if i >= 0 and i < len(symbols) else None)] = 2
                    s.code_lengths[(symbols[0] if 0 < len(symbols) else None)] = 1
                    if (num_symbols == 1):
                        pass
                    elif (num_symbols == 2):
                        if ((symbols[0] if 0 < len(symbols) else None) == (symbols[1] if 1 < len(symbols) else None)):
                            return 0
                        s.code_lengths[(symbols[1] if 1 < len(symbols) else None)] = 1
                    elif (num_symbols == 3):
                        if ((((symbols[0] if 0 < len(symbols) else None) == (symbols[1] if 1 < len(symbols) else None)) or (((symbols[0] if 0 < len(symbols) else None) == (symbols[2] if 2 < len(symbols) else None)))) or (((symbols[1] if 1 < len(symbols) else None) == (symbols[2] if 2 < len(symbols) else None)))):
                            return 0
                    elif (num_symbols == 4):
                        if (((((((symbols[0] if 0 < len(symbols) else None) == (symbols[1] if 1 < len(symbols) else None)) or (((symbols[0] if 0 < len(symbols) else None) == (symbols[2] if 2 < len(symbols) else None)))) or (((symbols[0] if 0 < len(symbols) else None) == (symbols[3] if 3 < len(symbols) else None)))) or (((symbols[1] if 1 < len(symbols) else None) == (symbols[2] if 2 < len(symbols) else None)))) or (((symbols[1] if 1 < len(symbols) else None) == (symbols[3] if 3 < len(symbols) else None)))) or (((symbols[2] if 2 < len(symbols) else None) == (symbols[3] if 3 < len(symbols) else None)))):
                            return 0
                        if (decode_BitReader.BrotliReadBits(br,1) == 1):
                            s.code_lengths[(symbols[2] if 2 < len(symbols) else None)] = 3
                            s.code_lengths[(symbols[3] if 3 < len(symbols) else None)] = 3
                        else:
                            s.code_lengths[(symbols[0] if 0 < len(symbols) else None)] = 2
                    else:
                        pass
                    s.sub_state[1] = 62
                    continue
                else:
                    space = 32
                    num_codes = 0
                    huff = [decode_huffman_HuffmanCode(2,0), decode_huffman_HuffmanCode(2,4), decode_huffman_HuffmanCode(2,3), decode_huffman_HuffmanCode(3,2), decode_huffman_HuffmanCode(2,0), decode_huffman_HuffmanCode(2,4), decode_huffman_HuffmanCode(2,3), decode_huffman_HuffmanCode(4,1), decode_huffman_HuffmanCode(2,0), decode_huffman_HuffmanCode(2,4), decode_huffman_HuffmanCode(2,3), decode_huffman_HuffmanCode(3,2), decode_huffman_HuffmanCode(2,0), decode_huffman_HuffmanCode(2,4), decode_huffman_HuffmanCode(2,3), decode_huffman_HuffmanCode(4,5)]
                    _g2 = 0
                    while (_g2 < 18):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        s.code_length_code_lengths[i1] = 0
                    _g3 = s.simple_code_or_skip
                    while (_g3 < 18):
                        i2 = _g3
                        _g3 = (_g3 + 1)
                        if (space <= 0):
                            break
                        code_len_idx = python_internal_ArrayImpl._get(decode_Decode.kCodeLengthCodeOrder, i2)
                        p_off = 0
                        v = None
                        decode_BitReader.BrotliFillBitWindow(br)
                        p_off = (0 + ((HxOverrides.rshift(br.val_, br.bit_pos_) & 15)))
                        br.bit_pos_ = (br.bit_pos_ + (huff[p_off] if p_off >= 0 and p_off < len(huff) else None).bits)
                        v = (huff[p_off] if p_off >= 0 and p_off < len(huff) else None).value
                        s.code_length_code_lengths[code_len_idx] = v
                        if (v != 0):
                            space = (space - ((32 >> v)))
                            num_codes = (num_codes + 1)
                    if (not (((num_codes == 1) or ((space == 0))))):
                        return 0
                    s.sub_state[1] = 60
            if ((s.sub_state[1] == 60) or ((s.sub_state[1] == 61))):
                result = decode_Decode.ReadHuffmanCodeLengths(s.code_length_code_lengths,alphabet_size,s.code_lengths,s)
                if (result != 1):
                    return result
                s.sub_state[1] = 62
            if (s.sub_state[1] == 62):
                table_size = decode_Huffman.BrotliBuildHuffmanTable(table,table_off,8,s.code_lengths,alphabet_size)
                if (table_size == 0):
                    print("[ReadHuffmanCode] BuildHuffmanTable failed: ")
                    return 0
                s.code_lengths = None
                if (opt_table_size is not None):
                    python_internal_ArrayImpl._set(opt_table_size, 0, table_size)
                s.sub_state[1] = 50
                return result

    @staticmethod
    def ReadBlockLength(table,table_off,br):
        code = None
        nbits = None
        code = decode_Decode.ReadSymbol(table,table_off,br)
        nbits = python_internal_ArrayImpl._get(decode_Prefix.kBlockLengthPrefixCode, code).nbits
        return (python_internal_ArrayImpl._get(decode_Prefix.kBlockLengthPrefixCode, code).offset + decode_BitReader.BrotliReadBits(br,nbits))

    @staticmethod
    def TranslateShortCodes(code,ringbuffer,index):
        val = None
        if (code < 16):
            index = (index + python_internal_ArrayImpl._get(decode_Decode.kDistanceShortCodeIndexOffset, code))
            index = (index & 3)
            val = (ringbuffer[index] + python_internal_ArrayImpl._get(decode_Decode.kDistanceShortCodeValueOffset, code))
        else:
            val = ((code - 16) + 1)
        return val

    @staticmethod
    def InverseMoveToFrontTransform(v,v_len):
        mtf = [None]*256
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            mtf[i] = i
        _g1 = 0
        while (_g1 < v_len):
            i1 = _g1
            _g1 = (_g1 + 1)
            index = v[i1]
            value = mtf[index]
            v[i1] = value
            while True:
                aNeg = (index < 0)
                if (not ((aNeg if ((aNeg != False)) else (index > 0)))):
                    break
                val = mtf[(index - 1)]
                mtf[index] = val
                index = (index - 1)
            mtf[0] = value

    @staticmethod
    def HuffmanTreeGroupDecode(group,s):
        if (s.sub_state[0] == 50):
            s.next = group.codes
            s.htree_index = 0
            s.sub_state[0] = 70
        if (s.sub_state[0] == 70):
            next_off = 0
            while (s.htree_index < group.num_htrees):
                table_size = []
                result = decode_Decode.ReadHuffmanCode(group.alphabet_size,s.next,next_off,table_size,s)
                if (result != 1):
                    return result
                python_internal_ArrayImpl._set(group.htrees, s.htree_index, s.next)
                python_internal_ArrayImpl._set(group.htrees_off, s.htree_index, next_off)
                next_off = (next_off + (table_size[0] if 0 < len(table_size) else None))
                if ((table_size[0] if 0 < len(table_size) else None) == 0):
                    return 0
                s.htree_index = (s.htree_index + 1)
            s.sub_state[0] = 50
            return 1
        return 0

    @staticmethod
    def DecodeContextMap(context_map_size,num_htrees,context_map,s):
        br = s.br
        result = 1
        use_rle_for_zeros = None
        if (s.sub_state[0] == 50):
            if (not decode_BitReader.BrotliReadMoreInput(br)):
                return 2
            python_internal_ArrayImpl._set(num_htrees, 0, (decode_Decode.DecodeVarLenUint8(br) + 1))
            s.context_index = 0
            python_internal_ArrayImpl._set(context_map, 0, FunctionMalloc.mallocUInt(context_map_size))
            if (len((context_map[0] if 0 < len(context_map) else None)) == 0):
                return 0
            if ((num_htrees[0] if 0 < len(num_htrees) else None) <= 1):
                DefaultFunctions.memset_UInt((context_map[0] if 0 < len(context_map) else None),0,0,context_map_size)
                return 1
            use_rle_for_zeros = decode_BitReader.BrotliReadBits(br,1)
            if (use_rle_for_zeros == 1):
                s.max_run_length_prefix = (decode_BitReader.BrotliReadBits(br,4) + 1)
            else:
                s.max_run_length_prefix = 0
            s.context_map_table = FunctionMalloc.malloc2_decode_huffman_HuffmanCode(decode_huffman_HuffmanCode,1080)
            if (s.context_map_table is None):
                return 0
            s.sub_state[0] = 80
        if (s.sub_state[0] == 80):
            result = decode_Decode.ReadHuffmanCode(((num_htrees[0] if 0 < len(num_htrees) else None) + s.max_run_length_prefix),s.context_map_table,0,None,s)
            if (result != 1):
                return result
            s.sub_state[0] = 81
        if (s.sub_state[0] == 81):
            while (s.context_index < context_map_size):
                code = None
                if (not decode_BitReader.BrotliReadMoreInput(br)):
                    return 2
                code = decode_Decode.ReadSymbol(s.context_map_table,0,br)
                if (code == 0):
                    (context_map[0] if 0 < len(context_map) else None)[s.context_index] = 0
                    s.context_index = (s.context_index + 1)
                elif (code <= s.max_run_length_prefix):
                    reps = ((1 + ((1 << code))) + decode_BitReader.BrotliReadBits(br,code))
                    while True:
                        reps = (reps - 1)
                        tmp = reps
                        if (not ((tmp > 0))):
                            break
                        if (s.context_index >= context_map_size):
                            return 0
                        (context_map[0] if 0 < len(context_map) else None)[s.context_index] = 0
                        s.context_index = (s.context_index + 1)
                else:
                    val = (code - s.max_run_length_prefix)
                    (context_map[0] if 0 < len(context_map) else None)[s.context_index] = val
                    s.context_index = (s.context_index + 1)
            if (decode_BitReader.BrotliReadBits(br,1) == 1):
                decode_Decode.InverseMoveToFrontTransform((context_map[0] if 0 < len(context_map) else None),context_map_size)
            s.context_map_table = None
            s.sub_state[0] = 50
            return 1
        return 0

    @staticmethod
    def DecodeBlockType(max_block_type,trees,tree_type,block_types,ringbuffers,indexes,br):
        ringbuffer_off = (tree_type * 2)
        type_code = decode_Decode.ReadSymbol(trees,(tree_type * 1080),br)
        block_type = None
        if (type_code == 0):
            block_type = ringbuffers[(ringbuffer_off + ((indexes[tree_type] & 1)))]
        elif (type_code == 1):
            block_type = (ringbuffers[(ringbuffer_off + (((indexes[tree_type] - 1) & 1)))] + 1)
        else:
            block_type = (type_code - 2)
        if (block_type >= max_block_type):
            block_type = (block_type - max_block_type)
        block_types[tree_type] = block_type
        ringbuffers[(ringbuffer_off + ((indexes[tree_type] & 1)))] = block_type
        val = (indexes[tree_type] + 1)
        indexes[tree_type] = val

    @staticmethod
    def DecodeBlockTypeWithContext(s,br):
        decode_Decode.DecodeBlockType(s.num_block_types[0],s.block_type_trees,0,s.block_type,s.block_type_rb,s.block_type_rb_index,br)
        this1 = s.block_length
        val = decode_Decode.ReadBlockLength(s.block_len_trees,0,br)
        this1[0] = val
        s.context_offset = (s.block_type[0] << 6)
        s.context_map_slice = s.context_map
        s.context_map_slice_off = (s.context_map_off + s.context_offset)
        s.literal_htree_index = s.context_map_slice[s.context_map_slice_off]
        s.context_mode = s.context_modes[s.block_type[0]]
        s.context_lookup_offset1 = python_internal_ArrayImpl._get(decode_Context.kContextLookupOffsets, s.context_mode)
        s.context_lookup_offset2 = python_internal_ArrayImpl._get(decode_Context.kContextLookupOffsets, (s.context_mode + 1))

    @staticmethod
    def CopyUncompressedBlockToOutput(output,pos,s):
        rb_size = (s.ringbuffer_mask + 1)
        ringbuffer_end = s.ringbuffer
        ringbuffer_end_off = (s.ringbuffer_off + rb_size)
        rb_pos = (pos & s.ringbuffer_mask)
        br_pos = (s.br.pos_ & 8191)
        remaining_bits = None
        num_read = None
        num_written = None
        while True:
            if (s.sub_state[0] == 50):
                tmp = None
                if (s.meta_block_remaining_len >= 8):
                    a = (s.br.bit_pos_ + ((s.meta_block_remaining_len << 3)))
                    b = s.br.bit_end_pos_
                    aNeg = (b < 0)
                    if (aNeg != ((a < 0))):
                        tmp = aNeg
                    else:
                        tmp = (b > a)
                else:
                    tmp = True
                if tmp:
                    s.sub_state[0] = 51
                    continue
                a1 = s.br.bit_end_pos_
                if (False if ((False != ((a1 < 0)))) else (64 > a1)):
                    return 0
                remaining_bits = 32
                while True:
                    a2 = s.br.bit_pos_
                    if (not ((False if ((False != ((a2 < 0)))) else (remaining_bits > a2)))):
                        break
                    val = (HxOverrides.rshift(s.br.val_, s.br.bit_pos_) & 255)
                    s.ringbuffer[(s.ringbuffer_off + rb_pos)] = val
                    s.br.bit_pos_ = (s.br.bit_pos_ + 8)
                    rb_pos = (rb_pos + 1)
                    s.meta_block_remaining_len = (s.meta_block_remaining_len - 1)
                s.nbytes = HxOverrides.rshift((s.br.bit_end_pos_ - s.br.bit_pos_), 3)
                if ((br_pos + s.nbytes) > 8191):
                    tail = (8192 - br_pos)
                    DefaultFunctions.memcpy_UInt(s.ringbuffer,(s.ringbuffer_off + rb_pos),s.br.buf_,(s.br.buf_off + br_pos),tail)
                    s.nbytes = (s.nbytes - tail)
                    rb_pos = (rb_pos + tail)
                    s.meta_block_remaining_len = (s.meta_block_remaining_len - tail)
                    br_pos = 0
                DefaultFunctions.memcpy_UInt(s.ringbuffer,(s.ringbuffer_off + rb_pos),s.br.buf_,(s.br.buf_off + br_pos),s.nbytes)
                rb_pos = (rb_pos + s.nbytes)
                s.meta_block_remaining_len = (s.meta_block_remaining_len - s.nbytes)
                s.partially_written = 0
                s.sub_state[0] = 55
            if (s.sub_state[0] == 55):
                if (rb_pos >= rb_size):
                    num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,(s.ringbuffer_off + s.partially_written),(rb_size - s.partially_written))
                    if (num_written < 0):
                        return 0
                    s.partially_written = (s.partially_written + num_written)
                    if (s.partially_written < rb_size):
                        return 3
                    rb_pos = (rb_pos - rb_size)
                    s.meta_block_remaining_len = (s.meta_block_remaining_len + rb_size)
                    DefaultFunctions.memcpy_UInt(s.ringbuffer,s.ringbuffer_off,ringbuffer_end,ringbuffer_end_off,rb_pos)
                s.sub_state[0] = 52
                continue
            if (s.sub_state[0] == 51):
                while (s.meta_block_remaining_len > 0):
                    if (not decode_BitReader.BrotliReadMoreInput(s.br)):
                        return 2
                    this1 = s.ringbuffer
                    index = rb_pos
                    rb_pos = (rb_pos + 1)
                    val1 = decode_BitReader.BrotliReadBits(s.br,8)
                    this1[index] = val1
                    if (rb_pos == rb_size):
                        s.partially_written = 0
                        s.sub_state[0] = 56
                        break
                    s.meta_block_remaining_len = (s.meta_block_remaining_len - 1)
                if (s.sub_state[0] == 51):
                    s.sub_state[0] = 50
                    return 1
                s.sub_state[0] = 56
            if (s.sub_state[0] == 56):
                num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,(s.ringbuffer_off + s.partially_written),(rb_size - s.partially_written))
                if (num_written < 0):
                    return 0
                s.partially_written = (s.partially_written + num_written)
                if (s.partially_written < rb_size):
                    return 3
                rb_pos = 0
                s.meta_block_remaining_len = (s.meta_block_remaining_len - 1)
                s.sub_state[0] = 51
                continue
            if (s.sub_state[0] == 52):
                if ((rb_pos + s.meta_block_remaining_len) >= rb_size):
                    s.nbytes = (rb_size - rb_pos)
                    if (decode_Streams.BrotliRead(s.br.input_,s.ringbuffer,(s.ringbuffer_off + rb_pos),s.nbytes) < s.nbytes):
                        return 2
                    s.partially_written = 0
                    s.sub_state[0] = 57
                else:
                    s.sub_state[0] = 53
                    continue
            if (s.sub_state[0] == 57):
                num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,(s.ringbuffer_off + s.partially_written),(rb_size - s.partially_written))
                if (num_written < 0):
                    return 0
                s.partially_written = (s.partially_written + num_written)
                if (s.partially_written < rb_size):
                    return 3
                s.meta_block_remaining_len = (s.meta_block_remaining_len - s.nbytes)
                rb_pos = 0
                s.sub_state[0] = 52
                continue
            if (s.sub_state[0] == 53):
                num_read = decode_Streams.BrotliRead(s.br.input_,s.ringbuffer,(s.ringbuffer_off + rb_pos),s.meta_block_remaining_len)
                s.meta_block_remaining_len = (s.meta_block_remaining_len - num_read)
                if (s.meta_block_remaining_len > 0):
                    return 2
                decode_BitReader.BrotliInitBitReader(s.br,s.br.input_,s.br.finish_)
                s.sub_state[0] = 54
            if (s.sub_state[0] == 54):
                if (not decode_BitReader.BrotliWarmupBitReader(s.br)):
                    return 2
                s.sub_state[0] = 50
                return 1

    @staticmethod
    def BrotliDecompressedSize(encoded_size,encoded_buffer,encoded_buffer_off,decoded_size):
        val = 0
        bit_pos = 0
        is_last = None
        is_uncompressed = 0
        size_nibbles = None
        meta_block_len = 0
        if (encoded_size == 0):
            return 0
        _g = 0
        while (_g < 4):
            i = _g
            _g = (_g + 1)
            if (i >= encoded_size):
                break
            val = (val | (encoded_buffer[i] << ((8 * i))))
        bit_pos = 1
        if (((val & 1)) == 1):
            bit_pos = 4
            if (((HxOverrides.rshift(val, 1) & 7)) == 0):
                bit_pos = 7
        is_last = (HxOverrides.rshift(val, bit_pos) & 1)
        bit_pos = (bit_pos + 1)
        if (is_last == 1):
            if (((HxOverrides.rshift(val, bit_pos) & 1)) == 1):
                python_internal_ArrayImpl._set(decoded_size, 0, 0)
                return 1
            bit_pos = (bit_pos + 1)
        size_nibbles = (((HxOverrides.rshift(val, bit_pos) & 3)) + 4)
        if (size_nibbles == 7):
            return 0
        bit_pos = (bit_pos + 2)
        _g1 = 0
        while (_g1 < size_nibbles):
            i1 = _g1
            _g1 = (_g1 + 1)
            meta_block_len = (meta_block_len | (((HxOverrides.rshift(val, bit_pos) & 15)) << ((4 * i1))))
            bit_pos = (bit_pos + 4)
        meta_block_len = (meta_block_len + 1)
        if (is_last == 1):
            python_internal_ArrayImpl._set(decoded_size, 0, meta_block_len)
            return 1
        is_uncompressed = (HxOverrides.rshift(val, bit_pos) & 1)
        bit_pos = (bit_pos + 1)
        if (is_uncompressed == 1):
            offset = ((((bit_pos + 7) >> 3)) + meta_block_len)
            if ((offset < encoded_size) and ((((encoded_buffer[offset] & 3)) == 3))):
                python_internal_ArrayImpl._set(decoded_size, 0, meta_block_len)
                return 1
        return 0

    @staticmethod
    def BrotliDecompressStreaming(input,output,finish,s):
        context = None
        pos = s.pos
        i = s.loop_counter
        result = 1
        br = s.br
        initial_remaining_len = None
        bytes_copied = None
        num_written = None
        s.br.input_ = input
        s.br.finish_ = finish
        while True:
            if (result != 1):
                if ((result == 2) and ((finish == 1))):
                    print(str((("Unexpected end of input. State: " + Std.string(s.state)) + "\n")))
                    result = 0
                break
            if (s.state == 0):
                pos = 0
                s.input_end = 0
                s.window_bits = 0
                s.max_distance = 0
                s.dist_rb[0] = 16
                s.dist_rb[1] = 15
                s.dist_rb[2] = 11
                s.dist_rb[3] = 4
                s.dist_rb_idx = 0
                s.prev_byte1 = 0
                s.prev_byte2 = 0
                s.block_type_trees = None
                s.block_len_trees = None
                decode_BitReader.BrotliInitBitReader(br,input,finish)
                s.state = 1
            if (s.state == 1):
                if (not decode_BitReader.BrotliWarmupBitReader(br)):
                    result = 2
                    continue
                s.window_bits = decode_Decode.DecodeWindowBits(br)
                if (s.window_bits == 9):
                    result = 0
                    continue
                s.max_backward_distance = (((1 << s.window_bits)) - 16)
                s.block_type_trees = FunctionMalloc.malloc2_decode_huffman_HuffmanCode(decode_huffman_HuffmanCode,3240)
                s.block_len_trees = FunctionMalloc.malloc2_decode_huffman_HuffmanCode(decode_huffman_HuffmanCode,3240)
                if ((s.block_type_trees is None) or ((s.block_len_trees is None))):
                    result = 0
                    continue
                s.state = 10
            if (s.state == 10):
                if (s.input_end != 0):
                    s.partially_written = 0
                    s.state = 100
                    continue
                s.meta_block_remaining_len = 0
                s.block_length[0] = 268435456
                s.block_length[1] = 268435456
                s.block_length[2] = 268435456
                s.block_type[0] = 0
                s.num_block_types[0] = 1
                s.num_block_types[1] = 1
                s.num_block_types[2] = 1
                s.block_type_rb[0] = 0
                s.block_type_rb[1] = 1
                s.block_type_rb[2] = 0
                s.block_type_rb[3] = 1
                s.block_type_rb[4] = 0
                s.block_type_rb[5] = 1
                s.block_type_rb_index[0] = 0
                s.context_map = None
                s.context_modes = None
                s.dist_context_map = None
                s.context_offset = 0
                s.context_map_slice = None
                s.context_map_slice_off = 0
                s.literal_htree_index = 0
                s.dist_context_offset = 0
                s.dist_context_map_slice = None
                s.dist_context_map_slice_off = 0
                s.dist_htree_index = 0
                s.context_lookup_offset1 = 0
                s.context_lookup_offset2 = 0
                _g = 0
                while (_g < 3):
                    i1 = _g
                    _g = (_g + 1)
                    s.hgroup[i1].codes = None
                    s.hgroup[i1].htrees = None
                s.state = 11
            if (s.state == 11):
                if (not decode_BitReader.BrotliReadMoreInput(br)):
                    result = 2
                    continue
                meta_block_remaining_len = [s.meta_block_remaining_len]
                input_end = [s.input_end]
                is_metadata = [s.is_metadata]
                is_uncompressed = [s.is_uncompressed]
                if (not decode_Decode.DecodeMetaBlockLength(br,meta_block_remaining_len,input_end,is_metadata,is_uncompressed)):
                    result = 0
                    continue
                s.meta_block_remaining_len = (meta_block_remaining_len[0] if 0 < len(meta_block_remaining_len) else None)
                s.input_end = (input_end[0] if 0 < len(input_end) else None)
                s.is_metadata = (is_metadata[0] if 0 < len(is_metadata) else None)
                s.is_uncompressed = (is_uncompressed[0] if 0 < len(is_uncompressed) else None)
                if (s.ringbuffer is None):
                    known_size = [0]
                    s.ringbuffer_size = (1 << s.window_bits)
                    if (decode_Decode.BrotliDecompressedSize(4096,br.buf_,br.buf_off,known_size) == 1):
                        while ((s.ringbuffer_size >= (((known_size[0] if 0 < len(known_size) else None) * 2))) and ((s.ringbuffer_size > 1))):
                            x = (s.ringbuffer_size / 2)
                            tmp = None
                            try:
                                tmp = int(x)
                            except Exception as _hx_e:
                                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                e = _hx_e1
                                tmp = None
                            s.ringbuffer_size = tmp
                    while (s.ringbuffer_size < s.custom_dict_size):
                        s.ringbuffer_size = (s.ringbuffer_size * 2)
                    s.ringbuffer_mask = (s.ringbuffer_size - 1)
                    s.ringbuffer = [None]*((s.ringbuffer_size + 4224) + 24)
                    s.ringbuffer_off = 0
                    if (len(s.ringbuffer) == 0):
                        result = 0
                        continue
                    s.ringbuffer_end = s.ringbuffer
                    s.ringbuffer_end_off = (s.ringbuffer_off + s.ringbuffer_size)
                    if (s.custom_dict_off != -1):
                        DefaultFunctions.memcpy_UInt(s.ringbuffer,(s.ringbuffer_off + ((-s.custom_dict_size & s.ringbuffer_mask))),s.custom_dict,s.custom_dict_off,s.custom_dict_size)
                        if (s.custom_dict_size > 0):
                            s.prev_byte1 = s.custom_dict[(s.custom_dict_size - 1)]
                        if (s.custom_dict_size > 1):
                            s.prev_byte2 = s.custom_dict[(s.custom_dict_size - 2)]
                if (s.is_metadata == 1):
                    if (not decode_Decode.JumpToByteBoundary(s.br)):
                        result = 0
                        continue
                    s.state = 18
                    continue
                if (s.meta_block_remaining_len == 0):
                    s.state = 20
                    continue
                if (s.is_uncompressed == 1):
                    if (not decode_Decode.JumpToByteBoundary(s.br)):
                        result = 0
                        continue
                    s.state = 17
                    continue
                i = 0
                s.state = 30
                continue
            if (s.state == 17):
                initial_remaining_len = s.meta_block_remaining_len
                result = decode_Decode.CopyUncompressedBlockToOutput(output,pos,s)
                if (result == 3):
                    continue
                bytes_copied = (initial_remaining_len - s.meta_block_remaining_len)
                pos = (pos + bytes_copied)
                if (bytes_copied > 0):
                    s.prev_byte2 = (s.prev_byte1 if ((bytes_copied == 1)) else s.ringbuffer[((pos - 2) & s.ringbuffer_mask)])
                    s.prev_byte1 = s.ringbuffer[((pos - 1) & s.ringbuffer_mask)]
                if (result != 1):
                    continue
                s.state = 20
                continue
            if (s.state == 18):
                while (s.meta_block_remaining_len > 0):
                    if (not decode_BitReader.BrotliReadMoreInput(s.br)):
                        result = 2
                        continue
                    decode_BitReader.BrotliReadBits(s.br,8)
                    s.meta_block_remaining_len = (s.meta_block_remaining_len - 1)
                s.state = 20
                continue
            if (s.state == 30):
                if (i >= 3):
                    s.num_block_types[0]
                    s.num_block_types[1]
                    s.num_block_types[2]
                    s.block_length[0]
                    s.block_length[1]
                    s.block_length[2]
                    s.state = 12
                    continue
                this1 = s.num_block_types
                val = (decode_Decode.DecodeVarLenUint8(br) + 1)
                this1[i] = val
                s.state = 31
            if (s.state == 31):
                if (s.num_block_types[i] >= 2):
                    result = decode_Decode.ReadHuffmanCode((s.num_block_types[i] + 2),s.block_type_trees,(i * 1080),None,s)
                    if (result != 1):
                        continue
                    s.state = 32
                else:
                    i = (i + 1)
                    s.state = 30
                    continue
            if (s.state == 32):
                result = decode_Decode.ReadHuffmanCode(26,s.block_len_trees,(i * 1080),None,s)
                if (result != 1):
                    break
                this2 = s.block_length
                val1 = decode_Decode.ReadBlockLength(s.block_len_trees,(i * 1080),br)
                this2[i] = val1
                s.block_type_rb_index[i] = 1
                i = (i + 1)
                s.state = 30
                continue
            if (s.state == 12):
                if (not decode_BitReader.BrotliReadInputAmount(br,128)):
                    result = 2
                    continue
                s.distance_postfix_bits = decode_BitReader.BrotliReadBits(br,2)
                s.num_direct_distance_codes = (16 + ((decode_BitReader.BrotliReadBits(br,4) << s.distance_postfix_bits)))
                s.distance_postfix_mask = (((1 << s.distance_postfix_bits)) - 1)
                s.num_distance_codes = (s.num_direct_distance_codes + ((48 << s.distance_postfix_bits)))
                s.context_modes = FunctionMalloc.mallocUInt(s.num_block_types[0])
                if (len(s.context_modes) == 0):
                    result = 0
                    continue
                _g1 = 0
                _g2 = s.num_block_types[0]
                while (_g1 < _g2):
                    i2 = _g1
                    _g1 = (_g1 + 1)
                    this3 = s.context_modes
                    val2 = (decode_BitReader.BrotliReadBits(br,2) << 1)
                    this3[i2] = val2
                s.state = 33
            if (s.state == 33):
                num_literal_htrees = [s.num_literal_htrees]
                context_map = [s.context_map]
                result = decode_Decode.DecodeContextMap((s.num_block_types[0] << 6),num_literal_htrees,context_map,s)
                s.num_literal_htrees = (num_literal_htrees[0] if 0 < len(num_literal_htrees) else None)
                s.context_map = (context_map[0] if 0 < len(context_map) else None)
                s.context_map_off = 0
                s.trivial_literal_context = 1
                _g11 = 0
                _g3 = (s.num_block_types[0] << 6)
                while (_g11 < _g3):
                    i3 = _g11
                    _g11 = (_g11 + 1)
                    if (s.context_map[i3] != ((i3 >> 6))):
                        s.trivial_literal_context = 0
                        continue
                if (result != 1):
                    continue
                s.state = 34
            if (s.state == 34):
                num_dist_htrees = [s.num_dist_htrees]
                dist_context_map = [s.dist_context_map]
                result = decode_Decode.DecodeContextMap((s.num_block_types[2] << 2),num_dist_htrees,dist_context_map,s)
                s.num_dist_htrees = (num_dist_htrees[0] if 0 < len(num_dist_htrees) else None)
                s.dist_context_map = (dist_context_map[0] if 0 < len(dist_context_map) else None)
                s.dist_context_map_off = 0
                if (result != 1):
                    continue
                decode_Huffman.BrotliHuffmanTreeGroupInit(s.hgroup[0],256,s.num_literal_htrees)
                decode_Huffman.BrotliHuffmanTreeGroupInit(s.hgroup[1],704,s.num_block_types[1])
                decode_Huffman.BrotliHuffmanTreeGroupInit(s.hgroup[2],s.num_distance_codes,s.num_dist_htrees)
                i = 0
                s.state = 35
            if (s.state == 35):
                result = decode_Decode.HuffmanTreeGroupDecode(s.hgroup[i],s)
                if (result != 1):
                    continue
                i = (i + 1)
                if (i >= 3):
                    s.context_map_slice = s.context_map
                    s.context_map_slice_off = s.context_map_off
                    s.dist_context_map_slice = s.dist_context_map
                    s.dist_context_map_slice_off = s.dist_context_map_off
                    s.context_mode = s.context_modes[s.block_type[0]]
                    s.context_lookup_offset1 = python_internal_ArrayImpl._get(decode_Context.kContextLookupOffsets, s.context_mode)
                    s.context_lookup_offset2 = python_internal_ArrayImpl._get(decode_Context.kContextLookupOffsets, (s.context_mode + 1))
                    s.htree_command = python_internal_ArrayImpl._get(s.hgroup[1].htrees, 0)
                    s.htree_command_off = python_internal_ArrayImpl._get(s.hgroup[1].htrees_off, 0)
                    s.state = 13
                    continue
                continue
            if (s.state == 13):
                if (not decode_BitReader.BrotliReadMoreInput(br)):
                    result = 2
                    continue
                if (s.meta_block_remaining_len <= 0):
                    pos = (pos & 1073741823)
                    s.state = 20
                    continue
                if (s.block_length[1] == 0):
                    decode_Decode.DecodeBlockType(s.num_block_types[1],s.block_type_trees,1,s.block_type,s.block_type_rb,s.block_type_rb_index,br)
                    this4 = s.block_length
                    val3 = decode_Decode.ReadBlockLength(s.block_len_trees,1080,br)
                    this4[1] = val3
                    s.htree_command = python_internal_ArrayImpl._get(s.hgroup[1].htrees, s.block_type[1])
                    s.htree_command_off = python_internal_ArrayImpl._get(s.hgroup[1].htrees_off, s.block_type[1])
                this5 = s.block_length
                val4 = (s.block_length[1] - 1)
                this5[1] = val4
                s.cmd_code = decode_Decode.ReadSymbol(s.htree_command,s.htree_command_off,br)
                s.range_idx = (s.cmd_code >> 6)
                if (s.range_idx >= 2):
                    s.range_idx = (s.range_idx - 2)
                    s.distance_code = -1
                else:
                    s.distance_code = 0
                s.insert_code = (python_internal_ArrayImpl._get(decode_Prefix.kInsertRangeLut, s.range_idx) + (((s.cmd_code >> 3) & 7)))
                s.copy_code = (python_internal_ArrayImpl._get(decode_Prefix.kCopyRangeLut, s.range_idx) + ((s.cmd_code & 7)))
                s.insert_length = (python_internal_ArrayImpl._get(decode_Prefix.kInsertLengthPrefixCode, s.insert_code).offset + decode_BitReader.BrotliReadBits(br,python_internal_ArrayImpl._get(decode_Prefix.kInsertLengthPrefixCode, s.insert_code).nbits))
                s.copy_length = (python_internal_ArrayImpl._get(decode_Prefix.kCopyLengthPrefixCode, s.copy_code).offset + decode_BitReader.BrotliReadBits(br,python_internal_ArrayImpl._get(decode_Prefix.kCopyLengthPrefixCode, s.copy_code).nbits))
                i = 0
                s.state = 14
            if (s.state == 14):
                if (s.trivial_literal_context == 1):
                    while (i < s.insert_length):
                        if (not decode_BitReader.BrotliReadMoreInput(br)):
                            result = 2
                            break
                        if (s.block_length[0] == 0):
                            decode_Decode.DecodeBlockTypeWithContext(s,br)
                        this6 = s.ringbuffer
                        index = (pos & s.ringbuffer_mask)
                        val5 = decode_Decode.ReadSymbol(python_internal_ArrayImpl._get(s.hgroup[0].htrees, s.literal_htree_index),python_internal_ArrayImpl._get(s.hgroup[0].htrees_off, s.literal_htree_index),br)
                        this6[index] = val5
                        this7 = s.block_length
                        val6 = (s.block_length[0] - 1)
                        this7[0] = val6
                        if (((pos & s.ringbuffer_mask)) == s.ringbuffer_mask):
                            s.partially_written = 0
                            s.state = 19
                            break
                        pos = (pos + 1)
                        i = (i + 1)
                else:
                    p1 = s.prev_byte1
                    p2 = s.prev_byte2
                    while (i < s.insert_length):
                        if (not decode_BitReader.BrotliReadMoreInput(br)):
                            result = 2
                            break
                        if (s.block_length[0] == 0):
                            decode_Decode.DecodeBlockTypeWithContext(s,br)
                        context = (python_internal_ArrayImpl._get(decode_Context.kContextLookup, (s.context_lookup_offset1 + p1)) | python_internal_ArrayImpl._get(decode_Context.kContextLookup, (s.context_lookup_offset2 + p2)))
                        s.literal_htree_index = s.context_map_slice[(s.context_map_slice_off + context)]
                        this8 = s.block_length
                        val7 = (s.block_length[0] - 1)
                        this8[0] = val7
                        p2 = p1
                        p1 = decode_Decode.ReadSymbol(python_internal_ArrayImpl._get(s.hgroup[0].htrees, s.literal_htree_index),python_internal_ArrayImpl._get(s.hgroup[0].htrees_off, s.literal_htree_index),br)
                        s.ringbuffer[(pos & s.ringbuffer_mask)] = p1
                        if (((pos & s.ringbuffer_mask)) == s.ringbuffer_mask):
                            s.partially_written = 0
                            s.state = 19
                            break
                        pos = (pos + 1)
                        i = (i + 1)
                    s.prev_byte1 = p1
                    s.prev_byte2 = p2
                if ((result != 1) or ((s.state == 19))):
                    continue
                s.meta_block_remaining_len = (s.meta_block_remaining_len - s.insert_length)
                if (s.meta_block_remaining_len <= 0):
                    s.state = 20
                    continue
                elif (s.distance_code < 0):
                    s.state = 15
                else:
                    s.state = 16
                    continue
            if (s.state == 15):
                if (not decode_BitReader.BrotliReadMoreInput(br)):
                    result = 2
                    continue
                if (s.block_length[2] == 0):
                    decode_Decode.DecodeBlockType(s.num_block_types[2],s.block_type_trees,2,s.block_type,s.block_type_rb,s.block_type_rb_index,br)
                    this9 = s.block_length
                    val8 = decode_Decode.ReadBlockLength(s.block_len_trees,2160,br)
                    this9[2] = val8
                    s.dist_context_offset = (s.block_type[2] << 2)
                    s.dist_context_map_slice = s.dist_context_map
                    s.dist_context_map_slice_off = (s.dist_context_map_off + s.dist_context_offset)
                this10 = s.block_length
                val9 = (s.block_length[2] - 1)
                this10[2] = val9
                if (s.copy_length > 4):
                    context = 3
                else:
                    context = (s.copy_length - 2)
                s.dist_htree_index = s.dist_context_map_slice[(s.dist_context_map_slice_off + context)]
                s.distance_code = decode_Decode.ReadSymbol(python_internal_ArrayImpl._get(s.hgroup[2].htrees, s.dist_htree_index),python_internal_ArrayImpl._get(s.hgroup[2].htrees_off, s.dist_htree_index),br)
                if (s.distance_code >= s.num_direct_distance_codes):
                    nbits = None
                    postfix = None
                    offset = None
                    s.distance_code = (s.distance_code - s.num_direct_distance_codes)
                    postfix = (s.distance_code & s.distance_postfix_mask)
                    s.distance_code = (s.distance_code >> s.distance_postfix_bits)
                    nbits = (((s.distance_code >> 1)) + 1)
                    offset = ((((2 + ((s.distance_code & 1))) << nbits)) - 4)
                    s.distance_code = ((s.num_direct_distance_codes + (((offset + decode_BitReader.BrotliReadBits(br,nbits)) << s.distance_postfix_bits))) + postfix)
                s.state = 16
            if (s.state == 16):
                if (not decode_BitReader.BrotliReadMoreInput(br)):
                    result = 2
                    continue
                s.distance = decode_Decode.TranslateShortCodes(s.distance_code,s.dist_rb,s.dist_rb_idx)
                if (s.distance < 0):
                    result = 0
                    continue
                if (((pos + s.custom_dict_size) < s.max_backward_distance) and ((s.max_distance != s.max_backward_distance))):
                    s.max_distance = (pos + s.custom_dict_size)
                else:
                    s.max_distance = s.max_backward_distance
                s.copy_dst = s.ringbuffer
                s.copy_dst_off = (s.ringbuffer_off + ((pos & s.ringbuffer_mask)))
                if (s.distance > s.max_distance):
                    if ((s.copy_length >= 4) and ((s.copy_length <= 24))):
                        offset1 = python_internal_ArrayImpl._get(decode_Dictionary.kBrotliDictionaryOffsetsByLength, s.copy_length)
                        word_id = ((s.distance - s.max_distance) - 1)
                        shift = python_internal_ArrayImpl._get(decode_Dictionary.kBrotliDictionarySizeBitsByLength, s.copy_length)
                        transform_idx = (word_id >> shift)
                        offset1 = (offset1 + ((((word_id & ((((1 << shift)) - 1)))) * s.copy_length)))
                        if (transform_idx < decode_Transforms.kNumTransforms):
                            _hx_len = decode_Transforms.TransformDictionaryWord(s.copy_dst,s.copy_dst_off,decode_Dictionary.kBrotliDictionary,offset1,s.copy_length,transform_idx)
                            s.copy_dst_off = (s.copy_dst_off + _hx_len)
                            pos = (pos + _hx_len)
                            s.meta_block_remaining_len = (s.meta_block_remaining_len - _hx_len)
                            if (s.copy_dst_off >= s.ringbuffer_end_off):
                                s.partially_written = 0
                                num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,s.ringbuffer_off,s.ringbuffer_size)
                                if (num_written < 0):
                                    result = 0
                                    continue
                                s.partially_written = (s.partially_written + num_written)
                                if (s.partially_written < s.ringbuffer_size):
                                    result = 3
                                    s.state = 21
                                    continue
                                DefaultFunctions.memcpy_UInt(s.ringbuffer,s.ringbuffer_off,s.ringbuffer_end,s.ringbuffer_end_off,(s.copy_dst_off - s.ringbuffer_end_off))
                        else:
                            print(str(((((((((("Invalid backward reference. pos: " + Std.string(pos)) + " distance: ") + Std.string(s.distance)) + " ") + "len: ") + Std.string(s.copy_length)) + " bytes left: ") + Std.string(s.meta_block_remaining_len)) + "\n")))
                            result = 0
                            continue
                    else:
                        print(str(((((((((("Invalid backward reference. pos: " + Std.string(pos)) + " distance: ") + Std.string(s.distance)) + " ") + "len: ") + Std.string(s.copy_length)) + " bytes left: ") + Std.string(s.meta_block_remaining_len)) + "\n")))
                        result = 0
                        continue
                else:
                    if (s.distance_code > 0):
                        val10 = s.distance
                        s.dist_rb[(s.dist_rb_idx & 3)] = val10
                        s.dist_rb_idx = (s.dist_rb_idx + 1)
                    if (s.copy_length > s.meta_block_remaining_len):
                        print(str(((((((((("Invalid backward reference. pos: " + Std.string(pos)) + " distance: ") + Std.string(s.distance)) + " ") + "len: ") + Std.string(s.copy_length)) + " bytes left: ") + Std.string(s.meta_block_remaining_len)) + "\n")))
                        result = 0
                        continue
                    s.copy_src = s.ringbuffer
                    s.copy_src_off = (s.ringbuffer_off + (((pos - s.distance) & s.ringbuffer_mask)))
                    _g12 = 0
                    _g4 = s.copy_length
                    while (_g12 < _g4):
                        _g12 = (_g12 + 1)
                        this11 = s.ringbuffer
                        index1 = (pos & s.ringbuffer_mask)
                        val11 = s.ringbuffer[((pos - s.distance) & s.ringbuffer_mask)]
                        this11[index1] = val11
                        if (((pos & s.ringbuffer_mask)) == s.ringbuffer_mask):
                            s.partially_written = 0
                            num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,s.ringbuffer_off,s.ringbuffer_size)
                            if (num_written < 0):
                                result = 0
                                continue
                            s.partially_written = (s.partially_written + num_written)
                            if (s.partially_written < s.ringbuffer_size):
                                result = 3
                                s.state = 22
                                continue
                        pos = (pos + 1)
                        s.meta_block_remaining_len = (s.meta_block_remaining_len - 1)
                    if (result == 3):
                        continue
                s.state = 23
            if (s.state == 23):
                s.prev_byte1 = s.ringbuffer[((pos - 1) & s.ringbuffer_mask)]
                s.prev_byte2 = s.ringbuffer[((pos - 2) & s.ringbuffer_mask)]
                s.state = 13
            if (((s.state == 19) or ((s.state == 21))) or ((s.state == 22))):
                num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,(s.ringbuffer_off + s.partially_written),(s.ringbuffer_size - s.partially_written))
                if (num_written < 0):
                    result = 0
                    continue
                s.partially_written = (s.partially_written + num_written)
                if (s.partially_written < s.ringbuffer_size):
                    result = 3
                    continue
                if (s.state == 21):
                    DefaultFunctions.memcpy_UInt(s.ringbuffer,s.ringbuffer_off,s.ringbuffer_end,s.ringbuffer_end_off,(s.copy_dst_off - s.ringbuffer_end_off))
                    s.state = 23
                elif (s.state == 22):
                    pos = (pos + 1)
                    s.meta_block_remaining_len = (s.meta_block_remaining_len - 1)
                    i = (i + 1)
                    while (i < s.copy_length):
                        this12 = s.ringbuffer
                        index2 = (pos & s.ringbuffer_mask)
                        val12 = s.ringbuffer[((pos - s.distance) & s.ringbuffer_mask)]
                        this12[index2] = val12
                        if (((pos & s.ringbuffer_mask)) == s.ringbuffer_mask):
                            s.partially_written = 0
                            num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,s.ringbuffer_off,s.ringbuffer_size)
                            if (num_written < 0):
                                result = 0
                                continue
                            s.partially_written = (s.partially_written + num_written)
                            if (s.partially_written < s.ringbuffer_size):
                                result = 3
                                continue
                        pos = (pos + 1)
                        s.meta_block_remaining_len = (s.meta_block_remaining_len - 1)
                        i = (i + 1)
                    if (result == 3):
                        continue
                    s.state = 23
                else:
                    pos = (pos + 1)
                    i = (i + 1)
                    s.state = 14
                continue
            if (s.state == 20):
                if (s.context_modes is not None):
                    s.context_modes = None
                if (s.context_map is not None):
                    s.context_map = None
                if (s.dist_context_map is not None):
                    s.dist_context_map = None
                _g5 = 0
                while (_g5 < 3):
                    i4 = _g5
                    _g5 = (_g5 + 1)
                    s.hgroup[i4]
                    s.hgroup[i4].codes = None
                    s.hgroup[i4].htrees = None
                s.state = 10
                continue
            if (s.state == 100):
                if (len(s.ringbuffer) != 0):
                    num_written = decode_Streams.BrotliWrite(output,s.ringbuffer,(s.ringbuffer_off + s.partially_written),(((pos & s.ringbuffer_mask)) - s.partially_written))
                    if (num_written < 0):
                        return 0
                    def _hx_local_36():
                        s.partially_written = (s.partially_written + num_written)
                        return s.partially_written
                    if ((_hx_local_36()) < ((pos & s.ringbuffer_mask))):
                        result = 3
                        break
                if (not decode_Decode.JumpToByteBoundary(s.br)):
                    result = 0
                return result
        s.pos = pos
        s.loop_counter = i
        return result

    @staticmethod
    def BrotliDecompress(input,output):
        s = decode_state_BrotliState()
        decode_State.BrotliStateInit(s)
        decode_Decode.BrotliDecompressStreaming(input,output,1,s)
        return 1


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                if (HxString.substr(x,0,2).lower() == "0x"):
                    return int(x,16)
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                if (r is None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g1 = 0
        _g = len(x)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            elif (((((((((((_g2 == 57) or ((_g2 == 56))) or ((_g2 == 55))) or ((_g2 == 54))) or ((_g2 == 53))) or ((_g2 == 52))) or ((_g2 == 51))) or ((_g2 == 50))) or ((_g2 == 49))) or ((_g2 == 48))) or ((_g2 == 46))):
                r = (("null" if r is None else r) + ("null" if c is None else c))
            else:
                break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["startsWith"]

    @staticmethod
    def startsWith(s,start):
        if (len(s) >= len(start)):
            return (HxString.substr(s,0,len(start)) == start)
        else:
            return False


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "fullPath"]

    @staticmethod
    def exists(path):
        return os.path.exists(path)

    @staticmethod
    def fullPath(relPath):
        return os.path.realpath(relPath)


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]

    def __init__(self):
        self.h = dict()



class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.next()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

class decode_BitReader:
    _hx_class_name = "decode.BitReader"
    __slots__ = ()
    _hx_statics = ["BROTLI_MAX_NUM_BIT_READ", "BROTLI_READ_SIZE", "BROTLI_IBUF_SIZE", "BROTLI_IBUF_MASK", "kBitMask", "BitMask", "ShiftBytes32", "BrotliReadMoreInput", "BrotliReadInputAmount", "BrotliFillBitWindow", "BrotliInitBitReader", "BrotliWarmupBitReader", "BrotliReadBits"]

    def __init__(self):
        pass

    @staticmethod
    def BitMask(n):
        return python_internal_ArrayImpl._get(decode_BitReader.kBitMask, n)

    @staticmethod
    def ShiftBytes32(br):
        while True:
            a = br.bit_pos_
            aNeg = (a < 0)
            if (not ((aNeg if ((aNeg != False)) else (a >= 8)))):
                break
            br.val_ = HxOverrides.rshift(br.val_, 8)
            a1 = br.val_
            a2 = br.buf_[(br.pos_ & 8191)]
            x = Math.pow(2,24)
            b = None
            try:
                b = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                b = None
            br.val_ = (a1 | (a2 * b))
            br.pos_ = (br.pos_ + 1)
            br.bit_pos_ = (br.bit_pos_ - 8)
            br.bit_end_pos_ = (br.bit_end_pos_ - 8)

    @staticmethod
    def BrotliReadMoreInput(br):
        a = br.bit_end_pos_
        aNeg = (a < 0)
        if (aNeg if ((aNeg != False)) else (a > 256)):
            return True
        elif (br.eos_ > 0):
            a1 = br.bit_pos_
            b = br.bit_end_pos_
            aNeg1 = (b < 0)
            if (aNeg1 != ((a1 < 0))):
                return aNeg1
            else:
                return (b >= a1)
        else:
            dst = br.buf_ptr_
            dst_off = br.buf_ptr_off
            bytes_read = decode_Streams.BrotliRead(br.input_,dst,(dst_off + br.tmp_bytes_read_),(4096 - br.tmp_bytes_read_))
            if (bytes_read < 0):
                return False
            bytes_read = (bytes_read + br.tmp_bytes_read_)
            br.tmp_bytes_read_ = 0
            if (bytes_read < 4096):
                if (br.finish_ <= 0):
                    br.tmp_bytes_read_ = bytes_read
                    return False
                br.eos_ = 1
                DefaultFunctions.memset_UInt(dst,(dst_off + bytes_read),0,32)
            if (dst_off == br.buf_off):
                DefaultFunctions.memcpy_UInt(br.buf_,(br.buf_off + 8192),br.buf_,br.buf_off,32)
                br.buf_ptr_ = br.buf_
                br.buf_ptr_off = (br.buf_off + 4096)
            else:
                br.buf_ptr_ = br.buf_
                br.buf_ptr_off = br.buf_off
            br.bit_end_pos_ = (br.bit_end_pos_ + ((bytes_read << 3)))
            return True

    @staticmethod
    def BrotliReadInputAmount(br,num):
        a = br.bit_end_pos_
        b = (num << 3)
        aNeg = (a < 0)
        if (aNeg if ((aNeg != ((b < 0)))) else (a > b)):
            return True
        elif (br.eos_ > 0):
            a1 = br.bit_pos_
            b1 = br.bit_end_pos_
            aNeg1 = (b1 < 0)
            if (aNeg1 != ((a1 < 0))):
                return aNeg1
            else:
                return (b1 >= a1)
        else:
            dst = br.buf_ptr_
            dst_off = br.buf_ptr_off
            bytes_read = decode_Streams.BrotliRead(br.input_,dst,(dst_off + br.tmp_bytes_read_),(4096 - br.tmp_bytes_read_))
            if (bytes_read < 0):
                return False
            bytes_read = (bytes_read + br.tmp_bytes_read_)
            br.tmp_bytes_read_ = 0
            if (bytes_read < 4096):
                if (br.finish_ <= 0):
                    br.tmp_bytes_read_ = bytes_read
                    return False
                br.eos_ = 1
                DefaultFunctions.memset_UInt(dst,(dst_off + bytes_read),0,num)
            if (dst_off == br.buf_off):
                DefaultFunctions.memcpy_UInt(br.buf_,(br.buf_off + 8192),br.buf_,br.buf_off,num)
                br.buf_ptr_ = br.buf_
                br.buf_ptr_off = (br.buf_off + 4096)
            else:
                br.buf_ptr_ = br.buf_
                br.buf_ptr_off = br.buf_off
            br.bit_end_pos_ = (br.bit_end_pos_ + ((bytes_read << 3)))
            return True

    @staticmethod
    def BrotliFillBitWindow(br):
        decode_BitReader.ShiftBytes32(br)

    @staticmethod
    def BrotliInitBitReader(br,input,finish):
        br.finish_ = finish
        br.tmp_bytes_read_ = 0
        br.buf_ptr_ = br.buf_
        br.buf_ptr_off = br.buf_off
        br.input_ = input
        br.val_ = 0
        br.pos_ = 0
        br.bit_pos_ = 0
        br.bit_end_pos_ = 0
        br.eos_ = 0

    @staticmethod
    def BrotliWarmupBitReader(br):
        if (not decode_BitReader.BrotliReadMoreInput(br)):
            return False
        _g = 0
        while (_g < 4):
            i = _g
            _g = (_g + 1)
            br.val_ = (br.val_ | (br.buf_[br.pos_] << ((8 * i))))
            br.pos_ = (br.pos_ + 1)
        a = br.bit_end_pos_
        aNeg = (a < 0)
        if (aNeg != False):
            return aNeg
        else:
            return (a > 0)

    @staticmethod
    def BrotliReadBits(br,n_bits):
        val = None
        a = (32 - br.bit_pos_)
        aNeg = (n_bits < 0)
        if (aNeg if ((aNeg != ((a < 0)))) else (n_bits > a)):
            decode_BitReader.BrotliFillBitWindow(br)
        val = (HxOverrides.rshift(br.val_, br.bit_pos_) & decode_BitReader.BitMask(n_bits))
        br.bit_pos_ = (br.bit_pos_ + n_bits)
        return val


class decode_Context:
    _hx_class_name = "decode.Context"
    __slots__ = ()
    _hx_statics = ["kContextLookup", "kContextLookupOffsets"]

    def __init__(self):
        pass


class decode_Dictionary:
    _hx_class_name = "decode.Dictionary"
    __slots__ = ()
    _hx_statics = ["kBrotliDictionary", "kBrotliDictionaryOffsetsByLength", "kBrotliDictionarySizeBitsByLength", "kMinDictionaryWordLength", "kMaxDictionaryWordLength"]

    def __init__(self):
        pass
    kBrotliDictionary = None


class decode_Huffman:
    _hx_class_name = "decode.Huffman"
    __slots__ = ()
    _hx_statics = ["BROTLI_HUFFMAN_MAX_TABLE_SIZE", "MAX_LENGTH", "MAX_CODE_LENGTHS_SIZE", "GetNextKey", "ReplicateValue", "NextTableBitSize", "BrotliBuildHuffmanTable", "BrotliHuffmanTreeGroupInit", "BrotliHuffmanTreeGroupRelease"]

    def __init__(self):
        pass

    @staticmethod
    def GetNextKey(key,_hx_len):
        step = (1 << ((_hx_len - 1)))
        while (((key & step)) > 0):
            step = (step >> 1)
        return (((key & ((step - 1)))) + step)

    @staticmethod
    def ReplicateValue(table,table_off,step,end,code):
        while True:
            end = (end - step)
            val = decode_huffman_HuffmanCode(code.bits,code.value)
            table[(table_off + end)] = val
            if (not ((end > 0))):
                break

    @staticmethod
    def NextTableBitSize(count,_hx_len,root_bits):
        left = (1 << ((_hx_len - root_bits)))
        while (_hx_len < 15):
            left = (left - count[_hx_len])
            if (left <= 0):
                break
            _hx_len = (_hx_len + 1)
            left = (left << 1)
        return (_hx_len - root_bits)

    @staticmethod
    def BrotliBuildHuffmanTable(root_table,root_table_off,root_bits,code_lengths,code_lengths_size):
        code = decode_huffman_HuffmanCode(0,0)
        table_off = None
        symbol = None
        key = None
        step = None
        low = None
        mask = None
        table_bits = None
        table_size = None
        total_size = None
        sorted = FunctionMalloc.mallocInt(704)
        count = FunctionMalloc.mallocInt(16)
        offset = FunctionMalloc.mallocInt(16)
        if (code_lengths_size > 704):
            return 0
        _g1 = 0
        while (_g1 < code_lengths_size):
            symbol1 = _g1
            _g1 = (_g1 + 1)
            _g2 = code_lengths[symbol1]
            val = (count[_g2] + 1)
            count[_g2] = val
        offset[1] = 0
        _g = 1
        while (_g < 15):
            len = _g
            _g = (_g + 1)
            val1 = (offset[len] + count[len])
            offset[(len + 1)] = val1
        _g11 = 0
        while (_g11 < code_lengths_size):
            symbol2 = _g11
            _g11 = (_g11 + 1)
            if (code_lengths[symbol2] != 0):
                sorted[offset[code_lengths[symbol2]]] = symbol2
                _g21 = code_lengths[symbol2]
                val2 = (offset[_g21] + 1)
                offset[_g21] = val2
        table_off = root_table_off
        table_bits = root_bits
        table_size = (1 << root_bits)
        total_size = table_size
        if (offset[15] == 1):
            code.bits = 0
            code.value = sorted[0]
            _g12 = 0
            _g3 = total_size
            while (_g12 < _g3):
                key1 = _g12
                _g12 = (_g12 + 1)
                root_table[(root_table_off + key1)] = code
            return total_size
        key = 0
        symbol = 0
        step = 2
        _g13 = 1
        _g4 = (root_bits + 1)
        while (_g13 < _g4):
            len1 = _g13
            _g13 = (_g13 + 1)
            while (count[len1] > 0):
                code.bits = len1
                index = symbol
                symbol = (symbol + 1)
                code.value = sorted[index]
                decode_Huffman.ReplicateValue(root_table,(root_table_off + key),step,table_size,code)
                key = decode_Huffman.GetNextKey(key,len1)
                val3 = (count[len1] - 1)
                count[len1] = val3
            step = (step << 1)
        mask = (total_size - 1)
        low = -1
        step = 2
        _g14 = (root_bits + 1)
        while (_g14 < 16):
            len2 = _g14
            _g14 = (_g14 + 1)
            while (count[len2] > 0):
                if (((key & mask)) != low):
                    table_off = (table_off + table_size)
                    table_bits = decode_Huffman.NextTableBitSize(count,len2,root_bits)
                    table_size = (1 << table_bits)
                    total_size = (total_size + table_size)
                    low = (key & mask)
                    root_table[(root_table_off + low)].bits = (table_bits + root_bits)
                    root_table[(root_table_off + low)].value = ((table_off - root_table_off) - low)
                code.bits = (len2 - root_bits)
                index1 = symbol
                symbol = (symbol + 1)
                code.value = sorted[index1]
                decode_Huffman.ReplicateValue(root_table,(table_off + ((key >> root_bits))),step,table_size,code)
                key = decode_Huffman.GetNextKey(key,len2)
                val4 = (count[len2] - 1)
                count[len2] = val4
            step = (step << 1)
        return total_size

    @staticmethod
    def BrotliHuffmanTreeGroupInit(group,alphabet_size,ntrees):
        group.alphabet_size = alphabet_size
        group.num_htrees = ntrees
        group.codes = FunctionMalloc.malloc2_decode_huffman_HuffmanCode(decode_huffman_HuffmanCode,(ntrees * 1080))
        group.htrees = list()
        group.htrees_off = list()

    @staticmethod
    def BrotliHuffmanTreeGroupRelease(group):
        pass


class decode_Port:
    _hx_class_name = "decode.Port"
    __slots__ = ()
    _hx_statics = ["PREDICT_FALSE", "PREDICT_TRUE", "BROTLI_DCHECK"]

    def __init__(self):
        pass

    @staticmethod
    def PREDICT_FALSE(x):
        return x

    @staticmethod
    def PREDICT_TRUE(x):
        return x

    @staticmethod
    def BROTLI_DCHECK(x):
        pass


class decode_prefix_PrefixCodeRange:
    _hx_class_name = "decode.prefix.PrefixCodeRange"
    __slots__ = ("offset", "nbits")
    _hx_fields = ["offset", "nbits"]

    def __init__(self,offset,nbits):
        self.offset = offset
        self.nbits = nbits



class decode_Prefix:
    _hx_class_name = "decode.Prefix"
    __slots__ = ()
    _hx_statics = ["kBlockLengthPrefixCode", "kInsertLengthPrefixCode", "kCopyLengthPrefixCode", "kInsertRangeLut", "kCopyRangeLut"]

    def __init__(self):
        pass


class decode_State:
    _hx_class_name = "decode.State"
    __slots__ = ()
    _hx_statics = ["BrotliStateInit"]

    def __init__(self):
        pass

    @staticmethod
    def BrotliStateInit(s):
        s.state = 0
        s.sub_state[0] = 50
        s.sub_state[1] = 50
        s.block_type_trees = None
        s.block_len_trees = None
        s.ringbuffer = None
        s.context_map = None
        s.context_modes = None
        s.dist_context_map = None
        s.context_map_slice = None
        s.context_map_slice_off = 0
        s.dist_context_map_slice = None
        s.dist_context_map_slice_off = 0
        _g = 0
        while (_g < 3):
            i = _g
            _g = (_g + 1)
            s.hgroup[i].codes = None
            s.hgroup[i].htrees = None
        s.code_lengths = None
        s.context_map_table = None
        s.custom_dict = None
        s.custom_dict_size = 0


class decode_Streams:
    _hx_class_name = "decode.Streams"
    __slots__ = ()
    _hx_statics = ["BrotliRead", "BrotliWrite", "BrotliMemInputFunction", "BrotliInitMemInput", "BrotliMemOutputFunction", "BrotliInitMemOutput", "BrotliFileInputFunction", "BrotliFileInput", "BrotliFileOutputFunction", "BrotliFileOutput"]

    def __init__(self):
        pass

    @staticmethod
    def BrotliRead(input,buf,buf_off,_hx_len):
        return input.cb_(input.data_,buf,buf_off,_hx_len)

    @staticmethod
    def BrotliWrite(out,buf,buf_off,_hx_len):
        return out.cb_(out.data_,buf,buf_off,_hx_len)

    @staticmethod
    def BrotliMemInputFunction(data,buf,buf_off,count):
        a = data.pos
        b = data.length
        aNeg = (a < 0)
        if (aNeg if ((aNeg != ((b < 0)))) else (a > b)):
            return -1
        a1 = (data.pos + count)
        b1 = data.length
        aNeg1 = (a1 < 0)
        if (aNeg1 if ((aNeg1 != ((b1 < 0)))) else (a1 > b1)):
            count = (data.length - data.pos)
        DefaultFunctions.memcpyVectorArray(buf,buf_off,data.buffer,(0 + data.pos),count)
        data.pos = (data.pos + count)
        return count

    @staticmethod
    def BrotliInitMemInput(buffer,length):
        input = decode_streams_BrotliInput()
        mem_input = decode_streams_BrotliMemInput()
        mem_input.buffer = buffer
        mem_input.length = length
        mem_input.pos = 0
        input.cb_ = decode_Streams.BrotliMemInputFunction
        input.data_ = mem_input
        return input

    @staticmethod
    def BrotliMemOutputFunction(data,buf,buf_off,count):
        DefaultFunctions.memcpyArrayVector(data.buffer,(0 + data.pos),buf,buf_off,count)
        data.pos = (data.pos + count)
        return count

    @staticmethod
    def BrotliInitMemOutput(buffer):
        output = decode_streams_BrotliOutput()
        mem_output = decode_streams_BrotliMemOutput()
        mem_output.buffer = buffer
        mem_output.pos = 0
        output.cb_ = decode_Streams.BrotliMemOutputFunction
        output.data_ = mem_output
        return output

    @staticmethod
    def BrotliFileInputFunction(data,buf,buf_off,count):
        _hx_bytes = haxe_io_Bytes.alloc(count)
        size = data.readBytes(_hx_bytes,0,count)
        _g1 = 0
        while (_g1 < size):
            i = _g1
            _g1 = (_g1 + 1)
            val = _hx_bytes.b[i]
            buf[(buf_off + i)] = val
        return size

    @staticmethod
    def BrotliFileInput(f):
        input = decode_streams_BrotliInput()
        input.cb_ = decode_Streams.BrotliFileInputFunction
        input.data_ = f
        return input

    @staticmethod
    def BrotliFileOutputFunction(data,buf,buf_off,count):
        _hx_bytes = haxe_io_Bytes.alloc(count)
        _g1 = 0
        while (_g1 < count):
            i = _g1
            _g1 = (_g1 + 1)
            v = buf[i]
            _hx_bytes.b[i] = (v & 255)
        data.write(_hx_bytes)
        return _hx_bytes.length

    @staticmethod
    def BrotliFileOutput(f):
        out = decode_streams_BrotliOutput()
        out.cb_ = decode_Streams.BrotliFileOutputFunction
        out.data_ = f
        return out


class decode_transform_Transform:
    _hx_class_name = "decode.transform.Transform"
    __slots__ = ("prefix", "transform", "suffix")
    _hx_fields = ["prefix", "transform", "suffix"]

    def __init__(self,prefix,transform,suffix):
        self.prefix = list()
        _g1 = 0
        _g = len(prefix)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(self.prefix, i, HxString.charCodeAt(prefix,i))
        self.transform = transform
        self.suffix = list()
        _g11 = 0
        _g2 = len(suffix)
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            python_internal_ArrayImpl._set(self.suffix, i1, HxString.charCodeAt(suffix,i1))



class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "get_length", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def get_length(s):
        return len(s)

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            return s[startIndex:(startIndex + _hx_len)]


class decode_Transforms:
    _hx_class_name = "decode.Transforms"
    __slots__ = ()
    _hx_statics = ["kIdentity", "kOmitLast1", "kOmitLast2", "kOmitLast3", "kOmitLast4", "kOmitLast5", "kOmitLast6", "kOmitLast7", "kOmitLast8", "kOmitLast9", "kUppercaseFirst", "kUppercaseAll", "kOmitFirst1", "kOmitFirst2", "kOmitFirst3", "kOmitFirst4", "kOmitFirst5", "kOmitFirst6", "kOmitFirst7", "kOmitFirst8", "kOmitFirst9", "kTransforms", "kNumTransforms", "ToUpperCase", "TransformDictionaryWord"]

    def __init__(self):
        pass

    @staticmethod
    def ToUpperCase(p,p_off):
        a = p[p_off]
        if (False if ((False != ((a < 0)))) else (192 > a)):
            tmp = None
            a1 = p[p_off]
            b = HxString.charCodeAt("a",0)
            aNeg = (a1 < 0)
            if (aNeg if ((aNeg != ((b < 0)))) else (a1 >= b)):
                a2 = p[p_off]
                b1 = HxString.charCodeAt("z",0)
                aNeg1 = (b1 < 0)
                if (aNeg1 != ((a2 < 0))):
                    tmp = aNeg1
                else:
                    tmp = (b1 >= a2)
            else:
                tmp = False
            if tmp:
                val = (p[p_off] ^ 32)
                p[p_off] = val
            return 1
        a3 = p[p_off]
        if (False if ((False != ((a3 < 0)))) else (224 > a3)):
            _g = (p_off + 1)
            val1 = (p[_g] ^ 32)
            p[_g] = val1
            return 2
        _g1 = (p_off + 2)
        val2 = (p[_g1] ^ 5)
        p[_g1] = val2
        return 3

    @staticmethod
    def TransformDictionaryWord(dst,dst_off,word,word_off,_hx_len,transform):
        prefix = python_internal_ArrayImpl._get(decode_Transforms.kTransforms, transform).prefix
        suffix = python_internal_ArrayImpl._get(decode_Transforms.kTransforms, transform).suffix
        t = python_internal_ArrayImpl._get(decode_Transforms.kTransforms, transform).transform
        skip = (0 if ((t < decode_Transforms.kOmitFirst1)) else (t - ((decode_Transforms.kOmitFirst1 - 1))))
        idx = 0
        i = 0
        uppercase_off = None
        if (skip > _hx_len):
            skip = _hx_len
        _g1 = 0
        _g = len(prefix)
        while (_g1 < _g):
            prefix_off = _g1
            _g1 = (_g1 + 1)
            index = idx
            idx = (idx + 1)
            val = (prefix[prefix_off] if prefix_off >= 0 and prefix_off < len(prefix) else None)
            dst[(dst_off + index)] = val
        word_off = (word_off + skip)
        _hx_len = (_hx_len - skip)
        if (t <= decode_Transforms.kOmitLast9):
            _hx_len = (_hx_len - t)
        while (i < _hx_len):
            index1 = idx
            idx = (idx + 1)
            index2 = i
            i = (i + 1)
            val1 = word[(word_off + index2)]
            dst[(dst_off + index1)] = val1
        uppercase_off = (dst_off + ((idx - _hx_len)))
        if (t == decode_Transforms.kUppercaseFirst):
            decode_Transforms.ToUpperCase(dst,uppercase_off)
        elif (t == decode_Transforms.kUppercaseAll):
            while (_hx_len > 0):
                step = decode_Transforms.ToUpperCase(dst,uppercase_off)
                uppercase_off = (uppercase_off + step)
                _hx_len = (_hx_len - step)
        _g11 = 0
        _g2 = len(suffix)
        while (_g11 < _g2):
            suffix_off = _g11
            _g11 = (_g11 + 1)
            index3 = idx
            idx = (idx + 1)
            val2 = (suffix[suffix_off] if suffix_off >= 0 and suffix_off < len(suffix) else None)
            dst[(dst_off + index3)] = val2
        return idx


class decode_bit_reader_BrotliBitReader:
    _hx_class_name = "decode.bit_reader.BrotliBitReader"
    __slots__ = ("val_", "pos_", "bit_pos_", "bit_end_pos_", "eos_", "buf_ptr_", "buf_ptr_off", "input_", "finish_", "tmp_bytes_read_", "buf_", "buf_off")
    _hx_fields = ["val_", "pos_", "bit_pos_", "bit_end_pos_", "eos_", "buf_ptr_", "buf_ptr_off", "input_", "finish_", "tmp_bytes_read_", "buf_", "buf_off"]

    def __init__(self):
        self.tmp_bytes_read_ = None
        self.finish_ = None
        self.input_ = None
        self.buf_ptr_off = None
        self.buf_ptr_ = None
        self.eos_ = None
        self.bit_end_pos_ = None
        self.bit_pos_ = None
        self.pos_ = None
        self.val_ = None
        self.buf_off = 0
        self.buf_ = [None]*8320



class decode_huffman_HuffmanCode:
    _hx_class_name = "decode.huffman.HuffmanCode"
    __slots__ = ("bits", "value")
    _hx_fields = ["bits", "value"]

    def __init__(self,bits,value):
        self.bits = bits
        self.value = value



class decode_huffman_HuffmanTreeGroup:
    _hx_class_name = "decode.huffman.HuffmanTreeGroup"
    __slots__ = ("alphabet_size", "num_htrees", "codes", "htrees", "htrees_off")
    _hx_fields = ["alphabet_size", "num_htrees", "codes", "htrees", "htrees_off"]

    def __init__(self):
        self.htrees_off = None
        self.htrees = None
        self.codes = None
        self.num_htrees = None
        self.alphabet_size = None



class decode_state_BrotliState:
    _hx_class_name = "decode.state.BrotliState"
    __slots__ = ("state", "sub_state", "pos", "input_end", "window_bits", "max_backward_distance", "max_distance", "ringbuffer_size", "ringbuffer_mask", "ringbuffer", "ringbuffer_off", "ringbuffer_end", "ringbuffer_end_off", "dist_rb", "dist_rb_idx", "prev_byte1", "prev_byte2", "hgroup", "block_type_trees", "block_len_trees", "br", "loop_counter", "trivial_literal_context", "meta_block_remaining_len", "is_metadata", "is_uncompressed", "block_length", "block_type", "num_block_types", "block_type_rb", "block_type_rb_index", "distance_postfix_bits", "num_direct_distance_codes", "distance_postfix_mask", "num_distance_codes", "context_map", "context_map_off", "context_modes", "context_modes_off", "num_literal_htrees", "dist_context_map", "dist_context_map_off", "num_dist_htrees", "context_offset", "context_map_slice", "context_map_slice_off", "literal_htree_index", "dist_context_offset", "dist_context_map_slice", "dist_context_map_slice_off", "dist_htree_index", "context_lookup_offset1", "context_lookup_offset2", "context_mode", "htree_command", "htree_command_off", "cmd_code", "range_idx", "insert_code", "copy_code", "insert_length", "copy_length", "distance_code", "distance", "copy_src", "copy_src_off", "copy_dst", "copy_dst_off", "nbytes", "partially_written", "htrees_decoded", "symbol", "prev_code_len", "repeat", "repeat_code_len", "space", "table", "code_length_code_lengths", "simple_code_or_skip", "code_lengths", "code_lengths_off", "htree_index", "next", "next_off", "context_index", "max_run_length_prefix", "context_map_table", "custom_dict", "custom_dict_off", "custom_dict_size")
    _hx_fields = ["state", "sub_state", "pos", "input_end", "window_bits", "max_backward_distance", "max_distance", "ringbuffer_size", "ringbuffer_mask", "ringbuffer", "ringbuffer_off", "ringbuffer_end", "ringbuffer_end_off", "dist_rb", "dist_rb_idx", "prev_byte1", "prev_byte2", "hgroup", "block_type_trees", "block_len_trees", "br", "loop_counter", "trivial_literal_context", "meta_block_remaining_len", "is_metadata", "is_uncompressed", "block_length", "block_type", "num_block_types", "block_type_rb", "block_type_rb_index", "distance_postfix_bits", "num_direct_distance_codes", "distance_postfix_mask", "num_distance_codes", "context_map", "context_map_off", "context_modes", "context_modes_off", "num_literal_htrees", "dist_context_map", "dist_context_map_off", "num_dist_htrees", "context_offset", "context_map_slice", "context_map_slice_off", "literal_htree_index", "dist_context_offset", "dist_context_map_slice", "dist_context_map_slice_off", "dist_htree_index", "context_lookup_offset1", "context_lookup_offset2", "context_mode", "htree_command", "htree_command_off", "cmd_code", "range_idx", "insert_code", "copy_code", "insert_length", "copy_length", "distance_code", "distance", "copy_src", "copy_src_off", "copy_dst", "copy_dst_off", "nbytes", "partially_written", "htrees_decoded", "symbol", "prev_code_len", "repeat", "repeat_code_len", "space", "table", "code_length_code_lengths", "simple_code_or_skip", "code_lengths", "code_lengths_off", "htree_index", "next", "next_off", "context_index", "max_run_length_prefix", "context_map_table", "custom_dict", "custom_dict_off", "custom_dict_size"]

    def __init__(self):
        self.custom_dict_size = None
        self.custom_dict_off = None
        self.custom_dict = None
        self.context_map_table = None
        self.max_run_length_prefix = None
        self.context_index = None
        self.next_off = None
        self.next = None
        self.htree_index = None
        self.code_lengths_off = None
        self.code_lengths = None
        self.simple_code_or_skip = None
        self.space = None
        self.repeat_code_len = None
        self.repeat = None
        self.prev_code_len = None
        self.symbol = None
        self.htrees_decoded = None
        self.partially_written = None
        self.nbytes = None
        self.copy_dst_off = None
        self.copy_dst = None
        self.copy_src_off = None
        self.copy_src = None
        self.distance = None
        self.distance_code = None
        self.copy_length = None
        self.insert_length = None
        self.copy_code = None
        self.insert_code = None
        self.range_idx = None
        self.cmd_code = None
        self.htree_command_off = None
        self.htree_command = None
        self.context_mode = None
        self.context_lookup_offset2 = None
        self.context_lookup_offset1 = None
        self.dist_htree_index = None
        self.dist_context_map_slice_off = None
        self.dist_context_map_slice = None
        self.dist_context_offset = None
        self.literal_htree_index = None
        self.context_map_slice_off = None
        self.context_map_slice = None
        self.context_offset = None
        self.num_dist_htrees = None
        self.dist_context_map_off = None
        self.dist_context_map = None
        self.num_literal_htrees = None
        self.context_modes_off = None
        self.context_modes = None
        self.context_map_off = None
        self.context_map = None
        self.num_distance_codes = None
        self.distance_postfix_mask = None
        self.num_direct_distance_codes = None
        self.distance_postfix_bits = None
        self.is_uncompressed = None
        self.is_metadata = None
        self.meta_block_remaining_len = None
        self.trivial_literal_context = None
        self.loop_counter = None
        self.block_len_trees = None
        self.block_type_trees = None
        self.prev_byte2 = None
        self.prev_byte1 = None
        self.dist_rb_idx = None
        self.ringbuffer_end_off = None
        self.ringbuffer_end = None
        self.ringbuffer_off = None
        self.ringbuffer = None
        self.ringbuffer_mask = None
        self.ringbuffer_size = None
        self.max_distance = None
        self.max_backward_distance = None
        self.window_bits = None
        self.input_end = None
        self.pos = None
        self.state = None
        self.code_length_code_lengths = [None]*18
        self.table = [None]*32
        self.block_type_rb_index = [None]*3
        self.block_type_rb = [None]*6
        self.num_block_types = [None]*3
        self.block_type = [None]*3
        self.block_length = [None]*3
        self.br = decode_bit_reader_BrotliBitReader()
        self.hgroup = FunctionMalloc.malloc_decode_huffman_HuffmanTreeGroup(decode_huffman_HuffmanTreeGroup,3)
        self.dist_rb = [None]*4
        self.sub_state = [None]*2



class decode_streams_BrotliInput:
    _hx_class_name = "decode.streams.BrotliInput"
    __slots__ = ("cb_", "data_", "data_off")
    _hx_fields = ["cb_", "data_", "data_off"]

    def __init__(self):
        self.data_off = None
        self.data_ = None
        self.cb_ = None



class decode_streams_BrotliMemInput:
    _hx_class_name = "decode.streams.BrotliMemInput"
    __slots__ = ("buffer", "length", "pos")
    _hx_fields = ["buffer", "length", "pos"]

    def __init__(self):
        self.pos = None
        self.length = None
        self.buffer = None



class decode_streams_BrotliMemOutput:
    _hx_class_name = "decode.streams.BrotliMemOutput"
    __slots__ = ("buffer", "pos")
    _hx_fields = ["buffer", "pos"]

    def __init__(self):
        self.pos = None
        self.buffer = None



class decode_streams_BrotliOutput:
    _hx_class_name = "decode.streams.BrotliOutput"
    __slots__ = ("cb_", "data_", "data_off")
    _hx_fields = ["cb_", "data_", "data_off"]

    def __init__(self):
        self.data_off = None
        self.data_ = None
        self.cb_ = None



class encode_Backward_references:
    _hx_class_name = "encode.Backward_references"
    __slots__ = ()
    _hx_statics = ["kInfinity", "SetDistanceCache", "ComputeDistanceCode", "UpdateZopfliNode", "ComputeMinimumCopyLength", "ZopfliIterate", "CreateBackwardReferences_HashLongestMatch", "CreateBackwardReferences_HashLongestMatchQuickly", "CreateBackwardReferences"]

    def __init__(self):
        pass

    @staticmethod
    def SetDistanceCache(distance,distance_code,max_distance,dist_cache,result_dist_cache,result_dist_cache_off):
        if ((distance <= max_distance) and ((distance_code > 0))):
            result_dist_cache[0] = distance
            DefaultFunctions.memcpy_Int(result_dist_cache,(result_dist_cache_off + 1),dist_cache,0,3)
        else:
            DefaultFunctions.memcpy_Int(result_dist_cache,result_dist_cache_off,dist_cache,0,4)

    @staticmethod
    def ComputeDistanceCode(distance,max_distance,quality,dist_cache):
        if (distance <= max_distance):
            if (distance == dist_cache[0]):
                return 0
            elif (distance == dist_cache[1]):
                return 1
            elif (distance == dist_cache[2]):
                return 2
            elif (distance == dist_cache[3]):
                return 3
            elif ((quality > 3) and ((distance >= 6))):
                _g = 4
                while (_g < 16):
                    k = _g
                    _g = (_g + 1)
                    if ((distance == ((dist_cache[python_internal_ArrayImpl._get(encode_Hash.kDistanceCacheIndex, k)] + python_internal_ArrayImpl._get(encode_Hash.kDistanceCacheOffset, k)))) and ((distance >= python_internal_ArrayImpl._get([0, 0, 0, 0, 6, 6, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12], k)))):
                        return k
        return (distance + 15)

    @staticmethod
    def UpdateZopfliNode(nodes,nodes_off,pos,start_pos,_hx_len,len_code,dist,dist_code,max_dist,dist_cache,cost):
        next = nodes[((nodes_off + pos) + _hx_len)]
        next.length = _hx_len
        next.length_code = len_code
        next.distance = dist
        next.distance_code = dist_code
        next.insert_length = (pos - start_pos)
        next.cost = cost
        encode_Backward_references.SetDistanceCache(dist,dist_code,max_dist,dist_cache,next.distance_cache,0)

    @staticmethod
    def ComputeMinimumCopyLength(queue,nodes,model,pos,min_cost_cmd):
        start0 = queue.GetStartPos(0)
        min_cost = ((nodes[start0].cost + model.GetLiteralCosts(start0,pos)) + min_cost_cmd)
        _hx_len = 2
        next_len_bucket = 4
        next_len_offset = 10
        while (((pos + _hx_len) < len(nodes)) and ((nodes[(pos + _hx_len)].cost <= min_cost))):
            _hx_len = (_hx_len + 1)
            if (_hx_len == next_len_offset):
                min_cost = (min_cost + 1.0)
                next_len_offset = (next_len_offset + next_len_bucket)
                next_len_bucket = (next_len_bucket * 2)
        return _hx_len

    @staticmethod
    def ZopfliIterate(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,model,num_matches,matches,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals):
        orig_commands_off = commands_off
        nodes = FunctionMalloc.malloc_encode_backward_references_ZopfliNode(encode_backward_references_ZopfliNode,(num_bytes + 1))
        nodes[0].length = 0
        nodes[0].cost = 0
        DefaultFunctions.memcpy_Int(nodes[0].distance_cache,0,dist_cache,0,4)
        queue = encode_backward_references_StartPosQueue(3)
        min_cost_cmd = model.GetMinCostCmd()
        cur_match_pos = 0
        i = 0
        while ((i + 3) < num_bytes):
            cur_ix = (position + i)
            cur_ix_masked = (cur_ix & ringbuffer_mask)
            x = (cur_ix if (python_lib_Math.isnan(cur_ix)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(cur_ix,max_backward_limit)))
            max_distance = None
            try:
                max_distance = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                max_distance = None
            max_length = (num_bytes - i)
            queue.Push(i,(nodes[i].cost - model.GetLiteralCosts(0,i)))
            min_len = encode_Backward_references.ComputeMinimumCopyLength(queue,nodes,model,i,min_cost_cmd)
            k = 0
            while ((k < 5) and ((k < queue.size()))):
                start = queue.GetStartPos(k)
                start_costdiff = (nodes[start].cost - model.GetLiteralCosts(0,start))
                dist_cache2 = nodes[start].distance_cache
                best_len = (min_len - 1)
                _g = 0
                while (_g < 16):
                    j = _g
                    _g = (_g + 1)
                    backward = (dist_cache2[python_internal_ArrayImpl._get(encode_Hash.kDistanceCacheIndex, j)] + python_internal_ArrayImpl._get(encode_Hash.kDistanceCacheOffset, j))
                    prev_ix = (cur_ix - backward)
                    if (prev_ix >= cur_ix):
                        continue
                    if (backward > max_distance):
                        continue
                    prev_ix = (prev_ix & ringbuffer_mask)
                    if ((((cur_ix_masked + best_len) > ringbuffer_mask) or (((prev_ix + best_len) > ringbuffer_mask))) or ((ringbuffer[(cur_ix_masked + best_len)] != ringbuffer[(prev_ix + best_len)]))):
                        continue
                    _g2 = (best_len + 1)
                    _g1 = (encode_Find_match_length.FindMatchLengthWithLimit(ringbuffer,prev_ix,ringbuffer,cur_ix_masked,max_length) + 1)
                    while (_g2 < _g1):
                        l = _g2
                        _g2 = (_g2 + 1)
                        cost = ((start_costdiff + model.GetCommandCost(j,l,(i - start))) + model.GetLiteralCosts(0,i))
                        if (cost < nodes[(i + l)].cost):
                            encode_Backward_references.UpdateZopfliNode(nodes,0,i,start,l,l,backward,j,max_distance,dist_cache2,cost)
                        best_len = l
                if (k >= 2):
                    k = (k + 1)
                    continue
                _hx_len = min_len
                _g11 = 0
                _g3 = num_matches[i]
                while (_g11 < _g3):
                    j1 = _g11
                    _g11 = (_g11 + 1)
                    match = python_internal_ArrayImpl._get(matches, (cur_match_pos + j1))
                    dist = match.distance
                    is_dictionary_match = (dist > max_distance)
                    dist_code = (dist + 15)
                    max_len = match.length()
                    if ((_hx_len < max_len) and ((is_dictionary_match or ((max_len > 325))))):
                        _hx_len = max_len
                    while (_hx_len <= max_len):
                        len_code = (match.length_code() if is_dictionary_match else _hx_len)
                        cost1 = ((start_costdiff + model.GetCommandCost(dist_code,len_code,(i - start))) + model.GetLiteralCosts(0,i))
                        if (cost1 < nodes[(i + _hx_len)].cost):
                            encode_Backward_references.UpdateZopfliNode(nodes,0,i,start,_hx_len,len_code,dist,dist_code,max_distance,dist_cache2,cost1)
                        _hx_len = (_hx_len + 1)
                k = (k + 1)
            cur_match_pos = (cur_match_pos + num_matches[i])
            if ((num_matches[i] == 1) and ((python_internal_ArrayImpl._get(matches, (cur_match_pos - 1)).length() > 325))):
                i = (i + ((python_internal_ArrayImpl._get(matches, (cur_match_pos - 1)).length() - 1)))
                queue.Clear()
            i = (i + 1)
        backwards = list()
        index = num_bytes
        while (nodes[index].cost == encode_Backward_references.kInfinity):
            index = (index - 1)
        while (index > 0):
            len1 = (nodes[index].length + nodes[index].insert_length)
            backwards.append(len1)
            index = (index - len1)
        path = list()
        i1 = len(backwards)
        while (i1 > 0):
            path.append(python_internal_ArrayImpl._get(backwards, (i1 - 1)))
            i1 = (i1 - 1)
        pos = 0
        _g12 = 0
        _g4 = len(path)
        while (_g12 < _g4):
            i2 = _g12
            _g12 = (_g12 + 1)
            next = nodes[(pos + (path[i2] if i2 >= 0 and i2 < len(path) else None))]
            copy_length = next.length
            insert_length = next.insert_length
            pos = (pos + insert_length)
            if (i2 == 0):
                insert_length = (insert_length + (last_insert_len[0] if 0 < len(last_insert_len) else None))
            distance = next.distance
            len_code1 = next.length_code
            a = (position + pos)
            x1 = (a if (python_lib_Math.isnan(a)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a,max_backward_limit)))
            max_distance1 = None
            try:
                max_distance1 = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                max_distance1 = None
            dist_code1 = next.distance_code
            command = encode_command_Command()
            command.Command4(insert_length,copy_length,len_code1,dist_code1)
            tmp = commands_off
            commands_off = (commands_off + 1)
            python_internal_ArrayImpl._set(commands, tmp, command)
            if ((distance <= max_distance1) and ((dist_code1 > 0))):
                val = dist_cache[2]
                dist_cache[3] = val
                val1 = dist_cache[1]
                dist_cache[2] = val1
                val2 = dist_cache[0]
                dist_cache[1] = val2
                dist_cache[0] = distance
            _hx_local_12 = num_literals
            _hx_local_13 = 0
            _hx_local_14 = (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            python_internal_ArrayImpl._set(_hx_local_12, _hx_local_13, (_hx_local_14 + insert_length))
            (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            insert_length = 0
            pos = (pos + copy_length)
        python_internal_ArrayImpl._set(last_insert_len, 0, (num_bytes - pos))
        _hx_local_16 = num_commands
        _hx_local_17 = 0
        _hx_local_18 = (_hx_local_16[_hx_local_17] if _hx_local_17 >= 0 and _hx_local_17 < len(_hx_local_16) else None)
        python_internal_ArrayImpl._set(_hx_local_16, _hx_local_17, (_hx_local_18 + ((commands_off - orig_commands_off))))
        (_hx_local_16[_hx_local_17] if _hx_local_17 >= 0 and _hx_local_17 < len(_hx_local_16) else None)

    @staticmethod
    def CreateBackwardReferences_HashLongestMatch(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hasher,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals):
        if ((num_bytes >= 3) and ((position >= 3))):
            hasher.Store(ringbuffer,((position - 3) & ringbuffer_mask),(position - 3))
            hasher.Store(ringbuffer,((position - 2) & ringbuffer_mask),(position - 2))
            hasher.Store(ringbuffer,((position - 1) & ringbuffer_mask),(position - 1))
        orig_commands_off = commands_off
        insert_length = (last_insert_len[0] if 0 < len(last_insert_len) else None)
        i = (position & ringbuffer_mask)
        i_diff = (position - i)
        i_end = (i + num_bytes)
        random_heuristics_window_size = (64 if ((quality < 9)) else 512)
        apply_random_heuristics = (i + random_heuristics_window_size)
        while ((i + 3) < i_end):
            max_length = (i_end - i)
            a = (i + i_diff)
            x = (a if (python_lib_Math.isnan(a)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a,max_backward_limit)))
            max_distance = None
            try:
                max_distance = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                max_distance = None
            best_len = [0]
            best_len_code = [0]
            best_dist = [0]
            best_score = [4.0]
            match_found = hasher.FindLongestMatch(ringbuffer,ringbuffer_mask,dist_cache,(i + i_diff),max_length,max_distance,best_len,best_len_code,best_dist,best_score)
            if match_found:
                delayed_backward_references_in_row = 0
                while True:
                    max_length = (max_length - 1)
                    best_len_2 = None
                    if (quality < 5):
                        a1 = ((best_len[0] if 0 < len(best_len) else None) - 1)
                        x1 = (a1 if (python_lib_Math.isnan(a1)) else (max_length if (python_lib_Math.isnan(max_length)) else min(a1,max_length)))
                        try:
                            best_len_2 = int(x1)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e1 = _hx_e1
                            best_len_2 = None
                    else:
                        best_len_2 = 0
                    best_len_21 = [best_len_2]
                    best_len_code_2 = [0]
                    best_dist_2 = [0]
                    best_score_2 = [4.0]
                    a2 = ((i + i_diff) + 1)
                    x2 = (a2 if (python_lib_Math.isnan(a2)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a2,max_backward_limit)))
                    try:
                        max_distance = int(x2)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e2 = _hx_e1
                        max_distance = None
                    hasher.Store(ringbuffer,i,(i + i_diff))
                    match_found = hasher.FindLongestMatch(ringbuffer,ringbuffer_mask,dist_cache,((i + i_diff) + 1),max_length,max_distance,best_len_21,best_len_code_2,best_dist_2,best_score_2)
                    if (match_found and (((best_score_2[0] if 0 < len(best_score_2) else None) >= (((best_score[0] if 0 < len(best_score) else None) + 7.0))))):
                        i = (i + 1)
                        insert_length = (insert_length + 1)
                        python_internal_ArrayImpl._set(best_len, 0, (best_len_21[0] if 0 < len(best_len_21) else None))
                        python_internal_ArrayImpl._set(best_len_code, 0, (best_len_code_2[0] if 0 < len(best_len_code_2) else None))
                        python_internal_ArrayImpl._set(best_dist, 0, (best_dist_2[0] if 0 < len(best_dist_2) else None))
                        python_internal_ArrayImpl._set(best_score, 0, (best_score_2[0] if 0 < len(best_score_2) else None))
                        delayed_backward_references_in_row = (delayed_backward_references_in_row + 1)
                        tmp = delayed_backward_references_in_row
                        if (tmp < 4):
                            continue
                    break
                apply_random_heuristics = ((i + ((2 * (best_len[0] if 0 < len(best_len) else None)))) + random_heuristics_window_size)
                a3 = (i + i_diff)
                x3 = (a3 if (python_lib_Math.isnan(a3)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a3,max_backward_limit)))
                try:
                    max_distance = int(x3)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e3 = _hx_e1
                    max_distance = None
                distance_code = encode_Backward_references.ComputeDistanceCode((best_dist[0] if 0 < len(best_dist) else None),max_distance,quality,dist_cache)
                if (((best_dist[0] if 0 < len(best_dist) else None) <= max_distance) and ((distance_code > 0))):
                    val = dist_cache[2]
                    dist_cache[3] = val
                    val1 = dist_cache[1]
                    dist_cache[2] = val1
                    val2 = dist_cache[0]
                    dist_cache[1] = val2
                    val3 = (best_dist[0] if 0 < len(best_dist) else None)
                    dist_cache[0] = val3
                command = encode_command_Command()
                command.Command4(insert_length,(best_len[0] if 0 < len(best_len) else None),(best_len_code[0] if 0 < len(best_len_code) else None),distance_code)
                tmp1 = commands_off
                commands_off = (commands_off + 1)
                python_internal_ArrayImpl._set(commands, tmp1, command)
                _hx_local_3 = num_literals
                _hx_local_4 = 0
                _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
                python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 + insert_length))
                (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
                insert_length = 0
                _g1 = 1
                _g = (best_len[0] if 0 < len(best_len) else None)
                while (_g1 < _g):
                    j = _g1
                    _g1 = (_g1 + 1)
                    hasher.Store(ringbuffer,(i + j),((i + i_diff) + j))
                i = (i + (best_len[0] if 0 < len(best_len) else None))
            else:
                insert_length = (insert_length + 1)
                hasher.Store(ringbuffer,i,(i + i_diff))
                i = (i + 1)
                if (i > apply_random_heuristics):
                    if (i > ((apply_random_heuristics + ((4 * random_heuristics_window_size))))):
                        a4 = (i + 16)
                        b = (i_end - 4)
                        x4 = (a4 if (python_lib_Math.isnan(a4)) else (b if (python_lib_Math.isnan(b)) else min(a4,b)))
                        i_jump = None
                        try:
                            i_jump = int(x4)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e4 = _hx_e1
                            i_jump = None
                        while (i < i_jump):
                            hasher.Store(ringbuffer,i,(i + i_diff))
                            insert_length = (insert_length + 4)
                            i = (i + 4)
                    else:
                        a5 = (i + 8)
                        b1 = (i_end - 3)
                        x5 = (a5 if (python_lib_Math.isnan(a5)) else (b1 if (python_lib_Math.isnan(b1)) else min(a5,b1)))
                        i_jump1 = None
                        try:
                            i_jump1 = int(x5)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e5 = _hx_e1
                            i_jump1 = None
                        while (i < i_jump1):
                            hasher.Store(ringbuffer,i,(i + i_diff))
                            insert_length = (insert_length + 2)
                            i = (i + 2)
        insert_length = (insert_length + ((i_end - i)))
        python_internal_ArrayImpl._set(last_insert_len, 0, insert_length)
        _hx_local_14 = num_commands
        _hx_local_15 = 0
        _hx_local_16 = (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)
        python_internal_ArrayImpl._set(_hx_local_14, _hx_local_15, (_hx_local_16 + ((commands_off - orig_commands_off))))
        (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)

    @staticmethod
    def CreateBackwardReferences_HashLongestMatchQuickly(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hasher,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals):
        if ((num_bytes >= 3) and ((position >= 3))):
            hasher.Store(ringbuffer,((position - 3) & ringbuffer_mask),(position - 3))
            hasher.Store(ringbuffer,((position - 2) & ringbuffer_mask),(position - 2))
            hasher.Store(ringbuffer,((position - 1) & ringbuffer_mask),(position - 1))
        orig_commands_off = commands_off
        insert_length = (last_insert_len[0] if 0 < len(last_insert_len) else None)
        i = (position & ringbuffer_mask)
        i_diff = (position - i)
        i_end = (i + num_bytes)
        random_heuristics_window_size = (64 if ((quality < 9)) else 512)
        apply_random_heuristics = (i + random_heuristics_window_size)
        while ((i + 3) < i_end):
            max_length = (i_end - i)
            a = (i + i_diff)
            x = (a if (python_lib_Math.isnan(a)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a,max_backward_limit)))
            max_distance = None
            try:
                max_distance = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                max_distance = None
            best_len = [0]
            best_len_code = [0]
            best_dist = [0]
            best_score = [4.0]
            match_found = hasher.FindLongestMatch(ringbuffer,ringbuffer_mask,dist_cache,(i + i_diff),max_length,max_distance,best_len,best_len_code,best_dist,best_score)
            if match_found:
                delayed_backward_references_in_row = 0
                while True:
                    max_length = (max_length - 1)
                    best_len_2 = None
                    if (quality < 5):
                        a1 = ((best_len[0] if 0 < len(best_len) else None) - 1)
                        x1 = (a1 if (python_lib_Math.isnan(a1)) else (max_length if (python_lib_Math.isnan(max_length)) else min(a1,max_length)))
                        try:
                            best_len_2 = int(x1)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e1 = _hx_e1
                            best_len_2 = None
                    else:
                        best_len_2 = 0
                    best_len_21 = [best_len_2]
                    best_len_code_2 = [0]
                    best_dist_2 = [0]
                    best_score_2 = [4.0]
                    a2 = ((i + i_diff) + 1)
                    x2 = (a2 if (python_lib_Math.isnan(a2)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a2,max_backward_limit)))
                    try:
                        max_distance = int(x2)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e2 = _hx_e1
                        max_distance = None
                    hasher.Store(ringbuffer,i,(i + i_diff))
                    match_found = hasher.FindLongestMatch(ringbuffer,ringbuffer_mask,dist_cache,((i + i_diff) + 1),max_length,max_distance,best_len_21,best_len_code_2,best_dist_2,best_score_2)
                    if (match_found and (((best_score_2[0] if 0 < len(best_score_2) else None) >= (((best_score[0] if 0 < len(best_score) else None) + 7.0))))):
                        i = (i + 1)
                        insert_length = (insert_length + 1)
                        python_internal_ArrayImpl._set(best_len, 0, (best_len_21[0] if 0 < len(best_len_21) else None))
                        python_internal_ArrayImpl._set(best_len_code, 0, (best_len_code_2[0] if 0 < len(best_len_code_2) else None))
                        python_internal_ArrayImpl._set(best_dist, 0, (best_dist_2[0] if 0 < len(best_dist_2) else None))
                        python_internal_ArrayImpl._set(best_score, 0, (best_score_2[0] if 0 < len(best_score_2) else None))
                        delayed_backward_references_in_row = (delayed_backward_references_in_row + 1)
                        tmp = delayed_backward_references_in_row
                        if (tmp < 4):
                            continue
                    break
                apply_random_heuristics = ((i + ((2 * (best_len[0] if 0 < len(best_len) else None)))) + random_heuristics_window_size)
                a3 = (i + i_diff)
                x3 = (a3 if (python_lib_Math.isnan(a3)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a3,max_backward_limit)))
                try:
                    max_distance = int(x3)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e3 = _hx_e1
                    max_distance = None
                distance_code = encode_Backward_references.ComputeDistanceCode((best_dist[0] if 0 < len(best_dist) else None),max_distance,quality,dist_cache)
                if (((best_dist[0] if 0 < len(best_dist) else None) <= max_distance) and ((distance_code > 0))):
                    val = dist_cache[2]
                    dist_cache[3] = val
                    val1 = dist_cache[1]
                    dist_cache[2] = val1
                    val2 = dist_cache[0]
                    dist_cache[1] = val2
                    val3 = (best_dist[0] if 0 < len(best_dist) else None)
                    dist_cache[0] = val3
                command = encode_command_Command()
                command.Command4(insert_length,(best_len[0] if 0 < len(best_len) else None),(best_len_code[0] if 0 < len(best_len_code) else None),distance_code)
                tmp1 = commands_off
                commands_off = (commands_off + 1)
                python_internal_ArrayImpl._set(commands, tmp1, command)
                _hx_local_3 = num_literals
                _hx_local_4 = 0
                _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
                python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 + insert_length))
                (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
                insert_length = 0
                _g1 = 1
                _g = (best_len[0] if 0 < len(best_len) else None)
                while (_g1 < _g):
                    j = _g1
                    _g1 = (_g1 + 1)
                    hasher.Store(ringbuffer,(i + j),((i + i_diff) + j))
                i = (i + (best_len[0] if 0 < len(best_len) else None))
            else:
                insert_length = (insert_length + 1)
                hasher.Store(ringbuffer,i,(i + i_diff))
                i = (i + 1)
                if (i > apply_random_heuristics):
                    if (i > ((apply_random_heuristics + ((4 * random_heuristics_window_size))))):
                        a4 = (i + 16)
                        b = (i_end - 4)
                        x4 = (a4 if (python_lib_Math.isnan(a4)) else (b if (python_lib_Math.isnan(b)) else min(a4,b)))
                        i_jump = None
                        try:
                            i_jump = int(x4)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e4 = _hx_e1
                            i_jump = None
                        while (i < i_jump):
                            hasher.Store(ringbuffer,i,(i + i_diff))
                            insert_length = (insert_length + 4)
                            i = (i + 4)
                    else:
                        a5 = (i + 8)
                        b1 = (i_end - 3)
                        x5 = (a5 if (python_lib_Math.isnan(a5)) else (b1 if (python_lib_Math.isnan(b1)) else min(a5,b1)))
                        i_jump1 = None
                        try:
                            i_jump1 = int(x5)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e5 = _hx_e1
                            i_jump1 = None
                        while (i < i_jump1):
                            hasher.Store(ringbuffer,i,(i + i_diff))
                            insert_length = (insert_length + 2)
                            i = (i + 2)
        insert_length = (insert_length + ((i_end - i)))
        python_internal_ArrayImpl._set(last_insert_len, 0, insert_length)
        _hx_local_14 = num_commands
        _hx_local_15 = 0
        _hx_local_16 = (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)
        python_internal_ArrayImpl._set(_hx_local_14, _hx_local_15, (_hx_local_16 + ((commands_off - orig_commands_off))))
        (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)

    @staticmethod
    def CreateBackwardReferences(num_bytes,position,ringbuffer,ringbuffer_mask,literal_cost,literal_cost_mask,max_backward_limit,quality,hashers,hash_type,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals):
        if (quality > 9):
            hasher = hashers.hash_h9
            if ((num_bytes >= 3) and ((position >= 3))):
                hasher.Store(ringbuffer,((position - 3) & ringbuffer_mask),(position - 3))
                hasher.Store(ringbuffer,((position - 2) & ringbuffer_mask),(position - 2))
                hasher.Store(ringbuffer,((position - 1) & ringbuffer_mask),(position - 1))
            num_matches = FunctionMalloc.mallocInt(num_bytes)
            matches = FunctionMalloc.mallocArray_encode_hash_BackwardMatch(encode_hash_BackwardMatch,(3 * num_bytes))
            cur_match_pos = 0
            i = 0
            while ((i + 3) < num_bytes):
                a = (position + i)
                x = (a if (python_lib_Math.isnan(a)) else (max_backward_limit if (python_lib_Math.isnan(max_backward_limit)) else min(a,max_backward_limit)))
                max_distance = None
                try:
                    max_distance = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    max_distance = None
                if (len(matches) < ((cur_match_pos + 325))):
                    (matches + FunctionMalloc.mallocArray_encode_hash_BackwardMatch(encode_hash_BackwardMatch,((cur_match_pos + 325) - len(matches))))
                hasher.FindAllMatches(ringbuffer,ringbuffer_mask,(position + i),(num_bytes - i),max_distance,num_matches,i,matches,cur_match_pos)
                hasher.Store(ringbuffer,((position + i) & ringbuffer_mask),(position + i))
                cur_match_pos = (cur_match_pos + num_matches[i])
                if (num_matches[i] == 1):
                    match_len = python_internal_ArrayImpl._get(matches, (cur_match_pos - 1)).length()
                    if (match_len > 325):
                        _g1 = 1
                        while (_g1 < match_len):
                            _g1 = (_g1 + 1)
                            i = (i + 1)
                            hasher.Store(ringbuffer,((position + i) & ringbuffer_mask),(position + i))
                            num_matches[i] = 0
                i = (i + 1)
            orig_num_literals = (num_literals[0] if 0 < len(num_literals) else None)
            orig_last_insert_len = (last_insert_len[0] if 0 < len(last_insert_len) else None)
            orig_dist_cache = [None]*4
            val = dist_cache[0]
            orig_dist_cache[0] = val
            val1 = dist_cache[1]
            orig_dist_cache[1] = val1
            val2 = dist_cache[2]
            orig_dist_cache[2] = val2
            val3 = dist_cache[3]
            orig_dist_cache[3] = val3
            orig_num_commands = (num_commands[0] if 0 < len(num_commands) else None)
            _g11 = 0
            while (_g11 < 2):
                i1 = _g11
                _g11 = (_g11 + 1)
                model = encode_backward_references_ZopfliCostModel()
                if (i1 == 0):
                    model.SetFromLiteralCosts(num_bytes,position,literal_cost,literal_cost_mask)
                else:
                    model.SetFromCommands(num_bytes,position,ringbuffer,ringbuffer_mask,commands,((commands_off + (num_commands[0] if 0 < len(num_commands) else None)) - orig_num_commands),orig_last_insert_len)
                python_internal_ArrayImpl._set(num_commands, 0, orig_num_commands)
                python_internal_ArrayImpl._set(num_literals, 0, orig_num_literals)
                python_internal_ArrayImpl._set(last_insert_len, 0, orig_last_insert_len)
                DefaultFunctions.memcpy_Int(dist_cache,0,orig_dist_cache,0,4)
                encode_Backward_references.ZopfliIterate(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,model,num_matches,matches,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
            return
        if (hash_type == 1):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatchQuickly(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h1,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 2):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatchQuickly(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h2,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 3):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatchQuickly(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h3,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 4):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatchQuickly(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h4,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 5):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatch(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h5,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 6):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatch(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h6,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 7):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatch(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h7,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 8):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatch(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h8,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        elif (hash_type == 9):
            encode_Backward_references.CreateBackwardReferences_HashLongestMatch(num_bytes,position,ringbuffer,ringbuffer_mask,max_backward_limit,quality,hashers.hash_h9,dist_cache,last_insert_len,commands,commands_off,num_commands,num_literals)
        else:
            pass


class encode_BinaryHeap:
    _hx_class_name = "encode.BinaryHeap"
    __slots__ = ("comp", "arr")
    _hx_fields = ["comp", "arr"]
    _hx_methods = ["HistogramPairComparator", "swap", "bubbleDown", "bubbleUp", "pop", "push", "size"]

    def __init__(self):
        self.comp = None
        self.arr = []
        self.comp = self.HistogramPairComparator

    def HistogramPairComparator(self,p1,p2):
        if not HxOverrides.eq(Reflect.field(p1,"cost_diff"),Reflect.field(p2,"cost_diff")):
            if (Reflect.field(p1,"cost_diff") < Reflect.field(p2,"cost_diff")):
                return 1
            else:
                return 0
        if (Reflect.field(Math,"fabs")((Reflect.field(p1,"idx1") - Reflect.field(p1,"idx2"))) < Reflect.field(Math,"fabs")((Reflect.field(p2,"idx1") - Reflect.field(p2,"idx2")))):
            return 1
        else:
            return 0

    def swap(self,a,b):
        temp = (self.arr[a] if a >= 0 and a < len(self.arr) else None)
        python_internal_ArrayImpl._set(self.arr, a, (self.arr[b] if b >= 0 and b < len(self.arr) else None))
        python_internal_ArrayImpl._set(self.arr, b, temp)

    def bubbleDown(self,pos):
        left = ((2 * pos) + 1)
        right = (left + 1)
        largest = pos
        if ((left < len(self.arr)) and ((self.comp((self.arr[left] if left >= 0 and left < len(self.arr) else None),(self.arr[pos] if pos >= 0 and pos < len(self.arr) else None)) > 0))):
            largest = left
        if ((right < len(self.arr)) and ((self.comp((self.arr[right] if right >= 0 and right < len(self.arr) else None),(self.arr[largest] if largest >= 0 and largest < len(self.arr) else None)) > 0))):
            largest = right
        if (largest != pos):
            self.swap(largest,pos)
            self.bubbleDown(largest)

    def bubbleUp(self,pos):
        if (pos <= 0):
            return
        parent = Math.floor((((pos - 1)) / 2))
        if (self.comp((self.arr[pos] if pos >= 0 and pos < len(self.arr) else None),(self.arr[parent] if parent >= 0 and parent < len(self.arr) else None)) > 0):
            self.swap(pos,parent)
            self.bubbleUp(parent)

    def pop(self):
        if (len(self.arr) == 0):
            return None
        value = (self.arr[0] if 0 < len(self.arr) else None)
        last = (len(self.arr) - 1)
        python_internal_ArrayImpl._set(self.arr, 0, (self.arr[last] if last >= 0 and last < len(self.arr) else None))
        _this = self.arr
        if (len(_this) != 0):
            _this.pop()
        if (last > 0):
            self.bubbleDown(0)
        return value

    def push(self,value):
        self.arr.append(value)
        self.bubbleUp((len(self.arr) - 1))

    def size(self):
        return len(self.arr)



class encode_Bit_cost:
    _hx_class_name = "encode.Bit_cost"
    __slots__ = ()
    _hx_statics = ["BitsEntropy", "PopulationCost"]

    def __init__(self):
        pass

    @staticmethod
    def BitsEntropy(population,population_off,size):
        sum = 0
        retval = 0
        population_end_off = (population_off + size)
        p = None
        if (((size & 1)) > 0):
            index = population_off
            population_off = (population_off + 1)
            p = population[index]
            sum = p
            retval = (retval - ((p * encode_Fast_log.FastLog2(p))))
        while (population_off < population_end_off):
            index1 = population_off
            population_off = (population_off + 1)
            p = population[index1]
            sum = (sum + p)
            retval = (retval - ((p * encode_Fast_log.FastLog2(p))))
            index2 = population_off
            population_off = (population_off + 1)
            p = population[index2]
            sum = (sum + p)
            retval = (retval - ((p * encode_Fast_log.FastLog2(p))))
        if (sum > 0):
            retval = (retval + ((sum * encode_Fast_log.FastLog2(sum))))
        if (retval < sum):
            retval = sum
        return retval

    @staticmethod
    def PopulationCost(histogram):
        kSize = len(histogram.data_)
        if (histogram.total_count_ == 0):
            return 12
        count = 0
        _g1 = 0
        while (_g1 < kSize):
            i = _g1
            _g1 = (_g1 + 1)
            if (histogram.data_[i] > 0):
                count = (count + 1)
        if (count == 1):
            return 12
        if (count == 2):
            return (20 + histogram.total_count_)
        bits = 0
        depth = FunctionMalloc.mallocUInt(kSize)
        if (count <= 4):
            encode_Entropy_encode.CreateHuffmanTree(histogram.data_,0,kSize,15,depth,0)
            _g11 = 0
            while (_g11 < kSize):
                i1 = _g11
                _g11 = (_g11 + 1)
                _hx_int = (histogram.data_[i1] * depth[i1])
                bits = ((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) + bits)
            if (count == 3):
                return (bits + 28)
            else:
                return (bits + 37)
        max_depth = 1
        depth_histo = FunctionMalloc.mallocInt(18)
        log2total = encode_Fast_log.FastLog2(histogram.total_count_)
        i2 = 0
        while (i2 < kSize):
            if (histogram.data_[i2] > 0):
                log2p = (log2total - encode_Fast_log.FastLog2(histogram.data_[i2]))
                depth1 = None
                try:
                    depth1 = int((log2p + 0.5))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    depth1 = None
                depth2 = depth1
                bits = (bits + ((histogram.data_[i2] * log2p)))
                if (depth2 > 15):
                    depth2 = 15
                if (depth2 > max_depth):
                    max_depth = depth2
                _g = depth2
                val = (depth_histo[_g] + 1)
                depth_histo[_g] = val
                i2 = (i2 + 1)
            else:
                reps = 1
                k = (i2 + 1)
                while ((k < kSize) and ((histogram.data_[k] == 0))):
                    reps = (reps + 1)
                    k = (k + 1)
                i2 = (i2 + reps)
                if (i2 == kSize):
                    break
                if (reps < 3):
                    val1 = (depth_histo[0] + reps)
                    depth_histo[0] = val1
                else:
                    reps = (reps - 2)
                    while (reps > 0):
                        val2 = (depth_histo[17] + 1)
                        depth_histo[17] = val2
                        bits = (bits + 3)
                        reps = (reps >> 3)
        bits = (bits + ((18 + ((2 * max_depth)))))
        bits = (bits + encode_Bit_cost.BitsEntropy(depth_histo,0,18))
        return bits


class encode_Block_splitter:
    _hx_class_name = "encode.Block_splitter"
    __slots__ = ()
    _hx_statics = ["kMaxLiteralHistograms", "kMaxCommandHistograms", "kLiteralBlockSwitchCost", "kCommandBlockSwitchCost", "kDistanceBlockSwitchCost", "kLiteralStrideLength", "kCommandStrideLength", "kSymbolsPerLiteralHistogram", "kSymbolsPerCommandHistogram", "kSymbolsPerDistanceHistogram", "kMinLengthForBlockSplitting", "kIterMulForRefining", "kMinItersForRefining", "CopyLiteralsToByteArray", "CopyCommandsToByteArray", "MyRand", "InitialEntropyCodes", "RandomSample", "RefineEntropyCodes", "BitCost", "FindBlocks", "RemapBlockIds", "BuildBlockHistograms", "ClusterBlocks", "BuildBlockSplit", "SplitByteVector", "SplitBlock"]

    def __init__(self):
        pass

    @staticmethod
    def CopyLiteralsToByteArray(cmds,num_commands,data,data_off,literals):
        total_length = 0
        _g1 = 0
        while (_g1 < num_commands):
            i = _g1
            _g1 = (_g1 + 1)
            total_length = (total_length + (cmds[i] if i >= 0 and i < len(cmds) else None).insert_len_)
        if (total_length == 0):
            return
        while (len(literals) > total_length):
            if (len(literals) != 0):
                literals.pop()
        pos = 0
        from_pos = 0
        i1 = 0
        while ((i1 < num_commands) and ((pos < total_length))):
            DefaultFunctions.memcpyArrayVector(literals,pos,data,(data_off + from_pos),(cmds[i1] if i1 >= 0 and i1 < len(cmds) else None).insert_len_)
            pos = (pos + (cmds[i1] if i1 >= 0 and i1 < len(cmds) else None).insert_len_)
            from_pos = (from_pos + (((cmds[i1] if i1 >= 0 and i1 < len(cmds) else None).insert_len_ + (cmds[i1] if i1 >= 0 and i1 < len(cmds) else None).copy_len_)))
            i1 = (i1 + 1)

    @staticmethod
    def CopyCommandsToByteArray(cmds,num_commands,insert_and_copy_codes,distance_prefixes):
        _g1 = 0
        while (_g1 < num_commands):
            i = _g1
            _g1 = (_g1 + 1)
            cmd = (cmds[i] if i >= 0 and i < len(cmds) else None)
            x = (cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None)
            insert_and_copy_codes.append(x)
            tmp = None
            if (cmd.copy_len_ > 0):
                a = (cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None)
                aNeg = (a < 0)
                if (aNeg != False):
                    tmp = aNeg
                else:
                    tmp = (a >= 128)
            else:
                tmp = False
            if tmp:
                x1 = (cmd.dist_prefix_[0] if 0 < len(cmd.dist_prefix_) else None)
                distance_prefixes.append(x1)

    @staticmethod
    def MyRand(seed):
        python_internal_ArrayImpl._set(seed, 0, ((seed[0] if 0 < len(seed) else None) * 16807))
        python_internal_ArrayImpl._set(seed, 0, HxOverrides.rshift((seed[0] if 0 < len(seed) else None), 0))
        if ((seed[0] if 0 < len(seed) else None) == 0):
            python_internal_ArrayImpl._set(seed, 0, 1)
        return (seed[0] if 0 < len(seed) else None)

    @staticmethod
    def InitialEntropyCodes(HistogramTypeInt,data,length,literals_per_histogram,max_histograms,stride,vec):
        total_histograms = None
        try:
            total_histograms = int((length / literals_per_histogram))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            total_histograms = None
        total_histograms1 = (total_histograms + 1)
        if (total_histograms1 > max_histograms):
            total_histograms1 = max_histograms
        seed_0 = 7
        block_length = None
        try:
            block_length = int((length / total_histograms1))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            block_length = None
        block_length1 = block_length
        _g1 = 0
        _g = total_histograms1
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            pos = None
            try:
                pos = int(((length * i) / total_histograms1))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                pos = None
            pos1 = pos
            if (i != 0):
                seed_0 = (seed_0 * 16807)
                seed_0 = HxOverrides.rshift(seed_0, 0)
                if (seed_0 == 0):
                    seed_0 = 1
                a = seed_0
                b = None
                try:
                    _hx_int = a
                    b = int(HxOverrides.modf((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))), (((4294967296.0 + block_length1) if ((block_length1 < 0)) else (block_length1 + 0.0)))))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e3 = _hx_e1
                    b = None
                pos1 = (pos1 + b)
            if ((pos1 + stride) >= length):
                pos1 = ((length - stride) - 1)
            histo = encode_histogram_Histogram(HistogramTypeInt)
            histo.Add2(data,pos1,stride)
            vec.append(histo)

    @staticmethod
    def RandomSample(seed,data,length,stride,sample):
        pos = 0
        if (stride >= length):
            pos = 0
            stride = length
        else:
            python_internal_ArrayImpl._set(seed, 0, ((seed[0] if 0 < len(seed) else None) * 16807))
            python_internal_ArrayImpl._set(seed, 0, HxOverrides.rshift((seed[0] if 0 < len(seed) else None), 0))
            if ((seed[0] if 0 < len(seed) else None) == 0):
                python_internal_ArrayImpl._set(seed, 0, 1)
            a = (seed[0] if 0 < len(seed) else None)
            pos1 = None
            try:
                _hx_int = a
                int1 = ((length - stride) + 1)
                pos1 = int(HxOverrides.modf((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))), (((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0)))))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                pos1 = None
            pos = pos1
        sample.Add2(data,pos,stride)

    @staticmethod
    def RefineEntropyCodes(HistogramTypeInt,data,length,stride,vec):
        iters = None
        try:
            iters = int(((2 * length) / stride))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            iters = None
        iters1 = (iters + 100)
        seed = [7]
        x = ((((iters1 + len(vec)) - 1)) / len(vec))
        iters2 = None
        try:
            iters2 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            iters2 = None
        iters1 = (iters2 * len(vec))
        _g1 = 0
        _g = iters1
        while (_g1 < _g):
            iter = _g1
            _g1 = (_g1 + 1)
            sample = encode_histogram_Histogram(HistogramTypeInt)
            encode_Block_splitter.RandomSample(seed,data,length,stride,sample)
            python_internal_ArrayImpl._get(vec, HxOverrides.mod(iter, len(vec))).AddHistogram(sample)

    @staticmethod
    def BitCost(count):
        if (count == 0):
            return -2
        else:
            return encode_Fast_log.FastLog2(count)

    @staticmethod
    def FindBlocks(kSize,data,length,block_switch_bitcost,vec,block_id,block_id_off):
        if (len(vec) <= 1):
            _g1 = 0
            while (_g1 < length):
                i = _g1
                _g1 = (_g1 + 1)
                block_id[i] = 0
            return
        vecsize = len(vec)
        insert_cost = FunctionMalloc.mallocFloat((kSize * vecsize))
        _g11 = 0
        while (_g11 < vecsize):
            j = _g11
            _g11 = (_g11 + 1)
            val = encode_Fast_log.FastLog2((vec[j] if j >= 0 and j < len(vec) else None).total_count_)
            insert_cost[j] = val
        i1 = (kSize - 1)
        while (i1 >= 0):
            _g12 = 0
            while (_g12 < vecsize):
                j1 = _g12
                _g12 = (_g12 + 1)
                val1 = insert_cost[j1]
                count = (vec[j1] if j1 >= 0 and j1 < len(vec) else None).data_[i1]
                val2 = (-2 if ((count == 0)) else encode_Fast_log.FastLog2(count))
                insert_cost[((i1 * vecsize) + j1)] = (val1 - val2)
            i1 = (i1 - 1)
        cost = FunctionMalloc.mallocFloat(vecsize)
        switch_signal = FunctionMalloc.mallocBool((length * vecsize))
        _g13 = 0
        while (_g13 < length):
            byte_ix = _g13
            _g13 = (_g13 + 1)
            ix = (byte_ix * vecsize)
            insert_cost_ix = ((data[byte_ix] if byte_ix >= 0 and byte_ix < len(data) else None) * vecsize)
            min_cost = 1e99
            _g3 = 0
            while (_g3 < vecsize):
                k = _g3
                _g3 = (_g3 + 1)
                val3 = (cost[k] + insert_cost[(insert_cost_ix + k)])
                cost[k] = val3
                if (cost[k] < min_cost):
                    min_cost = cost[k]
                    block_id[byte_ix] = k
            block_switch_cost = block_switch_bitcost
            if (byte_ix < 2000):
                block_switch_cost = (block_switch_bitcost * ((0.77 + (((0.07 * byte_ix) / 2000)))))
            _g31 = 0
            while (_g31 < vecsize):
                k1 = _g31
                _g31 = (_g31 + 1)
                val4 = (cost[k1] - min_cost)
                cost[k1] = val4
                if (cost[k1] >= block_switch_cost):
                    cost[k1] = block_switch_cost
                    switch_signal[(ix + k1)] = True
        byte_ix1 = (length - 1)
        ix1 = (byte_ix1 * vecsize)
        cur_id = block_id[byte_ix1]
        while (byte_ix1 > 0):
            byte_ix1 = (byte_ix1 - 1)
            ix1 = (ix1 - vecsize)
            if switch_signal[(ix1 + cur_id)]:
                cur_id = block_id[byte_ix1]
            block_id[byte_ix1] = cur_id

    @staticmethod
    def RemapBlockIds(block_ids,length):
        new_id = haxe_ds_IntMap()
        next_id = 0
        _g1 = 0
        while (_g1 < length):
            i = _g1
            _g1 = (_g1 + 1)
            if ((block_ids[i] in new_id.h) == False):
                new_id.set(block_ids[i],next_id)
                next_id = (next_id + 1)
        _g11 = 0
        while (_g11 < length):
            i1 = _g11
            _g11 = (_g11 + 1)
            key = block_ids[i1]
            val = new_id.h.get(key,None)
            block_ids[i1] = val
        return next_id

    @staticmethod
    def BuildBlockHistograms(HistogramTypeInt,data,length,block_ids,block_ids_off,histograms):
        num_types = encode_Block_splitter.RemapBlockIds(block_ids,length)
        while (len(histograms) > 0):
            if (len(histograms) != 0):
                histograms.pop()
        _g1 = 0
        while (_g1 < num_types):
            _g1 = (_g1 + 1)
            x = encode_histogram_Histogram(HistogramTypeInt)
            histograms.append(x)
        _g11 = 0
        while (_g11 < length):
            i = _g11
            _g11 = (_g11 + 1)
            python_internal_ArrayImpl._get(histograms, block_ids[i]).Add1((data[i] if i >= 0 and i < len(data) else None))

    @staticmethod
    def ClusterBlocks(HistogramTypeInt,data,length,block_ids):
        histograms = list()
        block_index = FunctionMalloc.mallocInt(length)
        cur_idx = 0
        cur_histogram = encode_histogram_Histogram(HistogramTypeInt)
        _g1 = 0
        while (_g1 < length):
            i = _g1
            _g1 = (_g1 + 1)
            block_boundary = (((i + 1) == length) or ((block_ids[i] != block_ids[(i + 1)])))
            block_index[i] = cur_idx
            cur_histogram.Add1((data[i] if i >= 0 and i < len(data) else None))
            if block_boundary:
                histograms.append(cur_histogram)
                cur_histogram = encode_histogram_Histogram(HistogramTypeInt)
                cur_idx = (cur_idx + 1)
        clustered_histograms = list()
        histogram_symbols = [None]*len(histograms)
        encode_Cluster.ClusterHistograms(histograms,1,len(histograms),256,clustered_histograms,HistogramTypeInt,histogram_symbols)
        _g11 = 0
        while (_g11 < length):
            i1 = _g11
            _g11 = (_g11 + 1)
            val = histogram_symbols[block_index[i1]]
            block_ids[i1] = val

    @staticmethod
    def BuildBlockSplit(block_ids,split):
        cur_id = block_ids[0]
        cur_length = 1
        split.num_types = -1
        _g1 = 1
        _g = len(block_ids)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (block_ids[i] != cur_id):
                split.types.append(cur_id)
                split.lengths.append(cur_length)
                a = split.num_types
                x = (a if (python_lib_Math.isnan(a)) else (cur_id if (python_lib_Math.isnan(cur_id)) else max(a,cur_id)))
                tmp = None
                try:
                    tmp = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    tmp = None
                split.num_types = tmp
                cur_id = block_ids[i]
                cur_length = 0
            cur_length = (cur_length + 1)
        split.types.append(cur_id)
        split.lengths.append(cur_length)
        a1 = split.num_types
        x1 = (a1 if (python_lib_Math.isnan(a1)) else (cur_id if (python_lib_Math.isnan(cur_id)) else max(a1,cur_id)))
        tmp1 = None
        try:
            tmp1 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp1 = None
        split.num_types = tmp1
        split.num_types = (split.num_types + 1)

    @staticmethod
    def SplitByteVector(HistogramTypeInt,data,literals_per_histogram,max_histograms,sampling_stride_length,block_switch_cost,split):
        if (len(data) == 0):
            split.num_types = 1
            return
        elif (len(data) < 128):
            split.num_types = 1
            split.types.append(0)
            x = len(data)
            split.lengths.append(x)
            return
        histograms = list()
        encode_Block_splitter.InitialEntropyCodes(HistogramTypeInt,data,len(data),literals_per_histogram,max_histograms,sampling_stride_length,histograms)
        encode_Block_splitter.RefineEntropyCodes(HistogramTypeInt,data,len(data),sampling_stride_length,histograms)
        block_ids = FunctionMalloc.mallocUInt(len(data))
        _g = 0
        while (_g < 10):
            _g = (_g + 1)
            encode_Block_splitter.FindBlocks(HistogramTypeInt,data,len(data),block_switch_cost,histograms,block_ids,0)
            encode_Block_splitter.BuildBlockHistograms(HistogramTypeInt,data,len(data),block_ids,0,histograms)
        encode_Block_splitter.ClusterBlocks(HistogramTypeInt,data,len(data),block_ids)
        encode_Block_splitter.BuildBlockSplit(block_ids,split)

    @staticmethod
    def SplitBlock(cmds,num_commands,data,data_off,literal_split,insert_and_copy_split,dist_split):
        literals = list()
        encode_Block_splitter.CopyLiteralsToByteArray(cmds,num_commands,data,data_off,literals)
        insert_and_copy_codes = list()
        distance_prefixes = list()
        encode_Block_splitter.CopyCommandsToByteArray(cmds,num_commands,insert_and_copy_codes,distance_prefixes)
        encode_Block_splitter.SplitByteVector(encode_Histogram_functions.HistogramLiteralInt,literals,544,100,70,28.1,literal_split)
        encode_Block_splitter.SplitByteVector(encode_Histogram_functions.HistogramCommandInt,insert_and_copy_codes,530,50,40,13.5,insert_and_copy_split)
        encode_Block_splitter.SplitByteVector(encode_Histogram_functions.HistogramDistanceInt,distance_prefixes,544,50,40,14.6,dist_split)


class encode_Brotli_bit_stream:
    _hx_class_name = "encode.Brotli_bit_stream"
    __slots__ = ()
    _hx_statics = ["EncodeMlen", "StoreVarLenUint8", "StoreCompressedMetaBlockHeader", "StoreUncompressedMetaBlockHeader", "StoreHuffmanTreeOfHuffmanTreeToBitMask", "StoreHuffmanTreeToBitMask", "StoreSimpleHuffmanTree", "StoreHuffmanTree", "BuildAndStoreHuffmanTree", "IndexOf", "MoveToFront", "MoveToFrontTransform", "RunLengthCodeZeros", "EncodeContextMap", "StoreBlockSwitch", "BuildAndStoreBlockSplitCode", "StoreTrivialContextMap", "JumpToByteBoundary", "StoreMetaBlock", "StoreMetaBlockTrivial", "StoreUncompressedMetaBlock"]

    def __init__(self):
        pass

    @staticmethod
    def EncodeMlen(length,bits,numbits,nibblesbits):
        length = (length - 1)
        lg = (1 if ((length == 0)) else (encode_Fast_log.Log2Floor(length) + 1))
        if (lg > 24):
            return False
        mnibbles = None
        try:
            mnibbles = int((((16 if ((lg < 16)) else (lg + 3))) / 4))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            mnibbles = None
        mnibbles1 = mnibbles
        python_internal_ArrayImpl._set(nibblesbits, 0, (mnibbles1 - 4))
        python_internal_ArrayImpl._set(numbits, 0, (mnibbles1 * 4))
        python_internal_ArrayImpl._set(bits, 0, length)
        return True

    @staticmethod
    def StoreVarLenUint8(n,storage_ix,storage):
        if (n == 0):
            encode_Write_bits.WriteBits(1,0,storage_ix,storage)
        else:
            encode_Write_bits.WriteBits(1,1,storage_ix,storage)
            nbits = encode_Fast_log.Log2Floor(n)
            encode_Write_bits.WriteBits(3,nbits,storage_ix,storage)
            encode_Write_bits.WriteBits(nbits,(n - ((1 << nbits))),storage_ix,storage)

    @staticmethod
    def StoreCompressedMetaBlockHeader(final_block,length,storage_ix,storage):
        encode_Write_bits.WriteBits(1,(1 if final_block else 0),storage_ix,storage)
        if final_block:
            encode_Write_bits.WriteBits(1,(1 if ((length == 0)) else 0),storage_ix,storage)
            if (length == 0):
                return True
        if (length == 0):
            return False
        lenbits = list()
        nlenbits = list()
        nibblesbits = list()
        if (not encode_Brotli_bit_stream.EncodeMlen(length,lenbits,nlenbits,nibblesbits)):
            return False
        encode_Write_bits.WriteBits(2,(nibblesbits[0] if 0 < len(nibblesbits) else None),storage_ix,storage)
        encode_Write_bits.WriteBits((nlenbits[0] if 0 < len(nlenbits) else None),(lenbits[0] if 0 < len(lenbits) else None),storage_ix,storage)
        if (not final_block):
            encode_Write_bits.WriteBits(1,0,storage_ix,storage)
        return True

    @staticmethod
    def StoreUncompressedMetaBlockHeader(length,storage_ix,storage):
        encode_Write_bits.WriteBits(1,0,storage_ix,storage)
        lenbits = list()
        nlenbits = list()
        nibblesbits = list()
        if (not encode_Brotli_bit_stream.EncodeMlen(length,lenbits,nlenbits,nibblesbits)):
            return False
        encode_Write_bits.WriteBits(2,(nibblesbits[0] if 0 < len(nibblesbits) else None),storage_ix,storage)
        encode_Write_bits.WriteBits((nlenbits[0] if 0 < len(nlenbits) else None),(lenbits[0] if 0 < len(lenbits) else None),storage_ix,storage)
        encode_Write_bits.WriteBits(1,1,storage_ix,storage)
        return True

    @staticmethod
    def StoreHuffmanTreeOfHuffmanTreeToBitMask(num_codes,code_length_bitdepth,storage_ix,storage):
        kStorageOrder = [1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15]
        kHuffmanBitLengthHuffmanCodeSymbols = [0, 7, 3, 2, 1, 15]
        kHuffmanBitLengthHuffmanCodeBitLengths = [2, 4, 3, 2, 2, 4]
        codes_to_store = 18
        if (num_codes > 1):
            while (codes_to_store > 0):
                if (code_length_bitdepth[python_internal_ArrayImpl._get(kStorageOrder, (codes_to_store - 1))] != 0):
                    break
                codes_to_store = (codes_to_store - 1)
        skip_some = 0
        if ((code_length_bitdepth[(kStorageOrder[0] if 0 < len(kStorageOrder) else None)] == 0) and ((code_length_bitdepth[(kStorageOrder[1] if 1 < len(kStorageOrder) else None)] == 0))):
            skip_some = 2
            if (code_length_bitdepth[(kStorageOrder[2] if 2 < len(kStorageOrder) else None)] == 0):
                skip_some = 3
        encode_Write_bits.WriteBits(2,skip_some,storage_ix,storage)
        _g1 = skip_some
        _g = codes_to_store
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            l = code_length_bitdepth[(kStorageOrder[i] if i >= 0 and i < len(kStorageOrder) else None)]
            encode_Write_bits.WriteBits((kHuffmanBitLengthHuffmanCodeBitLengths[l] if l >= 0 and l < len(kHuffmanBitLengthHuffmanCodeBitLengths) else None),(kHuffmanBitLengthHuffmanCodeSymbols[l] if l >= 0 and l < len(kHuffmanBitLengthHuffmanCodeSymbols) else None),storage_ix,storage)

    @staticmethod
    def StoreHuffmanTreeToBitMask(huffman_tree,huffman_tree_extra_bits,code_length_bitdepth,code_length_bitdepth_off,code_length_bitdepth_symbols,storage_ix,storage):
        _g1 = 0
        _g = len(huffman_tree)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            ix = (huffman_tree[i] if i >= 0 and i < len(huffman_tree) else None)
            encode_Write_bits.WriteBits(code_length_bitdepth[ix],code_length_bitdepth_symbols[ix],storage_ix,storage)
            if (ix == 16):
                encode_Write_bits.WriteBits(2,(huffman_tree_extra_bits[i] if i >= 0 and i < len(huffman_tree_extra_bits) else None),storage_ix,storage)
            elif (ix == 17):
                encode_Write_bits.WriteBits(3,(huffman_tree_extra_bits[i] if i >= 0 and i < len(huffman_tree_extra_bits) else None),storage_ix,storage)
            else:
                pass

    @staticmethod
    def StoreSimpleHuffmanTree(depths,depths_off,symbols,num_symbols,max_bits,storage_ix,storage):
        encode_Write_bits.WriteBits(2,1,storage_ix,storage)
        encode_Write_bits.WriteBits(2,(num_symbols - 1),storage_ix,storage)
        _g1 = 0
        while (_g1 < num_symbols):
            i = _g1
            _g1 = (_g1 + 1)
            _g3 = (i + 1)
            while (_g3 < num_symbols):
                j = _g3
                _g3 = (_g3 + 1)
                a = depths[(depths_off + (symbols[j] if j >= 0 and j < len(symbols) else None))]
                b = depths[(depths_off + (symbols[i] if i >= 0 and i < len(symbols) else None))]
                aNeg = (b < 0)
                if (aNeg if ((aNeg != ((a < 0)))) else (b > a)):
                    t = (symbols[j] if j >= 0 and j < len(symbols) else None)
                    python_internal_ArrayImpl._set(symbols, j, (symbols[i] if i >= 0 and i < len(symbols) else None))
                    python_internal_ArrayImpl._set(symbols, i, t)
        if (num_symbols == 2):
            encode_Write_bits.WriteBits(max_bits,(symbols[0] if 0 < len(symbols) else None),storage_ix,storage)
            encode_Write_bits.WriteBits(max_bits,(symbols[1] if 1 < len(symbols) else None),storage_ix,storage)
        elif (num_symbols == 3):
            encode_Write_bits.WriteBits(max_bits,(symbols[0] if 0 < len(symbols) else None),storage_ix,storage)
            encode_Write_bits.WriteBits(max_bits,(symbols[1] if 1 < len(symbols) else None),storage_ix,storage)
            encode_Write_bits.WriteBits(max_bits,(symbols[2] if 2 < len(symbols) else None),storage_ix,storage)
        else:
            encode_Write_bits.WriteBits(max_bits,(symbols[0] if 0 < len(symbols) else None),storage_ix,storage)
            encode_Write_bits.WriteBits(max_bits,(symbols[1] if 1 < len(symbols) else None),storage_ix,storage)
            encode_Write_bits.WriteBits(max_bits,(symbols[2] if 2 < len(symbols) else None),storage_ix,storage)
            encode_Write_bits.WriteBits(max_bits,(symbols[3] if 3 < len(symbols) else None),storage_ix,storage)
            encode_Write_bits.WriteBits(1,(1 if ((depths[(depths_off + (symbols[0] if 0 < len(symbols) else None))] == 1)) else 0),storage_ix,storage)

    @staticmethod
    def StoreHuffmanTree(depths,depths_off,num,storage_ix,storage):
        huffman_tree = list()
        huffman_tree_extra_bits = list()
        encode_Entropy_encode.WriteHuffmanTree(depths,depths_off,num,huffman_tree,huffman_tree_extra_bits)
        huffman_tree_histogram = FunctionMalloc.mallocInt(18)
        _g1 = 0
        _g = len(huffman_tree)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            _g2 = (huffman_tree[i] if i >= 0 and i < len(huffman_tree) else None)
            val = (huffman_tree_histogram[_g2] + 1)
            huffman_tree_histogram[_g2] = val
        num_codes = 0
        code = 0
        _g3 = 0
        while (_g3 < 18):
            i1 = _g3
            _g3 = (_g3 + 1)
            if (huffman_tree_histogram[i1] > 0):
                if (num_codes == 0):
                    code = i1
                    num_codes = 1
                elif (num_codes == 1):
                    num_codes = 2
                    break
        code_length_bitdepth = FunctionMalloc.mallocUInt(18)
        code_length_bitdepth_symbols = FunctionMalloc.mallocUInt(18)
        encode_Entropy_encode.CreateHuffmanTree(huffman_tree_histogram,0,18,5,code_length_bitdepth,0)
        encode_Entropy_encode.ConvertBitDepthsToSymbols(code_length_bitdepth,0,18,code_length_bitdepth_symbols,0)
        encode_Brotli_bit_stream.StoreHuffmanTreeOfHuffmanTreeToBitMask(num_codes,code_length_bitdepth,storage_ix,storage)
        if (num_codes == 1):
            code_length_bitdepth[code] = 0
        encode_Brotli_bit_stream.StoreHuffmanTreeToBitMask(huffman_tree,huffman_tree_extra_bits,code_length_bitdepth,0,code_length_bitdepth_symbols,storage_ix,storage)

    @staticmethod
    def BuildAndStoreHuffmanTree(histogram,length,depth,depth_off,bits,bits_off,storage_ix,storage):
        count = 0
        s4 = [0, 0, 0, 0]
        _g1 = 0
        while (_g1 < length):
            i = _g1
            _g1 = (_g1 + 1)
            if (histogram[i] > 0):
                if (count < 4):
                    python_internal_ArrayImpl._set(s4, count, i)
                elif (count > 4):
                    break
                count = (count + 1)
        max_bits_counter = (length - 1)
        max_bits = 0
        while (max_bits_counter > 0):
            max_bits_counter = (max_bits_counter >> 1)
            max_bits = (max_bits + 1)
        if (count <= 1):
            encode_Write_bits.WriteBits(4,1,storage_ix,storage)
            encode_Write_bits.WriteBits(max_bits,(s4[0] if 0 < len(s4) else None),storage_ix,storage)
            return
        encode_Entropy_encode.CreateHuffmanTree(histogram,0,length,15,depth,depth_off)
        encode_Entropy_encode.ConvertBitDepthsToSymbols(depth,depth_off,length,bits,bits_off)
        if (count <= 4):
            encode_Brotli_bit_stream.StoreSimpleHuffmanTree(depth,depth_off,s4,count,max_bits,storage_ix,storage)
        else:
            encode_Brotli_bit_stream.StoreHuffmanTree(depth,depth_off,length,storage_ix,storage)

    @staticmethod
    def IndexOf(v,value):
        _g1 = 0
        _g = len(v)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (v[i] == value):
                return i
        return -1

    @staticmethod
    def MoveToFront(v,index):
        value = v[index]
        i = index
        while (i > 0):
            val = v[(i - 1)]
            v[i] = val
            i = (i - 1)
        v[0] = value

    @staticmethod
    def MoveToFrontTransform(v):
        if (len(v) == 0):
            return v
        max_element = 0
        _g1 = 0
        _g = len(v)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (max_element < v[i]):
                max_element = v[i]
        mtf = [None]*(max_element + 1)
        _g11 = 0
        _g2 = len(mtf)
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            mtf[i1] = i1
        result = [None]*len(v)
        _g12 = 0
        _g3 = len(v)
        while (_g12 < _g3):
            i2 = _g12
            _g12 = (_g12 + 1)
            index = encode_Brotli_bit_stream.IndexOf(mtf,v[i2])
            result[i2] = index
            encode_Brotli_bit_stream.MoveToFront(mtf,index)
        return result

    @staticmethod
    def RunLengthCodeZeros(v_in,max_run_length_prefix,v_out,extra_bits):
        max_reps = 0
        i = 0
        while (i < len(v_in)):
            while ((i < len(v_in)) and ((v_in[i] != 0))):
                i = (i + 1)
            reps = 0
            while ((i < len(v_in)) and ((v_in[i] == 0))):
                reps = (reps + 1)
                i = (i + 1)
            x = (reps if (python_lib_Math.isnan(reps)) else (max_reps if (python_lib_Math.isnan(max_reps)) else max(reps,max_reps)))
            try:
                max_reps = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                max_reps = None
        max_prefix = (encode_Fast_log.Log2Floor(max_reps) if ((max_reps > 0)) else 0)
        b = (max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None)
        x1 = (max_prefix if (python_lib_Math.isnan(max_prefix)) else (b if (python_lib_Math.isnan(b)) else min(max_prefix,b)))
        tmp = None
        try:
            tmp = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp = None
        python_internal_ArrayImpl._set(max_run_length_prefix, 0, tmp)
        i1 = 0
        while (i1 < len(v_in)):
            if (v_in[i1] != 0):
                x2 = (v_in[i1] + (max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None))
                v_out.append(x2)
                extra_bits.append(0)
                i1 = (i1 + 1)
            else:
                reps1 = 1
                k = (i1 + 1)
                while ((k < len(v_in)) and ((v_in[k] == 0))):
                    reps1 = (reps1 + 1)
                    k = (k + 1)
                i1 = (i1 + reps1)
                while (reps1 > 0):
                    if (reps1 < ((2 << (max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None)))):
                        run_length_prefix = encode_Fast_log.Log2Floor(reps1)
                        v_out.append(run_length_prefix)
                        extra_bits.append((reps1 - ((1 << run_length_prefix))))
                        break
                    else:
                        v_out.append((max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None))
                        extra_bits.append((((1 << (max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None))) - 1))
                        reps1 = (reps1 - ((((2 << (max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None))) - 1)))

    @staticmethod
    def EncodeContextMap(context_map,num_clusters,storage_ix,storage):
        encode_Brotli_bit_stream.StoreVarLenUint8((num_clusters - 1),storage_ix,storage)
        if (num_clusters == 1):
            return
        transformed_symbols = encode_Brotli_bit_stream.MoveToFrontTransform(context_map)
        rle_symbols = list()
        extra_bits = list()
        max_run_length_prefix = [6]
        encode_Brotli_bit_stream.RunLengthCodeZeros(transformed_symbols,max_run_length_prefix,rle_symbols,extra_bits)
        symbol_histogram = encode_Histogram_functions.HistogramContextMap()
        _g1 = 0
        _g = len(rle_symbols)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            symbol_histogram.Add1((rle_symbols[i] if i >= 0 and i < len(rle_symbols) else None))
        use_rle = ((max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None) > 0)
        encode_Write_bits.WriteBits(1,(1 if use_rle else 0),storage_ix,storage)
        if use_rle:
            encode_Write_bits.WriteBits(4,((max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None) - 1),storage_ix,storage)
        symbol_code = encode_Entropy_encode.EntropyCodeContextMap()
        DefaultFunctions.memset_UInt(symbol_code.depth_,0,0,len(symbol_code.depth_))
        DefaultFunctions.memset_UInt(symbol_code.bits_,0,0,len(symbol_code.bits_))
        encode_Brotli_bit_stream.BuildAndStoreHuffmanTree(symbol_histogram.data_,(num_clusters + (max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None)),symbol_code.depth_,0,symbol_code.bits_,0,storage_ix,storage)
        _g11 = 0
        _g2 = len(rle_symbols)
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            encode_Write_bits.WriteBits(symbol_code.depth_[(rle_symbols[i1] if i1 >= 0 and i1 < len(rle_symbols) else None)],symbol_code.bits_[(rle_symbols[i1] if i1 >= 0 and i1 < len(rle_symbols) else None)],storage_ix,storage)
            if (((rle_symbols[i1] if i1 >= 0 and i1 < len(rle_symbols) else None) > 0) and (((rle_symbols[i1] if i1 >= 0 and i1 < len(rle_symbols) else None) <= (max_run_length_prefix[0] if 0 < len(max_run_length_prefix) else None)))):
                encode_Write_bits.WriteBits((rle_symbols[i1] if i1 >= 0 and i1 < len(rle_symbols) else None),(extra_bits[i1] if i1 >= 0 and i1 < len(extra_bits) else None),storage_ix,storage)
        encode_Write_bits.WriteBits(1,1,storage_ix,storage)

    @staticmethod
    def StoreBlockSwitch(code,block_ix,storage_ix,storage):
        if (block_ix > 0):
            typecode = code.type_code[block_ix]
            encode_Write_bits.WriteBits(code.type_depths[typecode],code.type_bits[typecode],storage_ix,storage)
        lencode = code.length_prefix[block_ix]
        encode_Write_bits.WriteBits(code.length_depths[lencode],code.length_bits[lencode],storage_ix,storage)
        encode_Write_bits.WriteBits(code.length_nextra[block_ix],code.length_extra[block_ix],storage_ix,storage)

    @staticmethod
    def BuildAndStoreBlockSplitCode(types,lengths,num_types,code,storage_ix,storage):
        num_blocks = len(types)
        type_histo = FunctionMalloc.mallocInt((num_types + 2))
        length_histo = FunctionMalloc.mallocInt(26)
        last_type = 1
        second_last_type = 0
        code.type_code = FunctionMalloc.mallocInt(num_blocks)
        code.length_prefix = FunctionMalloc.mallocInt(num_blocks)
        code.length_nextra = FunctionMalloc.mallocInt(num_blocks)
        code.length_extra = FunctionMalloc.mallocInt(num_blocks)
        code.type_depths = FunctionMalloc.mallocUInt((num_types + 2))
        code.type_bits = FunctionMalloc.mallocUInt((num_types + 2))
        code.length_depths = FunctionMalloc.mallocUInt(26)
        code.length_bits = FunctionMalloc.mallocUInt(26)
        _g1 = 0
        while (_g1 < num_blocks):
            i = _g1
            _g1 = (_g1 + 1)
            _hx_type = (types[i] if i >= 0 and i < len(types) else None)
            type_code = (1 if ((_hx_type == ((last_type + 1)))) else (0 if ((_hx_type == second_last_type)) else (_hx_type + 2)))
            second_last_type = last_type
            last_type = _hx_type
            code.type_code[i] = type_code
            if (i > 0):
                _g2 = type_code
                val = (type_histo[_g2] + 1)
                type_histo[_g2] = val
            encode_Prefix.GetBlockLengthPrefixCode((lengths[i] if i >= 0 and i < len(lengths) else None),code.length_prefix,i,code.length_nextra,i,code.length_extra,i)
            _g21 = code.length_prefix[i]
            val1 = (length_histo[_g21] + 1)
            length_histo[_g21] = val1
        encode_Brotli_bit_stream.StoreVarLenUint8((num_types - 1),storage_ix,storage)
        if (num_types > 1):
            encode_Brotli_bit_stream.BuildAndStoreHuffmanTree(type_histo,(num_types + 2),code.type_depths,0,code.type_bits,0,storage_ix,storage)
            encode_Brotli_bit_stream.BuildAndStoreHuffmanTree(length_histo,26,code.length_depths,0,code.length_bits,0,storage_ix,storage)
            encode_Brotli_bit_stream.StoreBlockSwitch(code,0,storage_ix,storage)

    @staticmethod
    def StoreTrivialContextMap(num_types,context_bits,storage_ix,storage):
        encode_Brotli_bit_stream.StoreVarLenUint8((num_types - 1),storage_ix,storage)
        if (num_types > 1):
            repeat_code = (context_bits - 1)
            repeat_bits = (((1 << repeat_code)) - 1)
            alphabet_size = (num_types + repeat_code)
            histogram = FunctionMalloc.mallocInt(alphabet_size)
            depths = FunctionMalloc.mallocUInt(alphabet_size)
            bits = FunctionMalloc.mallocUInt(alphabet_size)
            encode_Write_bits.WriteBits(1,1,storage_ix,storage)
            encode_Write_bits.WriteBits(4,(repeat_code - 1),storage_ix,storage)
            histogram[repeat_code] = num_types
            histogram[0] = 1
            _g1 = context_bits
            while (_g1 < alphabet_size):
                i = _g1
                _g1 = (_g1 + 1)
                histogram[i] = 1
            encode_Brotli_bit_stream.BuildAndStoreHuffmanTree(histogram,alphabet_size,depths,0,bits,0,storage_ix,storage)
            _g11 = 0
            while (_g11 < num_types):
                i1 = _g11
                _g11 = (_g11 + 1)
                code = (0 if ((i1 == 0)) else ((i1 + context_bits) - 1))
                encode_Write_bits.WriteBits(depths[code],bits[code],storage_ix,storage)
                encode_Write_bits.WriteBits(depths[repeat_code],bits[repeat_code],storage_ix,storage)
                encode_Write_bits.WriteBits(repeat_code,repeat_bits,storage_ix,storage)
            encode_Write_bits.WriteBits(1,1,storage_ix,storage)

    @staticmethod
    def JumpToByteBoundary(storage_ix,storage):
        python_internal_ArrayImpl._set(storage_ix, 0, (((storage_ix[0] if 0 < len(storage_ix) else None) + 7) & -8))
        storage[((storage_ix[0] if 0 < len(storage_ix) else None) >> 3)] = 0

    @staticmethod
    def StoreMetaBlock(input,start_pos,length,mask,prev_byte,prev_byte2,is_last,num_direct_distance_codes,distance_postfix_bits,literal_context_mode,commands,n_commands,mb,storage_ix,storage):
        if (not encode_Brotli_bit_stream.StoreCompressedMetaBlockHeader(is_last,length,storage_ix,storage)):
            return False
        if (length == 0):
            encode_Brotli_bit_stream.JumpToByteBoundary(storage_ix,storage)
            return True
        literal_enc = encode_brotli_bit_stream_BlockEncoder(256,mb.literal_split.num_types,mb.literal_split.types,mb.literal_split.lengths)
        command_enc = encode_brotli_bit_stream_BlockEncoder(704,mb.command_split.num_types,mb.command_split.types,mb.command_split.lengths)
        distance_enc = encode_brotli_bit_stream_BlockEncoder(((16 + num_direct_distance_codes) + ((48 << distance_postfix_bits))),mb.distance_split.num_types,mb.distance_split.types,mb.distance_split.lengths)
        literal_enc.BuildAndStoreBlockSwitchEntropyCodes(storage_ix,storage)
        command_enc.BuildAndStoreBlockSwitchEntropyCodes(storage_ix,storage)
        distance_enc.BuildAndStoreBlockSwitchEntropyCodes(storage_ix,storage)
        encode_Write_bits.WriteBits(2,distance_postfix_bits,storage_ix,storage)
        encode_Write_bits.WriteBits(4,(num_direct_distance_codes >> distance_postfix_bits),storage_ix,storage)
        _g1 = 0
        _g = mb.literal_split.num_types
        while (_g1 < _g):
            _g1 = (_g1 + 1)
            encode_Write_bits.WriteBits(2,literal_context_mode,storage_ix,storage)
        if (len(mb.literal_context_map) == 0):
            encode_Brotli_bit_stream.StoreTrivialContextMap(len(mb.literal_histograms),6,storage_ix,storage)
        else:
            encode_Brotli_bit_stream.EncodeContextMap(mb.literal_context_map,len(mb.literal_histograms),storage_ix,storage)
        if (len(mb.distance_context_map) == 0):
            encode_Brotli_bit_stream.StoreTrivialContextMap(len(mb.distance_histograms),2,storage_ix,storage)
        else:
            encode_Brotli_bit_stream.EncodeContextMap(mb.distance_context_map,len(mb.distance_histograms),storage_ix,storage)
        literal_enc.BuildAndStoreEntropyCodes(mb.literal_histograms,storage_ix,storage)
        command_enc.BuildAndStoreEntropyCodes(mb.command_histograms,storage_ix,storage)
        distance_enc.BuildAndStoreEntropyCodes(mb.distance_histograms,storage_ix,storage)
        pos = start_pos
        _g11 = 0
        while (_g11 < n_commands):
            i = _g11
            _g11 = (_g11 + 1)
            cmd = (commands[i] if i >= 0 and i < len(commands) else None)
            lennumextra = HxOverrides.rshift((cmd.cmd_extra_[0] if 0 < len(cmd.cmd_extra_) else None), 16)
            lenextra = cmd.cmd_extra_
            command_enc.StoreSymbol((cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None),storage_ix,storage)
            if (lennumextra >= 32):
                encode_Write_bits.WriteBits((lennumextra - 32),(lenextra[0] if 0 < len(lenextra) else None),storage_ix,storage)
            encode_Write_bits.WriteBits((lennumextra if ((lennumextra < 32)) else 32),(lenextra[1] if 1 < len(lenextra) else None),storage_ix,storage)
            if (len(mb.literal_context_map) == 0):
                _g3 = 0
                _g2 = cmd.insert_len_
                while (_g3 < _g2):
                    _g3 = (_g3 + 1)
                    literal_enc.StoreSymbol(input[(pos & mask)],storage_ix,storage)
                    pos = (pos + 1)
            else:
                _g31 = 0
                _g21 = cmd.insert_len_
                while (_g31 < _g21):
                    _g31 = (_g31 + 1)
                    context = encode_Context.ContextFunction(prev_byte,prev_byte2,literal_context_mode)
                    literal = input[(pos & mask)]
                    literal_enc.StoreSymbolWithContext(6,literal,context,mb.literal_context_map,storage_ix,storage)
                    prev_byte2 = prev_byte
                    prev_byte = literal
                    pos = (pos + 1)
            pos = (pos + cmd.copy_len_)
            if (cmd.copy_len_ > 0):
                prev_byte2 = input[((pos - 2) & mask)]
                prev_byte = input[((pos - 1) & mask)]
                a = (cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None)
                aNeg = (a < 0)
                if (aNeg if ((aNeg != False)) else (a >= 128)):
                    dist_code = (cmd.dist_prefix_[0] if 0 < len(cmd.dist_prefix_) else None)
                    distnumextra = HxOverrides.rshift((cmd.dist_extra_[0] if 0 < len(cmd.dist_extra_) else None), 24)
                    distextra = ((cmd.dist_extra_[0] if 0 < len(cmd.dist_extra_) else None) & 16777215)
                    if (len(mb.distance_context_map) == 0):
                        distance_enc.StoreSymbol(dist_code,storage_ix,storage)
                    else:
                        distance_enc.StoreSymbolWithContext(2,dist_code,cmd.DistanceContext(),mb.distance_context_map,storage_ix,storage)
                    encode_Write_bits.WriteBits(distnumextra,distextra,storage_ix,storage)
        if is_last:
            encode_Brotli_bit_stream.JumpToByteBoundary(storage_ix,storage)
        return True

    @staticmethod
    def StoreMetaBlockTrivial(input,start_pos,length,mask,is_last,commands,n_commands,storage_ix,storage,storage_off):
        if (not encode_Brotli_bit_stream.StoreCompressedMetaBlockHeader(is_last,length,storage_ix,storage)):
            return False
        if (length == 0):
            encode_Brotli_bit_stream.JumpToByteBoundary(storage_ix,storage)
            return True
        lit_histo = encode_Histogram_functions.HistogramLiteral()
        cmd_histo = encode_Histogram_functions.HistogramCommand()
        dist_histo = encode_Histogram_functions.HistogramDistance()
        pos = start_pos
        _g1 = 0
        while (_g1 < n_commands):
            i = _g1
            _g1 = (_g1 + 1)
            cmd = (commands[i] if i >= 0 and i < len(commands) else None)
            cmd_histo.Add1((cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None))
            _g3 = 0
            _g2 = cmd.insert_len_
            while (_g3 < _g2):
                _g3 = (_g3 + 1)
                lit_histo.Add1(input[(pos & mask)])
                pos = (pos + 1)
            pos = (pos + cmd.copy_len_)
            tmp = None
            if (cmd.copy_len_ > 0):
                a = (cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None)
                aNeg = (a < 0)
                if (aNeg != False):
                    tmp = aNeg
                else:
                    tmp = (a >= 128)
            else:
                tmp = False
            if tmp:
                dist_histo.Add1((cmd.dist_prefix_[0] if 0 < len(cmd.dist_prefix_) else None))
        encode_Write_bits.WriteBits(13,0,storage_ix,storage)
        lit_depth = FunctionMalloc.mallocUInt(256)
        lit_bits = FunctionMalloc.mallocUInt(256)
        cmd_depth = FunctionMalloc.mallocUInt(704)
        cmd_bits = FunctionMalloc.mallocUInt(704)
        dist_depth = FunctionMalloc.mallocUInt(64)
        dist_bits = FunctionMalloc.mallocUInt(64)
        encode_Brotli_bit_stream.BuildAndStoreHuffmanTree(lit_histo.data_,256,lit_depth,0,lit_bits,0,storage_ix,storage)
        encode_Brotli_bit_stream.BuildAndStoreHuffmanTree(cmd_histo.data_,704,cmd_depth,0,cmd_bits,0,storage_ix,storage)
        encode_Brotli_bit_stream.BuildAndStoreHuffmanTree(dist_histo.data_,64,dist_depth,0,dist_bits,0,storage_ix,storage)
        pos = start_pos
        _g11 = 0
        while (_g11 < n_commands):
            i1 = _g11
            _g11 = (_g11 + 1)
            cmd1 = (commands[i1] if i1 >= 0 and i1 < len(commands) else None)
            cmd_code = (cmd1.cmd_prefix_[0] if 0 < len(cmd1.cmd_prefix_) else None)
            lennumextra = HxOverrides.rshift((cmd1.cmd_extra_[0] if 0 < len(cmd1.cmd_extra_) else None), 16)
            lenextra = cmd1.cmd_extra_
            encode_Write_bits.WriteBits(cmd_depth[cmd_code],cmd_bits[cmd_code],storage_ix,storage)
            if (lennumextra >= 32):
                encode_Write_bits.WriteBits((lennumextra - 32),(lenextra[0] if 0 < len(lenextra) else None),storage_ix,storage)
            encode_Write_bits.WriteBits((lennumextra if ((lennumextra < 32)) else 32),(lenextra[1] if 1 < len(lenextra) else None),storage_ix,storage)
            _g31 = 0
            _g21 = cmd1.insert_len_
            while (_g31 < _g21):
                _g31 = (_g31 + 1)
                literal = input[(pos & mask)]
                encode_Write_bits.WriteBits(lit_depth[literal],lit_bits[literal],storage_ix,storage)
                pos = (pos + 1)
            pos = (pos + cmd1.copy_len_)
            tmp1 = None
            if (cmd1.copy_len_ > 0):
                a1 = (cmd1.cmd_prefix_[0] if 0 < len(cmd1.cmd_prefix_) else None)
                aNeg1 = (a1 < 0)
                if (aNeg1 != False):
                    tmp1 = aNeg1
                else:
                    tmp1 = (a1 >= 128)
            else:
                tmp1 = False
            if tmp1:
                dist_code = (cmd1.dist_prefix_[0] if 0 < len(cmd1.dist_prefix_) else None)
                distnumextra = HxOverrides.rshift((cmd1.dist_extra_[0] if 0 < len(cmd1.dist_extra_) else None), 24)
                distextra = ((cmd1.dist_extra_[0] if 0 < len(cmd1.dist_extra_) else None) & 16777215)
                encode_Write_bits.WriteBits(dist_depth[dist_code],dist_bits[dist_code],storage_ix,storage)
                encode_Write_bits.WriteBits(distnumextra,distextra,storage_ix,storage)
        if is_last:
            encode_Brotli_bit_stream.JumpToByteBoundary(storage_ix,storage)
        return True

    @staticmethod
    def StoreUncompressedMetaBlock(final_block,input,position,mask,_hx_len,storage_ix,storage,storage_off):
        if (not encode_Brotli_bit_stream.StoreUncompressedMetaBlockHeader(_hx_len,storage_ix,storage)):
            return False
        encode_Brotli_bit_stream.JumpToByteBoundary(storage_ix,storage)
        masked_pos = (position & mask)
        if ((masked_pos + _hx_len) > ((mask + 1))):
            len1 = ((mask + 1) - masked_pos)
            DefaultFunctions.memcpy_UInt(storage,((storage_ix[0] if 0 < len(storage_ix) else None) >> 3),input,masked_pos,len1)
            _hx_local_0 = storage_ix
            _hx_local_1 = 0
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 + ((len1 << 3))))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            _hx_len = (_hx_len - len1)
            masked_pos = 0
        DefaultFunctions.memcpy_UInt(storage,((storage_ix[0] if 0 < len(storage_ix) else None) >> 3),input,masked_pos,_hx_len)
        def _hx_local_7():
            _hx_local_4 = storage_ix
            _hx_local_5 = 0
            _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
            python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 + ((_hx_len << 3))))
            return (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        encode_Write_bits.WriteBitsPrepareStorage(_hx_local_7(),storage)
        if final_block:
            encode_Write_bits.WriteBits(1,1,storage_ix,storage)
            encode_Write_bits.WriteBits(1,1,storage_ix,storage)
            encode_Brotli_bit_stream.JumpToByteBoundary(storage_ix,storage)
        return True


class encode_Cluster:
    _hx_class_name = "encode.Cluster"
    __slots__ = ()
    _hx_statics = ["HistogramPairComparator", "ClusterCostDiff", "CompareAndPushToHeap", "HistogramCombine", "HistogramBitCostDistance", "HistogramRemap", "HistogramReindex", "ClusterHistograms"]

    def __init__(self):
        pass

    @staticmethod
    def HistogramPairComparator(p1,p2):
        if (p1.cost_diff != p2.cost_diff):
            if (p1.cost_diff > p2.cost_diff):
                return 1
            else:
                return -1
        if (Reflect.field(Math,"fabs")((p1.idx1 - p1.idx2)) > Reflect.field(Math,"fabs")((p2.idx1 - p2.idx2))):
            return 1
        else:
            return -1

    @staticmethod
    def ClusterCostDiff(size_a,size_b):
        size_c = (size_a + size_b)
        return (((size_a * encode_Fast_log.FastLog2(size_a)) + ((size_b * encode_Fast_log.FastLog2(size_b)))) - ((size_c * encode_Fast_log.FastLog2(size_c))))

    @staticmethod
    def CompareAndPushToHeap(out,cluster_size,idx1,idx2,pairs):
        if (idx1 == idx2):
            return
        if (idx2 < idx1):
            t = idx2
            idx2 = idx1
            idx1 = t
        store_pair = False
        p = encode_cluster_HistogramPair()
        p.idx1 = idx1
        p.idx2 = idx2
        p.valid = True
        p.cost_diff = (0.5 * encode_Cluster.ClusterCostDiff(cluster_size[idx1],cluster_size[idx2]))
        def _hx_local_1():
            p.cost_diff = (p.cost_diff - (out[idx1] if idx1 >= 0 and idx1 < len(out) else None).bit_cost_)
            return p.cost_diff
        p.cost_diff = ((_hx_local_1()) - (out[idx2] if idx2 >= 0 and idx2 < len(out) else None).bit_cost_)
        if ((out[idx1] if idx1 >= 0 and idx1 < len(out) else None).total_count_ == 0):
            p.cost_combo = (out[idx2] if idx2 >= 0 and idx2 < len(out) else None).bit_cost_
            store_pair = True
        elif ((out[idx2] if idx2 >= 0 and idx2 < len(out) else None).total_count_ == 0):
            p.cost_combo = (out[idx1] if idx1 >= 0 and idx1 < len(out) else None).bit_cost_
            store_pair = True
        else:
            threshold = None
            if (pairs.size() == 0):
                threshold = 1e99
            else:
                b = Reflect.field((pairs.arr[0] if 0 < len(pairs.arr) else None),"cost_diff")
                if python_lib_Math.isnan(0.0):
                    threshold = 0.0
                elif python_lib_Math.isnan(b):
                    threshold = b
                else:
                    threshold = max(0.0,b)
            combo = encode_histogram_Histogram(len((out[idx1] if idx1 >= 0 and idx1 < len(out) else None).data_))
            combo.bit_cost_ = (out[idx1] if idx1 >= 0 and idx1 < len(out) else None).bit_cost_
            _g1 = 0
            _g = len((out[idx1] if idx1 >= 0 and idx1 < len(out) else None).data_)
            while (_g1 < _g):
                a = _g1
                _g1 = (_g1 + 1)
                this1 = combo.data_
                val = (out[idx1] if idx1 >= 0 and idx1 < len(out) else None).data_[a]
                this1[a] = val
            combo.kDataSize = (out[idx1] if idx1 >= 0 and idx1 < len(out) else None).kDataSize
            combo.total_count_ = (out[idx1] if idx1 >= 0 and idx1 < len(out) else None).total_count_
            combo.AddHistogram((out[idx2] if idx2 >= 0 and idx2 < len(out) else None))
            cost_combo = encode_Bit_cost.PopulationCost(combo)
            if (cost_combo < ((threshold - p.cost_diff))):
                p.cost_combo = cost_combo
                store_pair = True
        if store_pair:
            p.cost_diff = (p.cost_diff + p.cost_combo)
            pairs.push(p)

    @staticmethod
    def HistogramCombine(out,cluster_size,symbols,symbols_off,symbols_size,max_clusters):
        cost_diff_threshold = 0.0
        min_cluster_size = 1
        all_symbols = list()
        clusters = list()
        _g1 = 0
        while (_g1 < symbols_size):
            i = _g1
            _g1 = (_g1 + 1)
            if (python_internal_ArrayImpl.indexOf(all_symbols,symbols[(symbols_off + i)],None) == -1):
                if (python_internal_ArrayImpl.indexOf(all_symbols,symbols[(symbols_off + i)],None) == -1):
                    x = symbols[(symbols_off + i)]
                    all_symbols.append(x)
                x1 = symbols[(symbols_off + i)]
                clusters.append(x1)
        pairs = encode_BinaryHeap()
        _g11 = 0
        _g = len(clusters)
        while (_g11 < _g):
            idx1 = _g11
            _g11 = (_g11 + 1)
            _g3 = (idx1 + 1)
            _g2 = len(clusters)
            while (_g3 < _g2):
                idx2 = _g3
                _g3 = (_g3 + 1)
                encode_Cluster.CompareAndPushToHeap(out,cluster_size,(clusters[idx1] if idx1 >= 0 and idx1 < len(clusters) else None),(clusters[idx2] if idx2 >= 0 and idx2 < len(clusters) else None),pairs)
        while (len(clusters) > min_cluster_size):
            if (Reflect.field((pairs.arr[0] if 0 < len(pairs.arr) else None),"cost_diff") >= cost_diff_threshold):
                cost_diff_threshold = 1e99
                min_cluster_size = max_clusters
                continue
            best_idx1 = Reflect.field((pairs.arr[0] if 0 < len(pairs.arr) else None),"idx1")
            best_idx2 = Reflect.field((pairs.arr[0] if 0 < len(pairs.arr) else None),"idx2")
            (out[best_idx1] if best_idx1 >= 0 and best_idx1 < len(out) else None).AddHistogram((out[best_idx2] if best_idx2 >= 0 and best_idx2 < len(out) else None))
            (out[best_idx1] if best_idx1 >= 0 and best_idx1 < len(out) else None).bit_cost_ = Reflect.field((pairs.arr[0] if 0 < len(pairs.arr) else None),"cost_combo")
            val = (cluster_size[best_idx1] + cluster_size[best_idx2])
            cluster_size[best_idx1] = val
            _g12 = 0
            while (_g12 < symbols_size):
                i1 = _g12
                _g12 = (_g12 + 1)
                if (symbols[(symbols_off + i1)] == best_idx2):
                    symbols[(symbols_off + i1)] = best_idx1
            _g13 = 0
            _g4 = len(clusters)
            while (_g13 < _g4):
                i2 = _g13
                _g13 = (_g13 + 1)
                if ((clusters[i2] if i2 >= 0 and i2 < len(clusters) else None) >= best_idx2):
                    python_internal_ArrayImpl._set(clusters, i2, python_internal_ArrayImpl._get(clusters, (i2 + 1)))
            if (len(clusters) != 0):
                clusters.pop()
            _g14 = 0
            _g5 = pairs.size()
            while (_g14 < _g5):
                i3 = _g14
                _g14 = (_g14 + 1)
                p = (pairs.arr[i3] if i3 >= 0 and i3 < len(pairs.arr) else None)
                if ((((p.idx1 == best_idx1) or ((p.idx2 == best_idx1))) or ((p.idx1 == best_idx2))) or ((p.idx2 == best_idx2))):
                    p.valid = False
            while ((pairs.size() != 0) and (not Reflect.field((pairs.arr[0] if 0 < len(pairs.arr) else None),"valid"))):
                pairs.pop()
            _g15 = 0
            _g6 = len(clusters)
            while (_g15 < _g6):
                i4 = _g15
                _g15 = (_g15 + 1)
                encode_Cluster.CompareAndPushToHeap(out,cluster_size,best_idx1,(clusters[i4] if i4 >= 0 and i4 < len(clusters) else None),pairs)

    @staticmethod
    def HistogramBitCostDistance(histogram,candidate):
        if (histogram.total_count_ == 0):
            return 0.0
        tmp = encode_histogram_Histogram(len(histogram.data_))
        tmp.bit_cost_ = histogram.bit_cost_
        _g1 = 0
        _g = len(histogram.data_)
        while (_g1 < _g):
            a = _g1
            _g1 = (_g1 + 1)
            this1 = tmp.data_
            val = histogram.data_[a]
            this1[a] = val
        tmp.kDataSize = histogram.kDataSize
        tmp.total_count_ = histogram.total_count_
        tmp.AddHistogram(candidate)
        return (encode_Bit_cost.PopulationCost(tmp) - candidate.bit_cost_)

    @staticmethod
    def HistogramRemap(input,in_size,output,symbols):
        all_symbols = list()
        _g1 = 0
        while (_g1 < in_size):
            i = _g1
            _g1 = (_g1 + 1)
            if (python_internal_ArrayImpl.indexOf(all_symbols,symbols[i],None) == -1):
                x = symbols[i]
                all_symbols.append(x)
        _g11 = 0
        while (_g11 < in_size):
            i1 = _g11
            _g11 = (_g11 + 1)
            best_out = (symbols[0] if ((i1 == 0)) else symbols[(i1 - 1)])
            best_bits = encode_Cluster.HistogramBitCostDistance((input[i1] if i1 >= 0 and i1 < len(input) else None),(output[best_out] if best_out >= 0 and best_out < len(output) else None))
            _g3 = 0
            _g2 = len(all_symbols)
            while (_g3 < _g2):
                k = _g3
                _g3 = (_g3 + 1)
                cur_bits = encode_Cluster.HistogramBitCostDistance((input[i1] if i1 >= 0 and i1 < len(input) else None),python_internal_ArrayImpl._get(output, (all_symbols[k] if k >= 0 and k < len(all_symbols) else None)))
                if (cur_bits < best_bits):
                    best_bits = cur_bits
                    best_out = (all_symbols[k] if k >= 0 and k < len(all_symbols) else None)
            symbols[i1] = best_out
        _g12 = 0
        _g = len(all_symbols)
        while (_g12 < _g):
            k1 = _g12
            _g12 = (_g12 + 1)
            python_internal_ArrayImpl._get(output, (all_symbols[k1] if k1 >= 0 and k1 < len(all_symbols) else None)).Clear()
        _g13 = 0
        while (_g13 < in_size):
            i2 = _g13
            _g13 = (_g13 + 1)
            python_internal_ArrayImpl._get(output, symbols[i2]).AddHistogram((input[i2] if i2 >= 0 and i2 < len(input) else None))

    @staticmethod
    def HistogramReindex(out,symbols):
        tmp = list()
        _g1 = 0
        _g = len(out)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(tmp, i, encode_histogram_Histogram(len((out[i] if i >= 0 and i < len(out) else None).data_)))
            (tmp[i] if i >= 0 and i < len(tmp) else None).bit_cost_ = (out[i] if i >= 0 and i < len(out) else None).bit_cost_
            _g3 = 0
            _g2 = len((out[i] if i >= 0 and i < len(out) else None).data_)
            while (_g3 < _g2):
                a = _g3
                _g3 = (_g3 + 1)
                this1 = (tmp[i] if i >= 0 and i < len(tmp) else None).data_
                val = (out[i] if i >= 0 and i < len(out) else None).data_[a]
                this1[a] = val
            (tmp[i] if i >= 0 and i < len(tmp) else None).kDataSize = (out[i] if i >= 0 and i < len(out) else None).kDataSize
            (tmp[i] if i >= 0 and i < len(tmp) else None).total_count_ = (out[i] if i >= 0 and i < len(out) else None).total_count_
        new_index = haxe_ds_IntMap()
        next_index = 0
        _g11 = 0
        _g4 = len(symbols)
        while (_g11 < _g4):
            i1 = _g11
            _g11 = (_g11 + 1)
            if ((symbols[i1] in new_index.h) == False):
                new_index.set(symbols[i1],next_index)
                (out[next_index] if next_index >= 0 and next_index < len(out) else None).bit_cost_ = python_internal_ArrayImpl._get(tmp, symbols[i1]).bit_cost_
                _g31 = 0
                _g21 = len(python_internal_ArrayImpl._get(tmp, symbols[i1]).data_)
                while (_g31 < _g21):
                    a1 = _g31
                    _g31 = (_g31 + 1)
                    this2 = (out[next_index] if next_index >= 0 and next_index < len(out) else None).data_
                    val1 = python_internal_ArrayImpl._get(tmp, symbols[i1]).data_[a1]
                    this2[a1] = val1
                (out[next_index] if next_index >= 0 and next_index < len(out) else None).kDataSize = python_internal_ArrayImpl._get(tmp, symbols[i1]).kDataSize
                (out[next_index] if next_index >= 0 and next_index < len(out) else None).total_count_ = python_internal_ArrayImpl._get(tmp, symbols[i1]).total_count_
                next_index = (next_index + 1)
        while (len(out) > next_index):
            if (len(out) != 0):
                out.pop()
        _g12 = 0
        _g5 = len(symbols)
        while (_g12 < _g5):
            i2 = _g12
            _g12 = (_g12 + 1)
            key = symbols[i2]
            val2 = new_index.h.get(key,None)
            symbols[i2] = val2

    @staticmethod
    def ClusterHistograms(input,num_contexts,num_blocks,max_histograms,output,outputInt,histogram_symbols):
        in_size = (num_contexts * num_blocks)
        cluster_size = [None]*in_size
        DefaultFunctions.memset_Int(cluster_size,0,1,in_size)
        while (len(output) > in_size):
            if (len(output) != 0):
                output.pop()
        _g1 = 0
        while (_g1 < in_size):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(output, i, encode_histogram_Histogram(outputInt))
        _g11 = 0
        while (_g11 < in_size):
            i1 = _g11
            _g11 = (_g11 + 1)
            _g3 = 0
            _g2 = len((input[i1] if i1 >= 0 and i1 < len(input) else None).data_)
            while (_g3 < _g2):
                a = _g3
                _g3 = (_g3 + 1)
                this1 = (output[i1] if i1 >= 0 and i1 < len(output) else None).data_
                val = (input[i1] if i1 >= 0 and i1 < len(input) else None).data_[a]
                this1[a] = val
            (output[i1] if i1 >= 0 and i1 < len(output) else None).kDataSize = (input[i1] if i1 >= 0 and i1 < len(input) else None).kDataSize
            (output[i1] if i1 >= 0 and i1 < len(output) else None).total_count_ = (input[i1] if i1 >= 0 and i1 < len(input) else None).total_count_
            (output[i1] if i1 >= 0 and i1 < len(output) else None).bit_cost_ = encode_Bit_cost.PopulationCost((input[i1] if i1 >= 0 and i1 < len(input) else None))
            histogram_symbols[i1] = i1
        i2 = 0
        while (i2 < in_size):
            a1 = (in_size - i2)
            x = (a1 if (python_lib_Math.isnan(a1)) else (64 if (python_lib_Math.isnan(64)) else min(a1,64)))
            num_to_combine = None
            try:
                num_to_combine = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                num_to_combine = None
            encode_Cluster.HistogramCombine(output,cluster_size,histogram_symbols,i2,num_to_combine,max_histograms)
            i2 = (i2 + 64)
        encode_Cluster.HistogramCombine(output,cluster_size,histogram_symbols,0,in_size,max_histograms)
        encode_Cluster.HistogramRemap(input,in_size,output,histogram_symbols)
        encode_Cluster.HistogramReindex(output,histogram_symbols)


class encode_Command_functions:
    _hx_class_name = "encode.Command_functions"
    __slots__ = ()
    _hx_statics = ["GetDistCode", "insbase", "insextra", "copybase", "copyextra", "GetInsertLengthCode", "GetCopyLengthCode", "CombineLengthCodes", "GetLengthCode"]

    def __init__(self):
        pass

    @staticmethod
    def GetDistCode(distance_code,code,extra):
        if (distance_code < 16):
            python_internal_ArrayImpl._set(code, 0, distance_code)
            python_internal_ArrayImpl._set(extra, 0, 0)
        else:
            distance_code = (distance_code - 12)
            numextra = (encode_Fast_log.Log2FloorNonZero(distance_code) - 1)
            prefix = (distance_code >> numextra)
            python_internal_ArrayImpl._set(code, 0, ((12 + ((2 * numextra))) + prefix))
            python_internal_ArrayImpl._set(extra, 0, ((numextra << 24) | ((distance_code - ((prefix << numextra))))))

    @staticmethod
    def GetInsertLengthCode(insertlen):
        if (insertlen < 6):
            return insertlen
        elif (insertlen < 130):
            insertlen = (insertlen - 2)
            nbits = (encode_Fast_log.Log2FloorNonZero(insertlen) - 1)
            return ((((nbits << 1)) + ((insertlen >> nbits))) + 2)
        elif (insertlen < 2114):
            return (encode_Fast_log.Log2FloorNonZero((insertlen - 66)) + 10)
        elif (insertlen < 6210):
            return 21
        elif (insertlen < 22594):
            return 22
        else:
            return 23

    @staticmethod
    def GetCopyLengthCode(copylen):
        if (copylen < 10):
            return (copylen - 2)
        elif (copylen < 134):
            copylen = (copylen - 6)
            nbits = (encode_Fast_log.Log2FloorNonZero(copylen) - 1)
            return ((((nbits << 1)) + ((copylen >> nbits))) + 4)
        elif (copylen < 2118):
            return (encode_Fast_log.Log2FloorNonZero((copylen - 70)) + 12)
        else:
            return 23

    @staticmethod
    def CombineLengthCodes(inscode,copycode,distancecode):
        bits64 = ((copycode & 7) | ((((inscode & 7)) << 3)))
        if (((distancecode == 0) and ((inscode < 8))) and ((copycode < 16))):
            if (copycode < 8):
                return bits64
            else:
                return (bits64 | 64)
        else:
            return ((python_internal_ArrayImpl._get([2, 3, 6, 4, 5, 8, 7, 9, 10], (((copycode >> 3)) + ((3 * ((inscode >> 3)))))) << 6) | bits64)

    @staticmethod
    def GetLengthCode(insertlen,copylen,distancecode,code,extra):
        inscode = encode_Command_functions.GetInsertLengthCode(insertlen)
        copycode = encode_Command_functions.GetCopyLengthCode(copylen)
        insnumextra = python_internal_ArrayImpl._get(encode_Command_functions.insextra, inscode)
        numextra = (insnumextra + python_internal_ArrayImpl._get(encode_Command_functions.copyextra, copycode))
        insextraval = (insertlen - python_internal_ArrayImpl._get(encode_Command_functions.insbase, inscode))
        copyextraval = (copylen - python_internal_ArrayImpl._get(encode_Command_functions.copybase, copycode))
        python_internal_ArrayImpl._set(code, 0, encode_Command_functions.CombineLengthCodes(inscode,copycode,distancecode))
        if (False if ((False != ((numextra < 0)))) else (32 > numextra)):
            python_internal_ArrayImpl._set(extra, 0, ((numextra << 16) | 0))
            python_internal_ArrayImpl._set(extra, 1, ((copyextraval << insnumextra) | insextraval))
        else:
            value = haxe__Int64____Int64(0,0)
            b = None
            b = haxe__Int64____Int64(((((haxe__Int64____Int64((numextra >> 31),numextra).low << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
            high = (((value.high + b.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((value.low + b.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (haxe__Int32_Int32_Impl_.ucompare(low,value.low) < 0):
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            value = haxe__Int64____Int64(high,low)
            a = haxe__Int64____Int64((copyextraval >> 31),copyextraval)
            b1 = insnumextra
            b1 = (b1 & 63)
            b2 = (haxe__Int64____Int64(a.high,a.low) if ((b1 == 0)) else (haxe__Int64____Int64((((((a.high << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(a.low, ((32 - b1)))),((((a.low << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))) if ((b1 < 32)) else haxe__Int64____Int64(((((a.low << (b1 - 32))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)))
            high1 = (((value.high + b2.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low1 = (((value.low + b2.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (haxe__Int32_Int32_Impl_.ucompare(low1,value.low) < 0):
                high1 = (high1 + 1)
                high1 = ((high1 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            value = haxe__Int64____Int64(high1,low1)
            b3 = haxe__Int64____Int64((insextraval >> 31),insextraval)
            high2 = (((value.high + b3.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low2 = (((value.low + b3.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (haxe__Int32_Int32_Impl_.ucompare(low2,value.low) < 0):
                high2 = (high2 + 1)
                high2 = ((high2 + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            value = haxe__Int64____Int64(high2,low2)
            x = value.high
            x1 = haxe__Int64____Int64((x >> 31),x)
            if (x1.high != (x1.low >> 31)):
                raise _HxException("Overflow")
            python_internal_ArrayImpl._set(extra, 0, x1.low)
            x2 = value.low
            x3 = haxe__Int64____Int64((x2 >> 31),x2)
            if (x3.high != (x3.low >> 31)):
                raise _HxException("Overflow")
            python_internal_ArrayImpl._set(extra, 1, x3.low)


class encode_Context:
    _hx_class_name = "encode.Context"
    __slots__ = ()
    _hx_statics = ["kUTF8ContextLookup", "kSigned3BitContextLookup", "CONTEXT_LSB6", "CONTEXT_MSB6", "CONTEXT_UTF8", "CONTEXT_SIGNED", "ContextFunction"]

    def __init__(self):
        pass

    @staticmethod
    def ContextFunction(p1,p2,mode):
        if (mode == 0):
            return (p1 & 63)
        elif (mode == 1):
            return HxOverrides.rshift(p1, 2)
        elif (mode == 2):
            return (python_internal_ArrayImpl._get(encode_Context.kUTF8ContextLookup, p1) | python_internal_ArrayImpl._get(encode_Context.kUTF8ContextLookup, (p2 + 256)))
        elif (mode == 3):
            return (((python_internal_ArrayImpl._get(encode_Context.kSigned3BitContextLookup, p1) << 3)) + python_internal_ArrayImpl._get(encode_Context.kSigned3BitContextLookup, p2))
        else:
            return 0


class encode_Dictionary:
    _hx_class_name = "encode.Dictionary"
    __slots__ = ()
    _hx_statics = ["kBrotliDictionary", "kBrotliDictionaryOffsetsByLength", "kBrotliDictionarySizeBitsByLength", "kMinDictionaryWordLength", "kMaxDictionaryWordLength"]

    def __init__(self):
        pass
    kBrotliDictionary = None


class encode_Dictionary_hash:
    _hx_class_name = "encode.Dictionary_hash"
    __slots__ = ()
    _hx_statics = ["kStaticDictionaryHash"]

    def __init__(self):
        pass


class encode_Encode:
    _hx_class_name = "encode.Encode"
    __slots__ = ()
    _hx_statics = ["kMaxWindowBits", "kMinWindowBits", "kMinInputBlockBits", "kMaxInputBlockBits", "kMinUTF8Ratio", "kMinQualityForBlockSplit", "kMinQualityForContextModeling", "kMinQualityForOptimizeHistograms", "ParseAsUTF8", "IsMostlyUTF8", "RecomputeDistancePrefixes", "DecideOverLiteralContextModeling", "CopyOneBlockToRingBuffer", "BrotliInIsFinished", "BrotliCompress", "BrotliCompressWithCustomDictionary"]

    def __init__(self):
        pass

    @staticmethod
    def ParseAsUTF8(symbol,input,input_off,size):
        if (((input[input_off] & 128)) == 0):
            python_internal_ArrayImpl._set(symbol, 0, input[input_off])
            if ((symbol[0] if 0 < len(symbol) else None) > 0):
                return 1
        if (((size > 1) and ((((input[input_off] & 224)) == 192))) and ((((input[(input_off + 1)] & 192)) == 128))):
            python_internal_ArrayImpl._set(symbol, 0, ((((input[input_off] & 31)) << 6) | (input[(input_off + 1)] & 63)))
            if ((symbol[0] if 0 < len(symbol) else None) > 127):
                return 2
        if ((((size > 2) and ((((input[input_off] & 240)) == 224))) and ((((input[(input_off + 1)] & 192)) == 128))) and ((((input[(input_off + 2)] & 192)) == 128))):
            python_internal_ArrayImpl._set(symbol, 0, (((((input[input_off] & 15)) << 12) | (((input[(input_off + 1)] & 63)) << 6)) | (input[(input_off + 2)] & 63)))
            if ((symbol[0] if 0 < len(symbol) else None) > 2047):
                return 3
        if (((((size > 3) and ((((input[input_off] & 248)) == 240))) and ((((input[(input_off + 1)] & 192)) == 128))) and ((((input[(input_off + 2)] & 192)) == 128))) and ((((input[(input_off + 3)] & 192)) == 128))):
            python_internal_ArrayImpl._set(symbol, 0, ((((((input[input_off] & 7)) << 18) | (((input[(input_off + 1)] & 63)) << 12)) | (((input[(input_off + 2)] & 63)) << 6)) | (input[(input_off + 3)] & 63)))
            if (((symbol[0] if 0 < len(symbol) else None) > 65535) and (((symbol[0] if 0 < len(symbol) else None) <= 1114111))):
                return 4
        python_internal_ArrayImpl._set(symbol, 0, (1114112 | input[input_off]))
        return 1

    @staticmethod
    def IsMostlyUTF8(data,data_off,length,min_fraction):
        size_utf8 = 0
        pos = 0
        while (pos < length):
            symbol = list()
            bytes_read = encode_Encode.ParseAsUTF8(symbol,data,(data_off + pos),(length - pos))
            pos = (pos + bytes_read)
            if ((symbol[0] if 0 < len(symbol) else None) < 1114112):
                size_utf8 = (size_utf8 + bytes_read)
        return (size_utf8 > ((min_fraction * length)))

    @staticmethod
    def RecomputeDistancePrefixes(cmds,num_commands,num_direct_distance_codes,distance_postfix_bits):
        if ((num_direct_distance_codes == 0) and ((distance_postfix_bits == 0))):
            return
        _g1 = 0
        while (_g1 < num_commands):
            i = _g1
            _g1 = (_g1 + 1)
            cmd = (cmds[i] if i >= 0 and i < len(cmds) else None)
            tmp = None
            if (cmd.copy_len_ > 0):
                a = (cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None)
                aNeg = (a < 0)
                if (aNeg != False):
                    tmp = aNeg
                else:
                    tmp = (a >= 128)
            else:
                tmp = False
            if tmp:
                encode_Prefix.PrefixEncodeCopyDistance(cmd.DistanceCode(),num_direct_distance_codes,distance_postfix_bits,cmd.dist_prefix_,cmd.dist_extra_)

    @staticmethod
    def DecideOverLiteralContextModeling(input,start_pos,length,mask,quality,literal_context_mode,num_literal_contexts,literal_context_map):
        if ((quality < encode_Encode.kMinQualityForContextModeling) or ((length < 64))):
            return
        end_pos = (start_pos + length)
        while ((start_pos + 64) < end_pos):
            stride_end_pos = (start_pos + 64)
            prev = input[(start_pos & mask)]
            _g1 = (start_pos + 1)
            while (_g1 < stride_end_pos):
                pos = _g1
                _g1 = (_g1 + 1)
                literal = input[(pos & mask)]
                tmp = None
                if (not ((((False if ((False != ((prev < 0)))) else (128 > prev))) and ((((literal & 192)) == 128))))):
                    aNeg = (prev < 0)
                    if (aNeg if ((aNeg != False)) else (prev >= 192)):
                        tmp = (((literal & 192)) != 128)
                    else:
                        tmp = False
                else:
                    tmp = True
                if tmp:
                    return
                prev = literal
            start_pos = (start_pos + 4096)
        python_internal_ArrayImpl._set(literal_context_mode, 0, 2)
        python_internal_ArrayImpl._set(num_literal_contexts, 0, 2)
        python_internal_ArrayImpl._set(literal_context_map, 0, [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

    @staticmethod
    def CopyOneBlockToRingBuffer(r,compressor):
        block_size = compressor.input_block_size()
        bytes_read = [0]
        data = Reflect.field(r,"Read")(block_size,bytes_read)
        if (data is None):
            return 0
        compressor.CopyInputToRingBuffer((bytes_read[0] if 0 < len(bytes_read) else None),data)
        remaining = (block_size - (bytes_read[0] if 0 < len(bytes_read) else None))
        while (remaining > 0):
            more_bytes_read = [0]
            data = Reflect.field(r,"Read")(remaining,more_bytes_read)
            if (data is None):
                break
            compressor.CopyInputToRingBuffer((more_bytes_read[0] if 0 < len(more_bytes_read) else None),data)
            python_internal_ArrayImpl._set(bytes_read, 0, ((bytes_read[0] if 0 < len(bytes_read) else None) + (more_bytes_read[0] if 0 < len(more_bytes_read) else None)))
            remaining = (remaining - (more_bytes_read[0] if 0 < len(more_bytes_read) else None))
        return (bytes_read[0] if 0 < len(bytes_read) else None)

    @staticmethod
    def BrotliInIsFinished(r):
        read_bytes = list()
        return (Reflect.field(r,"Read")(0,read_bytes) is None)

    @staticmethod
    def BrotliCompress(params,input,output):
        return encode_Encode.BrotliCompressWithCustomDictionary(0,None,params,input,output)

    @staticmethod
    def BrotliCompressWithCustomDictionary(dictsize,_hx_dict,params,input,output):
        in_bytes = 0
        out_bytes = [0]
        out = list()
        final_block = False
        compressor = encode_encode_BrotliCompressor(params)
        if (dictsize != 0):
            compressor.BrotliSetCustomDictionary(dictsize,_hx_dict)
        while (not final_block):
            in_bytes = encode_Encode.CopyOneBlockToRingBuffer(input,compressor)
            if (in_bytes != 0):
                final_block = encode_Encode.BrotliInIsFinished(input)
            else:
                final_block = True
            python_internal_ArrayImpl._set(out_bytes, 0, 0)
            if (not compressor.WriteBrotliData(final_block,False,out_bytes,out)):
                return False
            if (((out_bytes[0] if 0 < len(out_bytes) else None) > 0) and (not Reflect.field(output,"Write")((out[0] if 0 < len(out) else None),(out_bytes[0] if 0 < len(out_bytes) else None)))):
                return False
        return True


class encode_Entropy_encode:
    _hx_class_name = "encode.Entropy_encode"
    __slots__ = ()
    _hx_statics = ["kCodeLengthCodes", "EntropyCodeLiteral", "EntropyCodeCommand", "EntropyCodeDistance", "EntropyCodeBlockLength", "EntropyCodeContextMap", "EntropyCodeBlockType", "SortHuffmanTree", "SetDepth", "CreateHuffmanTree", "Reverse", "WriteHuffmanTreeRepetitions", "WriteHuffmanTreeRepetitionsZeros", "OptimizeHuffmanCountsForRle", "DecideOverRleUse", "WriteHuffmanTree", "ReverseBits", "ConvertBitDepthsToSymbols"]

    def __init__(self):
        pass

    @staticmethod
    def EntropyCodeLiteral():
        return encode_entropy_encode_EntropyCode(256)

    @staticmethod
    def EntropyCodeCommand():
        return encode_entropy_encode_EntropyCode(704)

    @staticmethod
    def EntropyCodeDistance():
        return encode_entropy_encode_EntropyCode(520)

    @staticmethod
    def EntropyCodeBlockLength():
        return encode_entropy_encode_EntropyCode(26)

    @staticmethod
    def EntropyCodeContextMap():
        return encode_entropy_encode_EntropyCode(272)

    @staticmethod
    def EntropyCodeBlockType():
        return encode_entropy_encode_EntropyCode(258)

    @staticmethod
    def SortHuffmanTree(v0,v1):
        if (v0.total_count_ == v1.total_count_):
            return (v1.index_right_or_value_ - v0.index_right_or_value_)
        if (v0.total_count_ < v1.total_count_):
            return -1
        return 1

    @staticmethod
    def SetDepth(p,pool,pool_off,depth,depth_off,level):
        if (p.index_left_ >= 0):
            level = (level + 1)
            encode_Entropy_encode.SetDepth(python_internal_ArrayImpl._get(pool, (pool_off + p.index_left_)),pool,pool_off,depth,depth_off,level)
            encode_Entropy_encode.SetDepth(python_internal_ArrayImpl._get(pool, (pool_off + p.index_right_or_value_)),pool,pool_off,depth,depth_off,level)
        else:
            depth[(depth_off + p.index_right_or_value_)] = level

    @staticmethod
    def CreateHuffmanTree(data,data_off,length,tree_limit,depth,depth_off):
        count_limit = 1
        while True:
            tree = list()
            tree_off = 0
            i = (length - 1)
            while (i >= 0):
                if (data[i] > 0):
                    a = data[i]
                    x = (a if (python_lib_Math.isnan(a)) else (count_limit if (python_lib_Math.isnan(count_limit)) else max(a,count_limit)))
                    count = None
                    try:
                        count = int(x)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        count = None
                    huffmantree = encode_entropy_encode_HuffmanTree()
                    huffmantree.HuffmanTree3(count,-1,i)
                    tmp = tree_off
                    tree_off = (tree_off + 1)
                    python_internal_ArrayImpl._set(tree, tmp, huffmantree)
                i = (i - 1)
            n = len(tree)
            if (n == 1):
                depth[(depth_off + (tree[0] if 0 < len(tree) else None).index_right_or_value_)] = 1
                break
            tree.sort(key= python_lib_Functools.cmp_to_key(encode_Entropy_encode.SortHuffmanTree))
            huffmantree1 = encode_entropy_encode_HuffmanTree()
            huffmantree1.HuffmanTree3(2147483647,-1,-1)
            tmp1 = tree_off
            tree_off = (tree_off + 1)
            python_internal_ArrayImpl._set(tree, tmp1, huffmantree1)
            huffmantree2 = encode_entropy_encode_HuffmanTree()
            huffmantree2.HuffmanTree3(2147483647,-1,-1)
            tmp2 = tree_off
            tree_off = (tree_off + 1)
            python_internal_ArrayImpl._set(tree, tmp2, huffmantree2)
            i1 = 0
            j = (n + 1)
            k = (n - 1)
            while (k > 0):
                left = None
                right = None
                if ((tree[i1] if i1 >= 0 and i1 < len(tree) else None).total_count_ <= (tree[j] if j >= 0 and j < len(tree) else None).total_count_):
                    left = i1
                    i1 = (i1 + 1)
                else:
                    left = j
                    j = (j + 1)
                if ((tree[i1] if i1 >= 0 and i1 < len(tree) else None).total_count_ <= (tree[j] if j >= 0 and j < len(tree) else None).total_count_):
                    right = i1
                    i1 = (i1 + 1)
                else:
                    right = j
                    j = (j + 1)
                j_end = (len(tree) - 1)
                (tree[j_end] if j_end >= 0 and j_end < len(tree) else None).total_count_ = ((tree[left] if left >= 0 and left < len(tree) else None).total_count_ + (tree[right] if right >= 0 and right < len(tree) else None).total_count_)
                (tree[j_end] if j_end >= 0 and j_end < len(tree) else None).index_left_ = left
                (tree[j_end] if j_end >= 0 and j_end < len(tree) else None).index_right_or_value_ = right
                huffmantree3 = encode_entropy_encode_HuffmanTree()
                huffmantree3.HuffmanTree3(2147483647,-1,-1)
                tmp3 = tree_off
                tree_off = (tree_off + 1)
                python_internal_ArrayImpl._set(tree, tmp3, huffmantree3)
                k = (k - 1)
            encode_Entropy_encode.SetDepth(python_internal_ArrayImpl._get(tree, ((2 * n) - 1)),tree,0,depth,depth_off,0)
            max_element = 0
            _g1 = depth_off
            _g = (depth_off + length)
            while (_g1 < _g):
                i2 = _g1
                _g1 = (_g1 + 1)
                a1 = depth[i2]
                aNeg = (a1 < 0)
                if (aNeg if ((aNeg != ((max_element < 0)))) else (a1 > max_element)):
                    max_element = depth[i2]
            if (max_element <= tree_limit):
                break
            count_limit = (count_limit * 2)

    @staticmethod
    def Reverse(v,start,end):
        end = (end - 1)
        while (start < end):
            tmp = (v[start] if start >= 0 and start < len(v) else None)
            python_internal_ArrayImpl._set(v, start, (v[end] if end >= 0 and end < len(v) else None))
            python_internal_ArrayImpl._set(v, end, tmp)
            start = (start + 1)
            end = (end - 1)

    @staticmethod
    def WriteHuffmanTreeRepetitions(previous_value,value,repetitions,tree,extra_bits_data):
        if (previous_value != value):
            tree.append(value)
            extra_bits_data.append(0)
            repetitions = (repetitions - 1)
        if (repetitions == 7):
            tree.append(value)
            extra_bits_data.append(0)
            repetitions = (repetitions - 1)
        if (repetitions < 3):
            _g1 = 0
            _g = repetitions
            while (_g1 < _g):
                _g1 = (_g1 + 1)
                tree.append(value)
                extra_bits_data.append(0)
        else:
            repetitions = (repetitions - 3)
            start = len(tree)
            while (repetitions >= 0):
                tree.append(16)
                extra_bits_data.append((repetitions & 3))
                repetitions = (repetitions >> 2)
                repetitions = (repetitions - 1)
            encode_Entropy_encode.Reverse(tree,start,len(tree))
            encode_Entropy_encode.Reverse(extra_bits_data,start,len(tree))

    @staticmethod
    def WriteHuffmanTreeRepetitionsZeros(repetitions,tree,extra_bits_data):
        if (repetitions == 11):
            tree.append(0)
            extra_bits_data.append(0)
            repetitions = (repetitions - 1)
        if (repetitions < 3):
            _g1 = 0
            _g = repetitions
            while (_g1 < _g):
                _g1 = (_g1 + 1)
                tree.append(0)
                extra_bits_data.append(0)
        else:
            repetitions = (repetitions - 3)
            start = len(tree)
            while (repetitions >= 0):
                tree.append(17)
                extra_bits_data.append((repetitions & 7))
                repetitions = (repetitions >> 3)
                repetitions = (repetitions - 1)
            encode_Entropy_encode.Reverse(tree,start,len(tree))
            encode_Entropy_encode.Reverse(extra_bits_data,start,len(tree))

    @staticmethod
    def OptimizeHuffmanCountsForRle(length,counts):
        nonzero_count = 0
        stride = None
        limit = None
        sum = None
        good_for_rle = None
        _g1 = 0
        _g = length
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (counts[i] > 0):
                nonzero_count = (nonzero_count + 1)
        if (nonzero_count < 16):
            return 1
        while (length >= 0):
            if (length == 0):
                return 1
            if (counts[(length - 1)] != 0):
                break
            length = (length - 1)
        nonzeros = 0
        smallest_nonzero = 1073741824
        _g11 = 0
        _g2 = length
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            if (counts[i1] != 0):
                nonzeros = (nonzeros + 1)
                if (smallest_nonzero > counts[i1]):
                    smallest_nonzero = counts[i1]
        if (nonzeros < 5):
            return 1
        if (smallest_nonzero < 4):
            if ((length - nonzeros) < 6):
                _g12 = 1
                _g3 = (length - 1)
                while (_g12 < _g3):
                    i2 = _g12
                    _g12 = (_g12 + 1)
                    if (((counts[(i2 - 1)] != 0) and ((counts[i2] == 0))) and ((counts[(i2 + 1)] != 0))):
                        counts[i2] = 1
        if (nonzeros < 28):
            return 1
        good_for_rle = FunctionMalloc.mallocUInt(length)
        if (good_for_rle is None):
            return 0
        symbol = counts[0]
        stride1 = 0
        _g13 = 0
        _g4 = (length + 1)
        while (_g13 < _g4):
            i3 = _g13
            _g13 = (_g13 + 1)
            if ((i3 == length) or ((counts[i3] != symbol))):
                if (((symbol == 0) and ((stride1 >= 5))) or (((symbol != 0) and ((stride1 >= 7))))):
                    _g31 = 0
                    _g21 = stride1
                    while (_g31 < _g21):
                        k = _g31
                        _g31 = (_g31 + 1)
                        good_for_rle[((i3 - k) - 1)] = 1
                stride1 = 1
                if (i3 != length):
                    symbol = counts[i3]
            else:
                stride1 = (stride1 + 1)
        stride = 0
        x = ((256 * (((counts[0] + counts[1]) + counts[2]))) / 3)
        limit1 = None
        try:
            limit1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            limit1 = None
        limit = (limit1 + 420)
        sum = 0
        _g14 = 0
        _g5 = (length + 1)
        while (_g14 < _g5):
            i4 = _g14
            _g14 = (_g14 + 1)
            tmp = None
            tmp1 = None
            tmp2 = None
            if (i4 != length):
                a = good_for_rle[i4]
                aNeg = (a < 0)
                if (aNeg != False):
                    tmp2 = aNeg
                else:
                    tmp2 = (a > 0)
            else:
                tmp2 = True
            if (not tmp2):
                if (i4 != 0):
                    a1 = good_for_rle[(i4 - 1)]
                    aNeg1 = (a1 < 0)
                    if (aNeg1 != False):
                        tmp1 = aNeg1
                    else:
                        tmp1 = (a1 > 0)
                else:
                    tmp1 = False
            else:
                tmp1 = True
            if (not tmp1):
                v = ((256 * counts[i4]) - limit)
                tmp = (Reflect.field(Math,"fabs")(v) >= 1240)
            else:
                tmp = True
            if tmp:
                if ((stride >= 4) or (((stride >= 3) and ((sum == 0))))):
                    x1 = None
                    try:
                        x1 = int((stride / 2))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        x1 = None
                    x2 = (((sum + x1)) / stride)
                    count = None
                    try:
                        count = int(x2)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e2 = _hx_e1
                        count = None
                    if (count < 1):
                        count = 1
                    if (sum == 0):
                        count = 0
                    _g32 = 0
                    _g22 = stride
                    while (_g32 < _g22):
                        k1 = _g32
                        _g32 = (_g32 + 1)
                        counts[((i4 - k1) - 1)] = count
                stride = 0
                sum = 0
                if (i4 < ((length - 2))):
                    x3 = ((256 * (((counts[i4] + counts[(i4 + 1)]) + counts[(i4 + 2)]))) / 3)
                    limit2 = None
                    try:
                        limit2 = int(x3)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e3 = _hx_e1
                        limit2 = None
                    limit = (limit2 + 420)
                elif (i4 < length):
                    limit = (256 * counts[i4])
                else:
                    limit = 0
            stride = (stride + 1)
            if (i4 != length):
                sum = (sum + counts[i4])
                if (stride >= 4):
                    x4 = (256 * sum)
                    x5 = None
                    try:
                        x5 = int((stride / 2))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e4 = _hx_e1
                        x5 = None
                    x6 = (((x4 + x5)) / stride)
                    try:
                        limit = int(x6)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e5 = _hx_e1
                        limit = None
                if (stride == 4):
                    limit = (limit + 120)
        return 1

    @staticmethod
    def DecideOverRleUse(depth,depth_off,length,use_rle_for_non_zero,use_rle_for_zero):
        total_reps_zero = 0
        total_reps_non_zero = 0
        count_reps_zero = 0
        count_reps_non_zero = 0
        i = 0
        while (i < length):
            value = depth[(depth_off + i)]
            reps = 1
            k = (i + 1)
            while ((k < length) and ((depth[(depth_off + k)] == value))):
                reps = (reps + 1)
                k = (k + 1)
            if ((reps >= 3) and ((value == 0))):
                total_reps_zero = (total_reps_zero + reps)
                count_reps_zero = (count_reps_zero + 1)
            if ((reps >= 4) and ((value != 0))):
                total_reps_non_zero = (total_reps_non_zero + reps)
                count_reps_non_zero = (count_reps_non_zero + 1)
            i = (i + reps)
        total_reps_non_zero = (total_reps_non_zero - ((count_reps_non_zero * 2)))
        total_reps_zero = (total_reps_zero - ((count_reps_zero * 2)))
        python_internal_ArrayImpl._set(use_rle_for_non_zero, 0, (total_reps_non_zero > 2))
        python_internal_ArrayImpl._set(use_rle_for_zero, 0, (total_reps_zero > 2))

    @staticmethod
    def WriteHuffmanTree(depth,depth_off,length,tree,extra_bits_data):
        previous_value = 8
        new_length = length
        _g1 = 0
        _g = length
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (depth[(((depth_off + length) - i) - 1)] == 0):
                new_length = (new_length - 1)
            else:
                break
        use_rle_for_non_zero = [False]
        use_rle_for_zero = [False]
        aNeg = (length < 0)
        if (aNeg if ((aNeg != False)) else (length > 50)):
            encode_Entropy_encode.DecideOverRleUse(depth,depth_off,new_length,use_rle_for_non_zero,use_rle_for_zero)
        i1 = 0
        while (i1 < new_length):
            value = depth[(depth_off + i1)]
            reps = 1
            if (((value != 0) and (use_rle_for_non_zero[0] if 0 < len(use_rle_for_non_zero) else None)) or (((value == 0) and (use_rle_for_zero[0] if 0 < len(use_rle_for_zero) else None)))):
                k = (i1 + 1)
                while ((k < new_length) and ((depth[(depth_off + k)] == value))):
                    reps = (reps + 1)
                    k = (k + 1)
            if (value == 0):
                encode_Entropy_encode.WriteHuffmanTreeRepetitionsZeros(reps,tree,extra_bits_data)
            else:
                encode_Entropy_encode.WriteHuffmanTreeRepetitions(previous_value,value,reps,tree,extra_bits_data)
                previous_value = value
            i1 = (i1 + reps)

    @staticmethod
    def ReverseBits(num_bits,bits):
        kLut = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]
        retval = python_internal_ArrayImpl._get(kLut, (bits & 15))
        i = 4
        while (i < num_bits):
            retval = (retval << 4)
            bits = HxOverrides.rshift(bits, 4)
            retval = (retval | python_internal_ArrayImpl._get(kLut, (bits & 15)))
            i = (i + 4)
        retval = (retval >> ((-num_bits & 3)))
        return retval

    @staticmethod
    def ConvertBitDepthsToSymbols(depth,depth_off,_hx_len,bits,bits_off):
        bl_count = FunctionMalloc.mallocUInt(16)
        _g1 = 0
        while (_g1 < _hx_len):
            i = _g1
            _g1 = (_g1 + 1)
            _g2 = depth[(depth_off + i)]
            val = (bl_count[_g2] + 1)
            bl_count[_g2] = val
        bl_count[0] = 0
        next_code = [None]*16
        next_code[0] = 0
        code = 0
        _g11 = 1
        while (_g11 < 16):
            _bits = _g11
            _g11 = (_g11 + 1)
            code = ((code + bl_count[(_bits - 1)]) << 1)
            next_code[_bits] = code
        _g12 = 0
        while (_g12 < _hx_len):
            i1 = _g12
            _g12 = (_g12 + 1)
            a = depth[(depth_off + i1)]
            aNeg = (a < 0)
            if (aNeg if ((aNeg != False)) else (a > 0)):
                val1 = encode_Entropy_encode.ReverseBits(depth[(depth_off + i1)],next_code[depth[(depth_off + i1)]])
                bits[(bits_off + i1)] = val1
                _g21 = depth[(depth_off + i1)]
                val2 = (next_code[_g21] + 1)
                next_code[_g21] = val2


class encode_Fast_log:
    _hx_class_name = "encode.Fast_log"
    __slots__ = ()
    _hx_statics = ["Log2Floor", "Log2FloorNonZero", "kLog2Table", "FastLog2"]

    def __init__(self):
        pass

    @staticmethod
    def Log2Floor(n):
        if (n == 0):
            return -1
        log = 0
        value = n
        i = 4
        while (i >= 0):
            shift = (1 << i)
            x = HxOverrides.rshift(value, shift)
            if (x != 0):
                value = x
                log = (log + shift)
            i = (i - 1)
        return log

    @staticmethod
    def Log2FloorNonZero(n):
        result = 0
        while True:
            n = HxOverrides.rshift(n, 1)
            a = n
            aNeg = (a < 0)
            if (not ((aNeg if ((aNeg != False)) else (a > 0)))):
                break
            result = (result + 1)
        return result

    @staticmethod
    def FastLog2(v):
        if (v < 256):
            return python_internal_ArrayImpl._get(encode_Fast_log.kLog2Table, v)
        return (((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) * 1.4426950408889634)


class encode_Find_match_length:
    _hx_class_name = "encode.Find_match_length"
    __slots__ = ()
    _hx_statics = ["FindMatchLengthWithLimit"]

    def __init__(self):
        pass

    @staticmethod
    def FindMatchLengthWithLimit(s1,s1_off,s2,s2_off,limit):
        matched = 0
        s2_limit_off = (s2_off + limit)
        s2_ptr_off = s2_off
        while True:
            tmp = None
            if (s2_ptr_off <= ((s2_limit_off - 4))):
                p_off = (s1_off + matched)
                tmp = ((((((s2[(s2_ptr_off + 3)] << 24) | (s2[(s2_ptr_off + 2)] << 16)) | (s2[(s2_ptr_off + 1)] << 8)) | s2[s2_ptr_off])) == (((((s1[(p_off + 3)] << 24) | (s1[(p_off + 2)] << 16)) | (s1[(p_off + 1)] << 8)) | s1[p_off])))
            else:
                tmp = False
            if (not tmp):
                break
            s2_ptr_off = (s2_ptr_off + 4)
            matched = (matched + 4)
        while ((s2_ptr_off < s2_limit_off) and ((s1[(s1_off + matched)] == s2[s2_ptr_off]))):
            s2_ptr_off = (s2_ptr_off + 1)
            matched = (matched + 1)
        return matched


class encode_Hash:
    _hx_class_name = "encode.Hash"
    __slots__ = ()
    _hx_statics = ["kDistanceCacheIndex", "kDistanceCacheOffset", "kHashMul32", "Hash_", "BackwardReferenceScore", "BackwardReferenceScoreUsingLastDistance", "kMaxZopfliLen"]

    def __init__(self):
        pass

    @staticmethod
    def Hash_(kShiftBits,data,data_off):
        return HxOverrides.rshift(((((((((data[(data_off + 3)] << 24) | (data[(data_off + 2)] << 16)) | (data[(data_off + 1)] << 8)) | data[data_off])) * encode_Hash.kHashMul32) & -1)), ((32 - kShiftBits)))

    @staticmethod
    def BackwardReferenceScore(copy_length,backward_reference_offset):
        return ((5.4 * copy_length) - ((1.20 * encode_Fast_log.Log2Floor(backward_reference_offset))))

    @staticmethod
    def BackwardReferenceScoreUsingLastDistance(copy_length,distance_short_code):
        return ((5.4 * copy_length) - python_internal_ArrayImpl._get([-0.6, 0.95, 1.17, 1.27, 0.93, 0.93, 0.96, 0.96, 0.99, 0.99, 1.05, 1.05, 1.15, 1.15, 1.25, 1.25], distance_short_code))


class encode_Histogram_functions:
    _hx_class_name = "encode.Histogram_functions"
    __slots__ = ()
    _hx_statics = ["HistogramLiteral", "HistogramLiteralInt", "HistogramCommand", "HistogramCommandInt", "HistogramDistance", "HistogramDistanceInt", "HistogramBlockLength", "HistogramBlockLengthInt", "HistogramContextMap", "HistogramContextMapInt", "HistogramBlockType", "HistogramBlockTypeInt", "kLiteralContextBits", "kDistanceContextBits", "BuildHistograms"]

    def __init__(self):
        pass

    @staticmethod
    def HistogramLiteral():
        return encode_histogram_Histogram(256)

    @staticmethod
    def HistogramCommand():
        return encode_histogram_Histogram(704)

    @staticmethod
    def HistogramDistance():
        return encode_histogram_Histogram(520)

    @staticmethod
    def HistogramBlockLength():
        return encode_histogram_Histogram(26)

    @staticmethod
    def HistogramContextMap():
        return encode_histogram_Histogram(272)

    @staticmethod
    def HistogramBlockType():
        return encode_histogram_Histogram(258)

    @staticmethod
    def BuildHistograms(cmds,num_commands,literal_split,insert_and_copy_split,dist_split,ringbuffer,start_pos,mask,prev_byte,prev_byte2,context_modes,literal_histograms,insert_and_copy_histograms,copy_dist_histograms):
        pos = start_pos
        literal_it = encode_block_splitter_BlockSplitIterator(literal_split)
        insert_and_copy_it = encode_block_splitter_BlockSplitIterator(insert_and_copy_split)
        dist_it = encode_block_splitter_BlockSplitIterator(dist_split)
        _g1 = 0
        while (_g1 < num_commands):
            i = _g1
            _g1 = (_g1 + 1)
            cmd = (cmds[i] if i >= 0 and i < len(cmds) else None)
            insert_and_copy_it.Next()
            python_internal_ArrayImpl._get(insert_and_copy_histograms, insert_and_copy_it.type_).Add1((cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None))
            _g3 = 0
            _g2 = cmd.insert_len_
            while (_g3 < _g2):
                _g3 = (_g3 + 1)
                literal_it.Next()
                python_internal_ArrayImpl._get(literal_histograms, (((literal_it.type_ << 6)) + encode_Context.ContextFunction(prev_byte,prev_byte2,python_internal_ArrayImpl._get(context_modes, literal_it.type_)))).Add1(ringbuffer[(pos & mask)])
                prev_byte2 = prev_byte
                prev_byte = ringbuffer[(pos & mask)]
                pos = (pos + 1)
            pos = (pos + cmd.copy_len_)
            if (cmd.copy_len_ > 0):
                prev_byte2 = ringbuffer[((pos - 2) & mask)]
                prev_byte = ringbuffer[((pos - 1) & mask)]
                a = (cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None)
                aNeg = (a < 0)
                if (aNeg if ((aNeg != False)) else (a >= 128)):
                    dist_it.Next()
                    python_internal_ArrayImpl._get(copy_dist_histograms, (((dist_it.type_ << 2)) + cmd.DistanceContext())).Add1((cmd.dist_prefix_[0] if 0 < len(cmd.dist_prefix_) else None))


class encode_Literal_cost:
    _hx_class_name = "encode.Literal_cost"
    __slots__ = ()
    _hx_statics = ["UTF8Position", "DecideMultiByteStatsLevel", "EstimateBitCostsForLiteralsUTF8", "EstimateBitCostsForLiterals"]

    def __init__(self):
        pass

    @staticmethod
    def UTF8Position(last,c,clamp):
        if (c < 128):
            return 0
        elif (c >= 192):
            x = (1 if (python_lib_Math.isnan(1)) else (clamp if (python_lib_Math.isnan(clamp)) else min(1,clamp)))
            try:
                return int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None
        elif (last < 224):
            return 0
        else:
            x1 = (2 if (python_lib_Math.isnan(2)) else (clamp if (python_lib_Math.isnan(clamp)) else min(2,clamp)))
            try:
                return int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                return None

    @staticmethod
    def DecideMultiByteStatsLevel(pos,_hx_len,mask,data):
        counts = [0, 0, 0]
        max_utf8 = 1
        last_c = 0
        utf8_pos = 0
        _g1 = 0
        while (_g1 < _hx_len):
            i = _g1
            _g1 = (_g1 + 1)
            c = data[((pos + i) & mask)]
            utf8_pos = encode_Literal_cost.UTF8Position(last_c,c,2)
            python_internal_ArrayImpl._set(counts, utf8_pos, ((counts[utf8_pos] if utf8_pos >= 0 and utf8_pos < len(counts) else None) + 1))
            last_c = c
        if ((counts[2] if 2 < len(counts) else None) < 500):
            max_utf8 = 1
        if (((counts[1] if 1 < len(counts) else None) + (counts[2] if 2 < len(counts) else None)) < 25):
            max_utf8 = 0
        return max_utf8

    @staticmethod
    def EstimateBitCostsForLiteralsUTF8(pos,_hx_len,mask,cost_mask,data,cost):
        max_utf8 = encode_Literal_cost.DecideMultiByteStatsLevel(pos,_hx_len,mask,data)
        histogram = [FunctionMalloc.mallocInt(256), FunctionMalloc.mallocInt(256), FunctionMalloc.mallocInt(256)]
        x = (495 if (python_lib_Math.isnan(495)) else (_hx_len if (python_lib_Math.isnan(_hx_len)) else min(495,_hx_len)))
        in_window = None
        try:
            in_window = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            in_window = None
        in_window_utf8 = [0, 0, 0]
        last_c = 0
        utf8_pos = 0
        _g1 = 0
        _g = in_window
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = data[((pos + i) & mask)]
            val = ((histogram[utf8_pos] if utf8_pos >= 0 and utf8_pos < len(histogram) else None)[c] + 1)
            (histogram[utf8_pos] if utf8_pos >= 0 and utf8_pos < len(histogram) else None)[c] = val
            python_internal_ArrayImpl._set(in_window_utf8, utf8_pos, ((in_window_utf8[utf8_pos] if utf8_pos >= 0 and utf8_pos < len(in_window_utf8) else None) + 1))
            utf8_pos = encode_Literal_cost.UTF8Position(last_c,c,max_utf8)
            last_c = c
        _g11 = 0
        while (_g11 < _hx_len):
            i1 = _g11
            _g11 = (_g11 + 1)
            if ((i1 - 495) >= 0):
                c1 = (0 if ((((i1 - 495) - 1) < 0)) else data[((((pos + i1) - 495) - 1) & mask)])
                utf8_pos2 = encode_Literal_cost.UTF8Position((0 if ((((i1 - 495) - 2) < 0)) else data[((((pos + i1) - 495) - 2) & mask)]),c1,max_utf8)
                _g2 = data[(((pos + i1) - 495) & mask)]
                val1 = ((histogram[utf8_pos2] if utf8_pos2 >= 0 and utf8_pos2 < len(histogram) else None)[_g2] - 1)
                (histogram[utf8_pos2] if utf8_pos2 >= 0 and utf8_pos2 < len(histogram) else None)[_g2] = val1
                python_internal_ArrayImpl._set(in_window_utf8, utf8_pos2, ((in_window_utf8[utf8_pos2] if utf8_pos2 >= 0 and utf8_pos2 < len(in_window_utf8) else None) - 1))
            if ((i1 + 495) < _hx_len):
                c2 = (0 if ((((i1 + 495) - 1) < 0)) else data[((((pos + i1) + 495) - 1) & mask)])
                utf8_pos21 = encode_Literal_cost.UTF8Position((0 if ((((i1 + 495) - 2) < 0)) else data[((((pos + i1) + 495) - 2) & mask)]),c2,max_utf8)
                _g21 = data[(((pos + i1) + 495) & mask)]
                val2 = ((histogram[utf8_pos21] if utf8_pos21 >= 0 and utf8_pos21 < len(histogram) else None)[_g21] + 1)
                (histogram[utf8_pos21] if utf8_pos21 >= 0 and utf8_pos21 < len(histogram) else None)[_g21] = val2
                python_internal_ArrayImpl._set(in_window_utf8, utf8_pos21, ((in_window_utf8[utf8_pos21] if utf8_pos21 >= 0 and utf8_pos21 < len(in_window_utf8) else None) + 1))
            c3 = (0 if ((i1 < 1)) else data[(((pos + i1) - 1) & mask)])
            utf8_pos1 = encode_Literal_cost.UTF8Position((0 if ((i1 < 2)) else data[(((pos + i1) - 2) & mask)]),c3,max_utf8)
            index = data[((pos + i1) & mask)]
            histo = (histogram[utf8_pos1] if utf8_pos1 >= 0 and utf8_pos1 < len(histogram) else None)[index]
            if (histo == 0):
                histo = 1
            lit_cost = (encode_Fast_log.FastLog2((in_window_utf8[utf8_pos1] if utf8_pos1 >= 0 and utf8_pos1 < len(in_window_utf8) else None)) - encode_Fast_log.FastLog2(histo))
            lit_cost = (lit_cost + 0.02905)
            if (lit_cost < 1.0):
                lit_cost = (lit_cost * 0.5)
                lit_cost = (lit_cost + 0.5)
            if (i1 < 2000):
                lit_cost = (lit_cost + ((0.7 - (((((2000 - i1)) / 2000.0) * 0.35)))))
            cost[((pos + i1) & cost_mask)] = lit_cost

    @staticmethod
    def EstimateBitCostsForLiterals(pos,_hx_len,mask,cost_mask,data,cost):
        histogram = FunctionMalloc.mallocInt(256)
        x = (2000 if (python_lib_Math.isnan(2000)) else (_hx_len if (python_lib_Math.isnan(_hx_len)) else min(2000,_hx_len)))
        in_window = None
        try:
            in_window = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            in_window = None
        _g1 = 0
        _g = in_window
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            _g2 = data[((pos + i) & mask)]
            val = (histogram[_g2] + 1)
            histogram[_g2] = val
        _g11 = 0
        while (_g11 < _hx_len):
            i1 = _g11
            _g11 = (_g11 + 1)
            if ((i1 - 2000) >= 0):
                _g21 = data[(((pos + i1) - 2000) & mask)]
                val1 = (histogram[_g21] - 1)
                histogram[_g21] = val1
                in_window = (in_window - 1)
            if ((i1 + 2000) < _hx_len):
                _g22 = data[(((pos + i1) + 2000) & mask)]
                val2 = (histogram[_g22] + 1)
                histogram[_g22] = val2
                in_window = (in_window + 1)
            histo = histogram[data[((pos + i1) & mask)]]
            if (histo == 0):
                histo = 1
            lit_cost = (encode_Fast_log.FastLog2(in_window) - encode_Fast_log.FastLog2(histo))
            lit_cost = (lit_cost + 0.029)
            if (lit_cost < 1.0):
                lit_cost = (lit_cost * 0.5)
                lit_cost = (lit_cost + 0.5)
            cost[((pos + i1) & cost_mask)] = lit_cost


class encode_Metablock:
    _hx_class_name = "encode.Metablock"
    __slots__ = ()
    _hx_statics = ["BuildMetaBlock", "BuildMetaBlockGreedy", "BuildMetaBlockGreedyWithContexts", "OptimizeHistograms"]

    def __init__(self):
        pass

    @staticmethod
    def BuildMetaBlock(ringbuffer,pos,mask,prev_byte,prev_byte2,cmds,num_commands,literal_context_mode,mb):
        encode_Block_splitter.SplitBlock(cmds,num_commands,ringbuffer,(pos & mask),mb.literal_split,mb.command_split,mb.distance_split)
        literal_context_modes = list()
        _g1 = 0
        _g = mb.literal_split.num_types
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(literal_context_modes, i, literal_context_mode)
        num_literal_contexts = (mb.literal_split.num_types << 6)
        num_distance_contexts = (mb.distance_split.num_types << 2)
        literal_histograms = list()
        _g11 = 0
        while (_g11 < num_literal_contexts):
            _g11 = (_g11 + 1)
            x = encode_histogram_Histogram(encode_Histogram_functions.HistogramLiteralInt)
            literal_histograms.append(x)
        mb.command_histograms = []
        _g12 = 0
        _g2 = mb.command_split.num_types
        while (_g12 < _g2):
            _g12 = (_g12 + 1)
            _this = mb.command_histograms
            x1 = encode_histogram_Histogram(encode_Histogram_functions.HistogramCommandInt)
            _this.append(x1)
        distance_histograms = list()
        _g13 = 0
        while (_g13 < num_distance_contexts):
            _g13 = (_g13 + 1)
            x2 = encode_histogram_Histogram(encode_Histogram_functions.HistogramDistanceInt)
            distance_histograms.append(x2)
        encode_Histogram_functions.BuildHistograms(cmds,num_commands,mb.literal_split,mb.command_split,mb.distance_split,ringbuffer,pos,mask,prev_byte,prev_byte2,literal_context_modes,literal_histograms,mb.command_histograms,distance_histograms)
        _g14 = 0
        _g3 = len(literal_histograms)
        while (_g14 < _g3):
            i1 = _g14
            _g14 = (_g14 + 1)
            python_internal_ArrayImpl._set(mb.literal_histograms, i1, encode_histogram_Histogram(encode_Histogram_functions.HistogramLiteralInt))
            (mb.literal_histograms[i1] if i1 >= 0 and i1 < len(mb.literal_histograms) else None).bit_cost_ = (literal_histograms[i1] if i1 >= 0 and i1 < len(literal_histograms) else None).bit_cost_
            _g31 = 0
            _g21 = len((literal_histograms[i1] if i1 >= 0 and i1 < len(literal_histograms) else None).data_)
            while (_g31 < _g21):
                a = _g31
                _g31 = (_g31 + 1)
                this1 = (mb.literal_histograms[i1] if i1 >= 0 and i1 < len(mb.literal_histograms) else None).data_
                val = (literal_histograms[i1] if i1 >= 0 and i1 < len(literal_histograms) else None).data_[a]
                this1[a] = val
            (mb.literal_histograms[i1] if i1 >= 0 and i1 < len(mb.literal_histograms) else None).kDataSize = (literal_histograms[i1] if i1 >= 0 and i1 < len(literal_histograms) else None).kDataSize
            (mb.literal_histograms[i1] if i1 >= 0 and i1 < len(mb.literal_histograms) else None).total_count_ = (literal_histograms[i1] if i1 >= 0 and i1 < len(literal_histograms) else None).total_count_
        mb.literal_context_map = [None]*(64 * mb.literal_split.num_types)
        encode_Cluster.ClusterHistograms(literal_histograms,64,mb.literal_split.num_types,256,mb.literal_histograms,encode_Histogram_functions.HistogramLiteralInt,mb.literal_context_map)
        _g15 = 0
        _g4 = len(distance_histograms)
        while (_g15 < _g4):
            i2 = _g15
            _g15 = (_g15 + 1)
            python_internal_ArrayImpl._set(mb.distance_histograms, i2, encode_histogram_Histogram(encode_Histogram_functions.HistogramDistanceInt))
            (mb.distance_histograms[i2] if i2 >= 0 and i2 < len(mb.distance_histograms) else None).bit_cost_ = (distance_histograms[i2] if i2 >= 0 and i2 < len(distance_histograms) else None).bit_cost_
            _g32 = 0
            _g22 = len((distance_histograms[i2] if i2 >= 0 and i2 < len(distance_histograms) else None).data_)
            while (_g32 < _g22):
                a1 = _g32
                _g32 = (_g32 + 1)
                this2 = (mb.distance_histograms[i2] if i2 >= 0 and i2 < len(mb.distance_histograms) else None).data_
                val1 = (distance_histograms[i2] if i2 >= 0 and i2 < len(distance_histograms) else None).data_[a1]
                this2[a1] = val1
            (mb.distance_histograms[i2] if i2 >= 0 and i2 < len(mb.distance_histograms) else None).kDataSize = (distance_histograms[i2] if i2 >= 0 and i2 < len(distance_histograms) else None).kDataSize
            (mb.distance_histograms[i2] if i2 >= 0 and i2 < len(mb.distance_histograms) else None).total_count_ = (distance_histograms[i2] if i2 >= 0 and i2 < len(distance_histograms) else None).total_count_
        mb.distance_context_map = [None]*(4 * mb.distance_split.num_types)
        encode_Cluster.ClusterHistograms(distance_histograms,4,mb.distance_split.num_types,256,mb.distance_histograms,encode_Histogram_functions.HistogramDistanceInt,mb.distance_context_map)

    @staticmethod
    def BuildMetaBlockGreedy(ringbuffer,pos,mask,commands,n_commands,mb):
        num_literals = 0
        _g1 = 0
        while (_g1 < n_commands):
            i = _g1
            _g1 = (_g1 + 1)
            num_literals = (num_literals + (commands[i] if i >= 0 and i < len(commands) else None).insert_len_)
        lit_blocks = encode_metablock_BlockSplitter(encode_Histogram_functions.HistogramLiteralInt,256,512,400.0,num_literals,mb.literal_split,mb.literal_histograms)
        cmd_blocks = encode_metablock_BlockSplitter(encode_Histogram_functions.HistogramCommandInt,704,1024,500.0,n_commands,mb.command_split,mb.command_histograms)
        dist_blocks = encode_metablock_BlockSplitter(encode_Histogram_functions.HistogramDistanceInt,64,512,100.0,n_commands,mb.distance_split,mb.distance_histograms)
        _g11 = 0
        while (_g11 < n_commands):
            i1 = _g11
            _g11 = (_g11 + 1)
            cmd = (commands[i1] if i1 >= 0 and i1 < len(commands) else None)
            cmd_blocks.AddSymbol((cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None))
            _g3 = 0
            _g2 = cmd.insert_len_
            while (_g3 < _g2):
                _g3 = (_g3 + 1)
                lit_blocks.AddSymbol(ringbuffer[(pos & mask)])
                pos = (pos + 1)
            pos = (pos + cmd.copy_len_)
            tmp = None
            if (cmd.copy_len_ > 0):
                a = (cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None)
                aNeg = (a < 0)
                if (aNeg != False):
                    tmp = aNeg
                else:
                    tmp = (a >= 128)
            else:
                tmp = False
            if tmp:
                dist_blocks.AddSymbol((cmd.dist_prefix_[0] if 0 < len(cmd.dist_prefix_) else None))
        lit_blocks.FinishBlock(True)
        cmd_blocks.FinishBlock(True)
        dist_blocks.FinishBlock(True)

    @staticmethod
    def BuildMetaBlockGreedyWithContexts(ringbuffer,pos,mask,prev_byte,prev_byte2,literal_context_mode,num_contexts,static_context_map,commands,n_commands,mb):
        num_literals = 0
        _g1 = 0
        while (_g1 < n_commands):
            i = _g1
            _g1 = (_g1 + 1)
            num_literals = (num_literals + (commands[i] if i >= 0 and i < len(commands) else None).insert_len_)
        lit_blocks = encode_metablock_ContextBlockSplitter(encode_Histogram_functions.HistogramLiteralInt,256,num_contexts,512,400.0,num_literals,mb.literal_split,mb.literal_histograms)
        cmd_blocks = encode_metablock_BlockSplitter(encode_Histogram_functions.HistogramCommandInt,704,1024,500.0,n_commands,mb.command_split,mb.command_histograms)
        dist_blocks = encode_metablock_BlockSplitter(encode_Histogram_functions.HistogramDistanceInt,64,512,100.0,n_commands,mb.distance_split,mb.distance_histograms)
        _g11 = 0
        while (_g11 < n_commands):
            i1 = _g11
            _g11 = (_g11 + 1)
            cmd = (commands[i1] if i1 >= 0 and i1 < len(commands) else None)
            cmd_blocks.AddSymbol((cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None))
            _g3 = 0
            _g2 = cmd.insert_len_
            while (_g3 < _g2):
                _g3 = (_g3 + 1)
                context = encode_Context.ContextFunction(prev_byte,prev_byte2,literal_context_mode)
                literal = ringbuffer[(pos & mask)]
                lit_blocks.AddSymbol(literal,(static_context_map[context] if context >= 0 and context < len(static_context_map) else None))
                prev_byte2 = prev_byte
                prev_byte = literal
                pos = (pos + 1)
            pos = (pos + cmd.copy_len_)
            if (cmd.copy_len_ > 0):
                prev_byte2 = ringbuffer[((pos - 2) & mask)]
                prev_byte = ringbuffer[((pos - 1) & mask)]
                if ((cmd.cmd_prefix_[0] if 0 < len(cmd.cmd_prefix_) else None) >= 128):
                    dist_blocks.AddSymbol((cmd.dist_prefix_[0] if 0 < len(cmd.dist_prefix_) else None))
        lit_blocks.FinishBlock(True)
        cmd_blocks.FinishBlock(True)
        dist_blocks.FinishBlock(True)
        mb.literal_context_map = FunctionMalloc.mallocInt((mb.literal_split.num_types << 6))
        _g12 = 0
        _g = mb.literal_split.num_types
        while (_g12 < _g):
            i2 = _g12
            _g12 = (_g12 + 1)
            _g31 = 0
            while (_g31 < 64):
                j = _g31
                _g31 = (_g31 + 1)
                val = ((i2 * num_contexts) + (static_context_map[j] if j >= 0 and j < len(static_context_map) else None))
                mb.literal_context_map[(((i2 << 6)) + j)] = val

    @staticmethod
    def OptimizeHistograms(num_direct_distance_codes,distance_postfix_bits,mb):
        _g1 = 0
        _g = len(mb.literal_histograms)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            encode_Entropy_encode.OptimizeHuffmanCountsForRle(256,(mb.literal_histograms[i] if i >= 0 and i < len(mb.literal_histograms) else None).data_)
        _g11 = 0
        _g2 = len(mb.command_histograms)
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            encode_Entropy_encode.OptimizeHuffmanCountsForRle(704,(mb.command_histograms[i1] if i1 >= 0 and i1 < len(mb.command_histograms) else None).data_)
        num_distance_codes = ((16 + num_direct_distance_codes) + ((48 << distance_postfix_bits)))
        _g12 = 0
        _g3 = len(mb.distance_histograms)
        while (_g12 < _g3):
            i2 = _g12
            _g12 = (_g12 + 1)
            encode_Entropy_encode.OptimizeHuffmanCountsForRle(num_distance_codes,(mb.distance_histograms[i2] if i2 >= 0 and i2 < len(mb.distance_histograms) else None).data_)


class encode_Port:
    _hx_class_name = "encode.Port"
    __slots__ = ()
    _hx_statics = ["BROTLI_UNALIGNED_LOAD32", "PREDICT_FALSE", "PREDICT_TRUE"]

    def __init__(self):
        pass

    @staticmethod
    def BROTLI_UNALIGNED_LOAD32(p,p_off):
        return ((((p[(p_off + 3)] << 24) | (p[(p_off + 2)] << 16)) | (p[(p_off + 1)] << 8)) | p[p_off])

    @staticmethod
    def PREDICT_FALSE(x):
        return x

    @staticmethod
    def PREDICT_TRUE(x):
        return x


class encode_prefix_PrefixCodeRange:
    _hx_class_name = "encode.prefix.PrefixCodeRange"
    __slots__ = ("offset", "nbits")
    _hx_fields = ["offset", "nbits"]

    def __init__(self,offset,nbits):
        self.offset = offset
        self.nbits = nbits



class encode_Prefix:
    _hx_class_name = "encode.Prefix"
    __slots__ = ()
    _hx_statics = ["kNumInsertLenPrefixes", "kNumCopyLenPrefixes", "kNumCommandPrefixes", "kNumBlockLenPrefixes", "kNumDistanceShortCodes", "kNumDistancePrefixes", "kBlockLengthPrefixCode", "GetBlockLengthPrefixCode", "PrefixEncodeCopyDistance"]

    def __init__(self):
        pass

    @staticmethod
    def GetBlockLengthPrefixCode(_hx_len,code,code_off,n_extra,n_extra_off,extra,extra_off):
        code[code_off] = 0
        while ((code[code_off] < 25) and ((_hx_len >= python_internal_ArrayImpl._get(encode_Prefix.kBlockLengthPrefixCode, (code[code_off] + 1)).offset))):
            val = (code[code_off] + 1)
            code[code_off] = val
        val1 = python_internal_ArrayImpl._get(encode_Prefix.kBlockLengthPrefixCode, code[code_off]).nbits
        n_extra[n_extra_off] = val1
        val2 = (_hx_len - python_internal_ArrayImpl._get(encode_Prefix.kBlockLengthPrefixCode, code[code_off]).offset)
        extra[extra_off] = val2

    @staticmethod
    def PrefixEncodeCopyDistance(distance_code,num_direct_codes,postfix_bits,code,extra_bits):
        if (distance_code < ((16 + num_direct_codes))):
            python_internal_ArrayImpl._set(code, 0, distance_code)
            python_internal_ArrayImpl._set(extra_bits, 0, 0)
            return
        distance_code = (distance_code - ((16 + num_direct_codes)))
        distance_code = (distance_code + ((1 << ((postfix_bits + 2)))))
        bucket = (encode_Fast_log.Log2Floor(distance_code) - 1)
        prefix = ((distance_code >> bucket) & 1)
        nbits = (bucket - postfix_bits)
        python_internal_ArrayImpl._set(code, 0, (((16 + num_direct_codes) + ((((2 * ((nbits - 1))) + prefix) << postfix_bits))) + ((distance_code & ((((1 << postfix_bits)) - 1))))))
        python_internal_ArrayImpl._set(extra_bits, 0, ((nbits << 24) | (((distance_code - (((2 + prefix) << bucket))) >> postfix_bits))))


class encode_RingBuffer:
    _hx_class_name = "encode.RingBuffer"
    __slots__ = ("window_bits_", "mask_", "tail_size_", "pos_", "buffer_", "buffer_off")
    _hx_fields = ["window_bits_", "mask_", "tail_size_", "pos_", "buffer_", "buffer_off"]
    _hx_methods = ["WriteTail", "Write", "position", "mask", "start"]

    def __init__(self,window_bits,tail_bits):
        self.buffer_off = None
        self.buffer_ = None
        self.window_bits_ = window_bits
        self.mask_ = (((1 << window_bits)) - 1)
        self.tail_size_ = (1 << tail_bits)
        self.pos_ = 0
        buflen = (((1 << self.window_bits_)) + self.tail_size_)
        self.buffer_ = [None]*(buflen + 3)
        _g1 = 0
        while (_g1 < 3):
            i = _g1
            _g1 = (_g1 + 1)
            self.buffer_[(buflen + i)] = 0

    def WriteTail(self,_hx_bytes,n):
        masked_pos = (self.pos_ & self.mask_)
        if (masked_pos < self.tail_size_):
            p = (((1 << self.window_bits_)) + masked_pos)
            tmp = self.buffer_
            b = (self.tail_size_ - masked_pos)
            x = (n if (python_lib_Math.isnan(n)) else (b if (python_lib_Math.isnan(b)) else min(n,b)))
            tmp1 = None
            try:
                tmp1 = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp1 = None
            DefaultFunctions.memcpy_UInt(tmp,p,_hx_bytes,0,tmp1)

    def Write(self,_hx_bytes,n):
        masked_pos = (self.pos_ & self.mask_)
        self.WriteTail(_hx_bytes,n)
        if ((masked_pos + n) <= ((1 << self.window_bits_))):
            DefaultFunctions.memcpy_UInt(self.buffer_,masked_pos,_hx_bytes,0,n)
        else:
            tmp = self.buffer_
            b = ((((1 << self.window_bits_)) + self.tail_size_) - masked_pos)
            x = (n if (python_lib_Math.isnan(n)) else (b if (python_lib_Math.isnan(b)) else min(n,b)))
            tmp1 = None
            try:
                tmp1 = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp1 = None
            DefaultFunctions.memcpy_UInt(tmp,masked_pos,_hx_bytes,0,tmp1)
            DefaultFunctions.memcpy_UInt(self.buffer_,0,_hx_bytes,(((1 << self.window_bits_)) - masked_pos),(n - ((((1 << self.window_bits_)) - masked_pos))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos_
        _hx_local_0.pos_ = (_hx_local_1 + n)
        _hx_local_0.pos_

    def position(self):
        return self.pos_

    def mask(self):
        return self.mask_

    def start(self):
        return self.buffer_



class encode_Static_dict:
    _hx_class_name = "encode.Static_dict"
    __slots__ = ()
    _hx_statics = ["kMaxDictionaryMatchLen", "kInvalidMatch", "Hash_1", "AddMatch", "DictMatchLength", "IsMatch", "FindAllStaticDictionaryMatches"]

    def __init__(self):
        pass

    @staticmethod
    def Hash_1(data,data_off):
        return HxOverrides.rshift(HxOverrides.rshift(((((((data[(data_off + 3)] << 24) | (data[(data_off + 2)] << 16)) | (data[(data_off + 1)] << 8)) | data[data_off])) * 506832829), 0), 17)

    @staticmethod
    def AddMatch(distance,_hx_len,len_code,matches):
        a = matches[_hx_len]
        b = (((distance << 5)) + len_code)
        x = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        val = None
        try:
            val = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            val = None
        matches[_hx_len] = val

    @staticmethod
    def DictMatchLength(data,data_off,id,_hx_len):
        return encode_Find_match_length.FindMatchLengthWithLimit(encode_Dictionary.kBrotliDictionary,(python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionaryOffsetsByLength, _hx_len) + ((_hx_len * id))),data,data_off,_hx_len)

    @staticmethod
    def IsMatch(w,data,data_off):
        offset = (python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionaryOffsetsByLength, w.len) + (w.len * w.idx))
        _hx_dict = encode_Dictionary.kBrotliDictionary
        if (w.transform == 0):
            return (encode_Find_match_length.FindMatchLengthWithLimit(_hx_dict,offset,data,data_off,w.len) == w.len)
        elif (w.transform == 10):
            tmp = None
            tmp1 = None
            a = _hx_dict[offset]
            b = HxString.charCodeAt("a",0)
            aNeg = (a < 0)
            if (aNeg if ((aNeg != ((b < 0)))) else (a >= b)):
                a1 = _hx_dict[offset]
                b1 = HxString.charCodeAt("z",0)
                aNeg1 = (b1 < 0)
                if (aNeg1 != ((a1 < 0))):
                    tmp1 = aNeg1
                else:
                    tmp1 = (b1 >= a1)
            else:
                tmp1 = False
            if tmp1:
                tmp = (((_hx_dict[offset] ^ 32)) == data[data_off])
            else:
                tmp = False
            if tmp:
                return (encode_Find_match_length.FindMatchLengthWithLimit(_hx_dict,(offset + 1),data,(data_off + 1),(w.len - 1)) == (w.len - 1))
            else:
                return False
        else:
            _g1 = 0
            _g = w.len
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                tmp2 = None
                a2 = _hx_dict[(offset + i)]
                b2 = HxString.charCodeAt("a",0)
                aNeg2 = (a2 < 0)
                if (aNeg2 if ((aNeg2 != ((b2 < 0)))) else (a2 >= b2)):
                    a3 = _hx_dict[(offset + i)]
                    b3 = HxString.charCodeAt("z",0)
                    aNeg3 = (b3 < 0)
                    if (aNeg3 != ((a3 < 0))):
                        tmp2 = aNeg3
                    else:
                        tmp2 = (b3 >= a3)
                else:
                    tmp2 = False
                if tmp2:
                    if (((_hx_dict[(offset + i)] ^ 32)) != data[(data_off + i)]):
                        return False
                elif (_hx_dict[(offset + i)] != data[(data_off + i)]):
                    return False
            return True

    @staticmethod
    def FindAllStaticDictionaryMatches(data,data_off,min_length,matches,matches_off):
        found_match = False
        key = encode_Static_dict.Hash_1(data,data_off)
        bucket = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryBuckets, key)
        if (bucket != 0):
            num = (bucket & 255)
            offset = HxOverrides.rshift(bucket, 8)
            _g1 = 0
            while (_g1 < num):
                i = _g1
                _g1 = (_g1 + 1)
                w = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryWords, (offset + i))
                l = w.len
                n = (1 << python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionarySizeBitsByLength, l))
                id = w.idx
                if (w.transform == 0):
                    matchlen = encode_Static_dict.DictMatchLength(data,data_off,id,l)
                    if (matchlen == l):
                        encode_Static_dict.AddMatch(id,l,l,matches)
                        found_match = True
                    if (matchlen >= ((l - 1))):
                        encode_Static_dict.AddMatch((id + ((12 * n))),(l - 1),l,matches)
                        if ((((data[((data_off + l) - 1)] == HxString.charCodeAt("i",0)) and ((data[(data_off + l)] == HxString.charCodeAt("n",0)))) and ((data[((data_off + l) + 1)] == HxString.charCodeAt("g",0)))) and ((data[((data_off + l) + 2)] == HxString.charCodeAt(" ",0)))):
                            encode_Static_dict.AddMatch((id + ((49 * n))),(l + 3),l,matches)
                        found_match = True
                    b = (l - 9)
                    x = (min_length if (python_lib_Math.isnan(min_length)) else (b if (python_lib_Math.isnan(b)) else max(min_length,b)))
                    minlen = None
                    try:
                        minlen = int(x)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        minlen = None
                    b1 = (l - 2)
                    x1 = (matchlen if (python_lib_Math.isnan(matchlen)) else (b1 if (python_lib_Math.isnan(b1)) else min(matchlen,b1)))
                    maxlen = None
                    try:
                        maxlen = int(x1)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        maxlen = None
                    _g3 = minlen
                    _g2 = (maxlen + 1)
                    while (_g3 < _g2):
                        len = _g3
                        _g3 = (_g3 + 1)
                        encode_Static_dict.AddMatch((id + ((python_internal_ArrayImpl._get(encode_Transform.kOmitLastNTransforms, (l - len)) * n))),len,l,matches)
                        found_match = True
                    if (matchlen < l):
                        continue
                    s_off = (data_off + l)
                    if (data[s_off] == HxString.charCodeAt(" ",0)):
                        encode_Static_dict.AddMatch((id + n),(l + 1),l,matches)
                        if (data[(s_off + 1)] == HxString.charCodeAt("a",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt(" ",0)):
                                encode_Static_dict.AddMatch((id + ((28 * n))),(l + 3),l,matches)
                            elif (data[(s_off + 2)] == HxString.charCodeAt("s",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt(" ",0)):
                                    encode_Static_dict.AddMatch((id + ((46 * n))),(l + 4),l,matches)
                            elif (data[(s_off + 2)] == HxString.charCodeAt("t",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt(" ",0)):
                                    encode_Static_dict.AddMatch((id + ((60 * n))),(l + 4),l,matches)
                            elif (data[(s_off + 2)] == HxString.charCodeAt("n",0)):
                                if ((data[(s_off + 3)] == HxString.charCodeAt("d",0)) and ((data[(s_off + 4)] == HxString.charCodeAt(" ",0)))):
                                    encode_Static_dict.AddMatch((id + ((10 * n))),(l + 5),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("b",0)):
                            if ((data[(s_off + 2)] == HxString.charCodeAt("y",0)) and ((data[(s_off + 3)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id + ((38 * n))),(l + 4),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("i",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt("n",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt(" ",0)):
                                    encode_Static_dict.AddMatch((id + ((16 * n))),(l + 4),l,matches)
                            elif (data[(s_off + 2)] == HxString.charCodeAt("s",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt(" ",0)):
                                    encode_Static_dict.AddMatch((id + ((47 * n))),(l + 4),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("f",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt("o",0)):
                                if ((data[(s_off + 3)] == HxString.charCodeAt("r",0)) and ((data[(s_off + 4)] == HxString.charCodeAt(" ",0)))):
                                    encode_Static_dict.AddMatch((id + ((25 * n))),(l + 5),l,matches)
                            elif (data[(s_off + 2)] == HxString.charCodeAt("r",0)):
                                if (((data[(s_off + 3)] == HxString.charCodeAt("o",0)) and ((data[(s_off + 4)] == HxString.charCodeAt("m",0)))) and ((data[(s_off + 5)] == HxString.charCodeAt(" ",0)))):
                                    encode_Static_dict.AddMatch((id + ((37 * n))),(l + 6),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("o",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt("f",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt(" ",0)):
                                    encode_Static_dict.AddMatch((id + ((8 * n))),(l + 4),l,matches)
                            elif (data[(s_off + 2)] == HxString.charCodeAt("n",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt(" ",0)):
                                    encode_Static_dict.AddMatch((id + ((45 * n))),(l + 4),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("n",0)):
                            if (((data[(s_off + 2)] == HxString.charCodeAt("o",0)) and ((data[(s_off + 3)] == HxString.charCodeAt("t",0)))) and ((data[(s_off + 4)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id + ((80 * n))),(l + 5),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("t",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt("h",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt("e",0)):
                                    if (data[(s_off + 4)] == HxString.charCodeAt(" ",0)):
                                        encode_Static_dict.AddMatch((id + ((5 * n))),(l + 5),l,matches)
                                elif (data[(s_off + 3)] == HxString.charCodeAt("a",0)):
                                    if ((data[(s_off + 4)] == HxString.charCodeAt("t",0)) and ((data[(s_off + 5)] == HxString.charCodeAt(" ",0)))):
                                        encode_Static_dict.AddMatch((id + ((29 * n))),(l + 6),l,matches)
                            elif (data[(s_off + 2)] == HxString.charCodeAt("o",0)):
                                if (data[(s_off + 3)] == HxString.charCodeAt(" ",0)):
                                    encode_Static_dict.AddMatch((id + ((17 * n))),(l + 4),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("w",0)):
                            if ((((data[(s_off + 2)] == HxString.charCodeAt("i",0)) and ((data[(s_off + 3)] == HxString.charCodeAt("t",0)))) and ((data[(s_off + 4)] == HxString.charCodeAt("h",0)))) and ((data[(s_off + 5)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id + ((35 * n))),(l + 6),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("\"",0)):
                        encode_Static_dict.AddMatch((id + ((19 * n))),(l + 1),l,matches)
                        if (data[(s_off + 1)] == HxString.charCodeAt(">",0)):
                            encode_Static_dict.AddMatch((id + ((21 * n))),(l + 2),l,matches)
                    elif (data[s_off] == HxString.charCodeAt(".",0)):
                        encode_Static_dict.AddMatch((id + ((20 * n))),(l + 1),l,matches)
                        if (data[(s_off + 1)] == HxString.charCodeAt(" ",0)):
                            encode_Static_dict.AddMatch((id + ((31 * n))),(l + 2),l,matches)
                            if ((data[(s_off + 2)] == HxString.charCodeAt("T",0)) and ((data[(s_off + 3)] == HxString.charCodeAt("h",0)))):
                                if (data[(s_off + 4)] == HxString.charCodeAt("e",0)):
                                    if (data[(s_off + 5)] == HxString.charCodeAt(" ",0)):
                                        encode_Static_dict.AddMatch((id + ((43 * n))),(l + 6),l,matches)
                                elif (data[(s_off + 4)] == HxString.charCodeAt("i",0)):
                                    if ((data[(s_off + 5)] == HxString.charCodeAt("s",0)) and ((data[(s_off + 6)] == HxString.charCodeAt(" ",0)))):
                                        encode_Static_dict.AddMatch((id + ((75 * n))),(l + 7),l,matches)
                    elif (data[s_off] == HxString.charCodeAt(",",0)):
                        encode_Static_dict.AddMatch((id + ((76 * n))),(l + 1),l,matches)
                        if (data[(s_off + 1)] == HxString.charCodeAt(" ",0)):
                            encode_Static_dict.AddMatch((id + ((14 * n))),(l + 2),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("\n",0)):
                        encode_Static_dict.AddMatch((id + ((22 * n))),(l + 1),l,matches)
                        if (data[(s_off + 1)] == HxString.charCodeAt("\t",0)):
                            encode_Static_dict.AddMatch((id + ((50 * n))),(l + 2),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("]",0)):
                        encode_Static_dict.AddMatch((id + ((24 * n))),(l + 1),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("'",0)):
                        encode_Static_dict.AddMatch((id + ((36 * n))),(l + 1),l,matches)
                    elif (data[s_off] == HxString.charCodeAt(":",0)):
                        encode_Static_dict.AddMatch((id + ((51 * n))),(l + 1),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("(",0)):
                        encode_Static_dict.AddMatch((id + ((57 * n))),(l + 1),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("=",0)):
                        if (data[(s_off + 1)] == HxString.charCodeAt("\"",0)):
                            encode_Static_dict.AddMatch((id + ((70 * n))),(l + 2),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("'",0)):
                            encode_Static_dict.AddMatch((id + ((86 * n))),(l + 2),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("a",0)):
                        if ((data[(s_off + 1)] == HxString.charCodeAt("l",0)) and ((data[(s_off + 2)] == HxString.charCodeAt(" ",0)))):
                            encode_Static_dict.AddMatch((id + ((84 * n))),(l + 3),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("e",0)):
                        if (data[(s_off + 1)] == HxString.charCodeAt("d",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt(" ",0)):
                                encode_Static_dict.AddMatch((id + ((53 * n))),(l + 3),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("r",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt(" ",0)):
                                encode_Static_dict.AddMatch((id + ((82 * n))),(l + 3),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("s",0)):
                            if ((data[(s_off + 2)] == HxString.charCodeAt("t",0)) and ((data[(s_off + 3)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id + ((95 * n))),(l + 4),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("f",0)):
                        if (((data[(s_off + 1)] == HxString.charCodeAt("u",0)) and ((data[(s_off + 2)] == HxString.charCodeAt("l",0)))) and ((data[(s_off + 3)] == HxString.charCodeAt(" ",0)))):
                            encode_Static_dict.AddMatch((id + ((90 * n))),(l + 4),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("i",0)):
                        if (data[(s_off + 1)] == HxString.charCodeAt("v",0)):
                            if ((data[(s_off + 2)] == HxString.charCodeAt("e",0)) and ((data[(s_off + 3)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id + ((92 * n))),(l + 4),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("z",0)):
                            if ((data[(s_off + 2)] == HxString.charCodeAt("e",0)) and ((data[(s_off + 3)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id + ((100 * n))),(l + 4),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("l",0)):
                        if (data[(s_off + 1)] == HxString.charCodeAt("e",0)):
                            if (((data[(s_off + 2)] == HxString.charCodeAt("s",0)) and ((data[(s_off + 3)] == HxString.charCodeAt("s",0)))) and ((data[(s_off + 4)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id + ((93 * n))),(l + 5),l,matches)
                        elif (data[(s_off + 1)] == HxString.charCodeAt("y",0)):
                            if (data[(s_off + 2)] == HxString.charCodeAt(" ",0)):
                                encode_Static_dict.AddMatch((id + ((61 * n))),(l + 3),l,matches)
                    elif (data[s_off] == HxString.charCodeAt("o",0)):
                        if (((data[(s_off + 1)] == HxString.charCodeAt("u",0)) and ((data[(s_off + 2)] == HxString.charCodeAt("s",0)))) and ((data[(s_off + 3)] == HxString.charCodeAt(" ",0)))):
                            encode_Static_dict.AddMatch((id + ((106 * n))),(l + 4),l,matches)
                else:
                    t = (w.transform - 10)
                    if (not encode_Static_dict.IsMatch(w,data,data_off)):
                        continue
                    encode_Static_dict.AddMatch((id + ((((44 if ((t > 0)) else 9)) * n))),l,l,matches)
                    found_match = True
                    s_off1 = (data_off + l)
                    if (data[s_off1] == HxString.charCodeAt(" ",0)):
                        encode_Static_dict.AddMatch((id + ((((68 if ((t > 0)) else 4)) * n))),(l + 1),l,matches)
                    elif (data[s_off1] == HxString.charCodeAt("\"",0)):
                        encode_Static_dict.AddMatch((id + ((((87 if ((t > 0)) else 66)) * n))),(l + 1),l,matches)
                        if (data[(s_off1 + 1)] == HxString.charCodeAt(">",0)):
                            encode_Static_dict.AddMatch((id + ((((97 if ((t > 0)) else 69)) * n))),(l + 2),l,matches)
                    elif (data[s_off1] == HxString.charCodeAt(".",0)):
                        encode_Static_dict.AddMatch((id + ((((101 if ((t > 0)) else 79)) * n))),(l + 1),l,matches)
                        if (data[(s_off1 + 1)] == HxString.charCodeAt(" ",0)):
                            encode_Static_dict.AddMatch((id + ((((114 if ((t > 0)) else 88)) * n))),(l + 2),l,matches)
                    elif (data[s_off1] == HxString.charCodeAt(",",0)):
                        encode_Static_dict.AddMatch((id + ((((112 if ((t > 0)) else 99)) * n))),(l + 1),l,matches)
                        if (data[(s_off1 + 1)] == HxString.charCodeAt(" ",0)):
                            encode_Static_dict.AddMatch((id + ((((107 if ((t > 0)) else 58)) * n))),(l + 2),l,matches)
                    elif (data[s_off1] == HxString.charCodeAt("'",0)):
                        encode_Static_dict.AddMatch((id + ((((94 if ((t > 0)) else 74)) * n))),(l + 1),l,matches)
                    elif (data[s_off1] == HxString.charCodeAt("(",0)):
                        encode_Static_dict.AddMatch((id + ((((113 if ((t > 0)) else 78)) * n))),(l + 1),l,matches)
                    elif (data[s_off1] == HxString.charCodeAt("=",0)):
                        if (data[(s_off1 + 1)] == HxString.charCodeAt("\"",0)):
                            encode_Static_dict.AddMatch((id + ((((105 if ((t > 0)) else 104)) * n))),(l + 2),l,matches)
                        elif (data[(s_off1 + 1)] == HxString.charCodeAt("'",0)):
                            encode_Static_dict.AddMatch((id + ((((116 if ((t > 0)) else 108)) * n))),(l + 2),l,matches)
        if ((data[data_off] == HxString.charCodeAt(" ",0)) or ((data[data_off] == HxString.charCodeAt(".",0)))):
            is_space = (data[data_off] == HxString.charCodeAt(" ",0))
            key = encode_Static_dict.Hash_1(data,(data_off + 1))
            bucket = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryBuckets, key)
            num1 = (bucket & 255)
            offset1 = HxOverrides.rshift(bucket, 8)
            _g11 = 0
            while (_g11 < num1):
                i1 = _g11
                _g11 = (_g11 + 1)
                w1 = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryWords, (offset1 + i1))
                l1 = w1.len
                n1 = (1 << python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionarySizeBitsByLength, l1))
                id1 = w1.idx
                if (w1.transform == 0):
                    if (not encode_Static_dict.IsMatch(w1,data,(data_off + 1))):
                        continue
                    encode_Static_dict.AddMatch((id1 + ((((6 if is_space else 32)) * n1))),(l1 + 1),l1,matches)
                    found_match = True
                    s_off2 = ((data_off + l1) + 1)
                    if (data[s_off2] == HxString.charCodeAt(" ",0)):
                        encode_Static_dict.AddMatch((id1 + ((((2 if is_space else 77)) * n1))),(l1 + 2),l1,matches)
                    elif (data[s_off2] == HxString.charCodeAt("(",0)):
                        encode_Static_dict.AddMatch((id1 + ((((89 if is_space else 67)) * n1))),(l1 + 2),l1,matches)
                    elif is_space:
                        if (data[s_off2] == HxString.charCodeAt(",",0)):
                            encode_Static_dict.AddMatch((id1 + ((103 * n1))),(l1 + 2),l1,matches)
                            if (data[(s_off2 + 1)] == HxString.charCodeAt(" ",0)):
                                encode_Static_dict.AddMatch((id1 + ((33 * n1))),(l1 + 3),l1,matches)
                        elif (data[s_off2] == HxString.charCodeAt(".",0)):
                            encode_Static_dict.AddMatch((id1 + ((71 * n1))),(l1 + 2),l1,matches)
                            if (data[(s_off2 + 1)] == HxString.charCodeAt(" ",0)):
                                encode_Static_dict.AddMatch((id1 + ((52 * n1))),(l1 + 3),l1,matches)
                        elif (data[s_off2] == HxString.charCodeAt("=",0)):
                            if (data[(s_off2 + 1)] == HxString.charCodeAt("\"",0)):
                                encode_Static_dict.AddMatch((id1 + ((81 * n1))),(l1 + 3),l1,matches)
                            elif (data[(s_off2 + 1)] == HxString.charCodeAt("'",0)):
                                encode_Static_dict.AddMatch((id1 + ((98 * n1))),(l1 + 3),l1,matches)
                elif is_space:
                    t1 = (w1.transform - 10)
                    if (not encode_Static_dict.IsMatch(w1,data,(data_off + 1))):
                        continue
                    encode_Static_dict.AddMatch((id1 + ((((85 if ((t1 > 0)) else 30)) * n1))),(l1 + 1),l1,matches)
                    found_match = True
                    s_off3 = ((data_off + l1) + 1)
                    if (data[s_off3] == HxString.charCodeAt(" ",0)):
                        encode_Static_dict.AddMatch((id1 + ((((83 if ((t1 > 0)) else 15)) * n1))),(l1 + 2),l1,matches)
                    elif (data[s_off3] == HxString.charCodeAt(",",0)):
                        if (t1 == 0):
                            encode_Static_dict.AddMatch((id1 + ((109 * n1))),(l1 + 2),l1,matches)
                        if (data[(s_off3 + 1)] == HxString.charCodeAt(" ",0)):
                            encode_Static_dict.AddMatch((id1 + ((((111 if ((t1 > 0)) else 65)) * n1))),(l1 + 3),l1,matches)
                    elif (data[s_off3] == HxString.charCodeAt(".",0)):
                        encode_Static_dict.AddMatch((id1 + ((((115 if ((t1 > 0)) else 96)) * n1))),(l1 + 2),l1,matches)
                        if (data[(s_off3 + 1)] == HxString.charCodeAt(" ",0)):
                            encode_Static_dict.AddMatch((id1 + ((((117 if ((t1 > 0)) else 91)) * n1))),(l1 + 3),l1,matches)
                    elif (data[s_off3] == HxString.charCodeAt("=",0)):
                        if (data[(s_off3 + 1)] == HxString.charCodeAt("\"",0)):
                            encode_Static_dict.AddMatch((id1 + ((((110 if ((t1 > 0)) else 118)) * n1))),(l1 + 3),l1,matches)
                        elif (data[(s_off3 + 1)] == HxString.charCodeAt("'",0)):
                            encode_Static_dict.AddMatch((id1 + ((((119 if ((t1 > 0)) else 120)) * n1))),(l1 + 3),l1,matches)
        if (((data[(data_off + 1)] == HxString.charCodeAt(" ",0)) and ((((data[data_off] == HxString.charCodeAt("e",0)) or ((data[data_off] == HxString.charCodeAt("s",0)))) or ((data[data_off] == HxString.charCodeAt(",",0)))))) or (((data[data_off] == 194) and ((data[(data_off + 1)] == 160))))):
            key = encode_Static_dict.Hash_1(data,(data_off + 2))
            bucket = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryBuckets, key)
            num2 = (bucket & 255)
            offset2 = HxOverrides.rshift(bucket, 8)
            _g12 = 0
            while (_g12 < num2):
                i2 = _g12
                _g12 = (_g12 + 1)
                w2 = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryWords, (offset2 + i2))
                l2 = w2.len
                n2 = (1 << python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionarySizeBitsByLength, l2))
                id2 = w2.idx
                if ((w2.transform == 0) and encode_Static_dict.IsMatch(w2,data,(data_off + 2))):
                    if (data[data_off] == 194):
                        encode_Static_dict.AddMatch((id2 + ((102 * n2))),(l2 + 2),l2,matches)
                        found_match = True
                    elif (data[((data_off + l2) + 2)] == HxString.charCodeAt(" ",0)):
                        encode_Static_dict.AddMatch((id2 + ((((18 if ((data[data_off] == HxString.charCodeAt("e",0))) else (7 if ((data[data_off] == HxString.charCodeAt("s",0))) else 13))) * n2))),(l2 + 3),l2,matches)
                        found_match = True
        if ((((((data[data_off] == HxString.charCodeAt(" ",0)) and ((data[(data_off + 1)] == HxString.charCodeAt("t",0)))) and ((data[(data_off + 2)] == HxString.charCodeAt("h",0)))) and ((data[(data_off + 3)] == HxString.charCodeAt("e",0)))) and ((data[(data_off + 4)] == HxString.charCodeAt(" ",0)))) or ((((((data[data_off] == HxString.charCodeAt(".",0)) and ((data[(data_off + 1)] == HxString.charCodeAt("c",0)))) and ((data[(data_off + 2)] == HxString.charCodeAt("o",0)))) and ((data[(data_off + 3)] == HxString.charCodeAt("m",0)))) and ((data[(data_off + 4)] == HxString.charCodeAt("/",0)))))):
            key = encode_Static_dict.Hash_1(data,(data_off + 5))
            bucket = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryBuckets, key)
            num3 = (bucket & 255)
            offset3 = HxOverrides.rshift(bucket, 8)
            _g13 = 0
            while (_g13 < num3):
                i3 = _g13
                _g13 = (_g13 + 1)
                w3 = python_internal_ArrayImpl._get(encode_Static_dict_lut.kStaticDictionaryWords, (offset3 + i3))
                l3 = w3.len
                n3 = (1 << python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionarySizeBitsByLength, l3))
                id3 = w3.idx
                if ((w3.transform == 0) and encode_Static_dict.IsMatch(w3,data,(data_off + 5))):
                    encode_Static_dict.AddMatch((id3 + ((((41 if ((data[data_off] == HxString.charCodeAt(" ",0))) else 72)) * n3))),(l3 + 5),l3,matches)
                    found_match = True
                    s_off4 = ((data_off + l3) + 5)
                    if (data[data_off] == HxString.charCodeAt(" ",0)):
                        if ((((data[s_off4] == HxString.charCodeAt(" ",0)) and ((data[(s_off4 + 1)] == HxString.charCodeAt("o",0)))) and ((data[(s_off4 + 2)] == HxString.charCodeAt("f",0)))) and ((data[(s_off4 + 3)] == HxString.charCodeAt(" ",0)))):
                            encode_Static_dict.AddMatch((id3 + ((62 * n3))),(l3 + 9),l3,matches)
                            if ((((data[(s_off4 + 4)] == HxString.charCodeAt("t",0)) and ((data[(s_off4 + 5)] == HxString.charCodeAt("h",0)))) and ((data[(s_off4 + 6)] == HxString.charCodeAt("e",0)))) and ((data[(s_off4 + 7)] == HxString.charCodeAt(" ",0)))):
                                encode_Static_dict.AddMatch((id3 + ((73 * n3))),(l3 + 13),l3,matches)
        return found_match


class encode_Static_dict_lut:
    _hx_class_name = "encode.Static_dict_lut"
    __slots__ = ()
    _hx_statics = ["kDictNumBits", "kDictHashMul32", "kStaticDictionaryBuckets", "kStaticDictionaryWords"]

    def __init__(self):
        pass


class encode_Transform:
    _hx_class_name = "encode.Transform"
    __slots__ = ()
    _hx_statics = ["kOmitLastNTransforms"]

    def __init__(self):
        pass


class encode_Write_bits:
    _hx_class_name = "encode.Write_bits"
    __slots__ = ()
    _hx_statics = ["WriteBits", "WriteBitsPrepareStorage"]

    def __init__(self):
        pass

    @staticmethod
    def WriteBits(n_bits,bits,pos,array):
        array_pos_off = ((pos[0] if 0 < len(pos) else None) >> 3)
        bits_reserved_in_first_byte = ((pos[0] if 0 < len(pos) else None) & 7)
        bits = (bits << bits_reserved_in_first_byte)
        _g = array_pos_off
        array_pos_off = (array_pos_off + 1)
        val = (array[_g] | (bits & 255))
        array[_g] = val
        bits_left_to_write = ((n_bits - 8) + bits_reserved_in_first_byte)
        while (bits_left_to_write >= 1):
            bits = HxOverrides.rshift(bits, 8)
            index = array_pos_off
            array_pos_off = (array_pos_off + 1)
            array[index] = (bits & 255)
            bits_left_to_write = (bits_left_to_write - 8)
        array[array_pos_off] = 0
        _hx_local_1 = pos
        _hx_local_2 = 0
        _hx_local_3 = (_hx_local_1[_hx_local_2] if _hx_local_2 >= 0 and _hx_local_2 < len(_hx_local_1) else None)
        python_internal_ArrayImpl._set(_hx_local_1, _hx_local_2, (_hx_local_3 + n_bits))
        (_hx_local_1[_hx_local_2] if _hx_local_2 >= 0 and _hx_local_2 < len(_hx_local_1) else None)

    @staticmethod
    def WriteBitsPrepareStorage(pos,array):
        array[(pos >> 3)] = 0


class encode_backward_references_Pair:
    _hx_class_name = "encode.backward_references.Pair"
    __slots__ = ("first", "second")
    _hx_fields = ["first", "second"]

    def __init__(self,first,second):
        self.first = first
        self.second = second



class encode_backward_references_StartPosQueue:
    _hx_class_name = "encode.backward_references.StartPosQueue"
    __slots__ = ("mask_", "q_", "idx_")
    _hx_fields = ["mask_", "q_", "idx_"]
    _hx_methods = ["Clear", "Push", "size", "GetStartPos"]

    def __init__(self,bits):
        self.mask_ = (((1 << bits)) - 1)
        self.q_ = FunctionMalloc.malloc2__encode_backward_references_Pair(encode_backward_references_Pair,(1 << bits))
        self.idx_ = 0

    def Clear(self):
        self.idx_ = 0

    def Push(self,pos,costdiff):
        val = encode_backward_references_Pair(pos,costdiff)
        self.q_[(self.idx_ & self.mask_)] = val
        i = self.idx_
        while ((i > 0) and ((i > ((self.idx_ - self.mask_))))):
            if (self.q_[(i & self.mask_)].second > self.q_[((i - 1) & self.mask_)].second):
                t1 = self.q_[(i & self.mask_)].first
                t2 = self.q_[(i & self.mask_)].second
                self.q_[(i & self.mask_)].first = self.q_[((i - 1) & self.mask_)].first
                self.q_[(i & self.mask_)].second = self.q_[((i - 1) & self.mask_)].second
                self.q_[((i - 1) & self.mask_)].first = t1
                self.q_[((i - 1) & self.mask_)].second = t2
            i = (i - 1)
        _hx_local_1 = self
        _hx_local_2 = _hx_local_1.idx_
        _hx_local_1.idx_ = (_hx_local_2 + 1)
        _hx_local_1.idx_

    def size(self):
        a = self.idx_
        b = (self.mask_ + 1)
        x = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    def GetStartPos(self,k):
        return self.q_[(((self.idx_ - k) - 1) & self.mask_)].first



class encode_backward_references_ZopfliCostModel:
    _hx_class_name = "encode.backward_references.ZopfliCostModel"
    __slots__ = ("cost_cmd_", "cost_dist_", "literal_costs_", "min_cost_cmd_")
    _hx_fields = ["cost_cmd_", "cost_dist_", "literal_costs_", "min_cost_cmd_"]
    _hx_methods = ["SetFromCommands", "SetFromLiteralCosts", "GetCommandCost", "GetLiteralCosts", "GetMinCostCmd", "Set"]

    def __init__(self):
        self.min_cost_cmd_ = None
        self.literal_costs_ = None
        self.cost_dist_ = None
        self.cost_cmd_ = None

    def SetFromCommands(self,num_bytes,position,ringbuffer,ringbuffer_mask,commands,num_commands,last_insert_len):
        histogram_literal = FunctionMalloc.mallocInt(256)
        histogram_cmd = FunctionMalloc.mallocInt(704)
        histogram_dist = FunctionMalloc.mallocInt(520)
        pos = (position - last_insert_len)
        _g1 = 0
        while (_g1 < num_commands):
            i = _g1
            _g1 = (_g1 + 1)
            inslength = (commands[i] if i >= 0 and i < len(commands) else None).insert_len_
            copylength = (commands[i] if i >= 0 and i < len(commands) else None).copy_len_
            distcode = python_internal_ArrayImpl._get((commands[i] if i >= 0 and i < len(commands) else None).dist_prefix_, 0)
            cmdcode = python_internal_ArrayImpl._get((commands[i] if i >= 0 and i < len(commands) else None).cmd_prefix_, 0)
            val = (histogram_cmd[cmdcode] + 1)
            histogram_cmd[cmdcode] = val
            if (cmdcode >= 128):
                val1 = (histogram_dist[distcode] + 1)
                histogram_dist[distcode] = val1
            _g3 = 0
            while (_g3 < inslength):
                j = _g3
                _g3 = (_g3 + 1)
                _g4 = ringbuffer[((pos + j) & ringbuffer_mask)]
                val2 = (histogram_literal[_g4] + 1)
                histogram_literal[_g4] = val2
            pos = (pos + ((inslength + copylength)))
        cost_literal_ = list()
        self.Set(histogram_literal,cost_literal_)
        cost_literal = (cost_literal_[0] if 0 < len(cost_literal_) else None)
        cost_cmd = [self.cost_cmd_]
        self.Set(histogram_cmd,cost_cmd)
        self.cost_cmd_ = (cost_cmd[0] if 0 < len(cost_cmd) else None)
        cost_dist = [self.cost_dist_]
        self.Set(histogram_dist,cost_dist)
        self.cost_dist_ = (cost_dist[0] if 0 < len(cost_dist) else None)
        self.min_cost_cmd_ = encode_Backward_references.kInfinity
        _g = 0
        while (_g < 704):
            i1 = _g
            _g = (_g + 1)
            a = self.min_cost_cmd_
            b = self.cost_cmd_[i1]
            self.min_cost_cmd_ = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        self.literal_costs_ = [None]*(num_bytes + 1)
        self.literal_costs_[0] = 0.0
        _g11 = 0
        while (_g11 < num_bytes):
            i2 = _g11
            _g11 = (_g11 + 1)
            this1 = self.literal_costs_
            val3 = (self.literal_costs_[i2] + cost_literal[ringbuffer[((position + i2) & ringbuffer_mask)]])
            this1[(i2 + 1)] = val3

    def SetFromLiteralCosts(self,num_bytes,position,literal_cost,literal_cost_mask):
        self.literal_costs_ = FunctionMalloc.mallocFloat((num_bytes + 1))
        self.literal_costs_[0] = 0.0
        if (literal_cost is not None):
            _g1 = 0
            while (_g1 < num_bytes):
                i = _g1
                _g1 = (_g1 + 1)
                this1 = self.literal_costs_
                val = (self.literal_costs_[i] + literal_cost[((position + i) & literal_cost_mask)])
                this1[(i + 1)] = val
        else:
            _g11 = 1
            _g = (num_bytes + 1)
            while (_g11 < _g):
                i1 = _g11
                _g11 = (_g11 + 1)
                self.literal_costs_[i1] = (i1 * 5.4)
        self.cost_cmd_ = [None]*704
        self.cost_dist_ = [None]*520
        _g2 = 0
        while (_g2 < 704):
            i2 = _g2
            _g2 = (_g2 + 1)
            this2 = self.cost_cmd_
            val1 = encode_Fast_log.FastLog2((11 + i2))
            this2[i2] = val1
        _g3 = 0
        while (_g3 < 520):
            i3 = _g3
            _g3 = (_g3 + 1)
            this3 = self.cost_dist_
            val2 = encode_Fast_log.FastLog2((20 + i3))
            this3[i3] = val2
        self.min_cost_cmd_ = encode_Fast_log.FastLog2(11)

    def GetCommandCost(self,dist_code,length_code,insert_length):
        inscode = encode_Command_functions.GetInsertLengthCode(insert_length)
        copycode = encode_Command_functions.GetCopyLengthCode(length_code)
        cmdcode = encode_Command_functions.CombineLengthCodes(inscode,copycode,dist_code)
        insnumextra = python_internal_ArrayImpl._get(encode_Command_functions.insextra, inscode)
        copynumextra = python_internal_ArrayImpl._get(encode_Command_functions.copyextra, copycode)
        dist_symbol = list()
        distextra = list()
        encode_Command_functions.GetDistCode(dist_code,dist_symbol,distextra)
        result = None
        _hx_int = ((insnumextra + copynumextra) + (HxOverrides.rshift((distextra[0] if 0 < len(distextra) else None), 24)))
        if (_hx_int < 0):
            result = (4294967296.0 + _hx_int)
        else:
            result = (_hx_int + 0.0)
        result = (result + self.cost_cmd_[cmdcode])
        aNeg = (cmdcode < 0)
        if (aNeg if ((aNeg != False)) else (cmdcode >= 128)):
            result = (result + self.cost_dist_[(dist_symbol[0] if 0 < len(dist_symbol) else None)])
        return result

    def GetLiteralCosts(self,_hx_from,to):
        return (self.literal_costs_[to] - self.literal_costs_[_hx_from])

    def GetMinCostCmd(self):
        return self.min_cost_cmd_

    def Set(self,histogram,cost):
        python_internal_ArrayImpl._set(cost, 0, [None]*len(histogram))
        sum = 0
        _g1 = 0
        _g = len(histogram)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            sum = (sum + histogram[i])
        log2sum = encode_Fast_log.FastLog2(sum)
        _g11 = 0
        _g2 = len(histogram)
        while (_g11 < _g2):
            i1 = _g11
            _g11 = (_g11 + 1)
            if (histogram[i1] == 0):
                (cost[0] if 0 < len(cost) else None)[i1] = (log2sum + 2)
                continue
            val = (log2sum - encode_Fast_log.FastLog2(histogram[i1]))
            (cost[0] if 0 < len(cost) else None)[i1] = val
            if ((cost[0] if 0 < len(cost) else None)[i1] < 1):
                (cost[0] if 0 < len(cost) else None)[i1] = 1



class encode_backward_references_ZopfliNode:
    _hx_class_name = "encode.backward_references.ZopfliNode"
    __slots__ = ("length", "distance", "distance_code", "distance_cache", "length_code", "insert_length", "cost")
    _hx_fields = ["length", "distance", "distance_code", "distance_cache", "length_code", "insert_length", "cost"]

    def __init__(self):
        self.distance_cache = FunctionMalloc.mallocInt(4)
        self.length = 1
        self.distance = 0
        self.distance_code = 0
        self.length_code = 0
        self.insert_length = 0
        self.cost = encode_Backward_references.kInfinity



class encode_block_splitter_BlockSplitIterator:
    _hx_class_name = "encode.block_splitter.BlockSplitIterator"
    __slots__ = ("split_", "idx_", "type_", "length_")
    _hx_fields = ["split_", "idx_", "type_", "length_"]
    _hx_methods = ["Next"]

    def __init__(self,split):
        self.split_ = split
        self.idx_ = 0
        self.type_ = 0
        self.length_ = 0
        if (len(split.lengths) != 0):
            self.length_ = (split.lengths[0] if 0 < len(split.lengths) else None)

    def Next(self):
        if (self.length_ == 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.idx_
            _hx_local_0.idx_ = (_hx_local_1 + 1)
            _hx_local_0.idx_
            self.type_ = python_internal_ArrayImpl._get(self.split_.types, self.idx_)
            self.length_ = python_internal_ArrayImpl._get(self.split_.lengths, self.idx_)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.length_
        _hx_local_2.length_ = (_hx_local_3 - 1)
        _hx_local_2.length_



class encode_brotli_bit_stream_BlockEncoder:
    _hx_class_name = "encode.brotli_bit_stream.BlockEncoder"
    __slots__ = ("alphabet_size_", "num_block_types_", "block_types_", "block_lengths_", "block_split_code_", "block_ix_", "block_len_", "entropy_ix_", "depths_", "bits_")
    _hx_fields = ["alphabet_size_", "num_block_types_", "block_types_", "block_lengths_", "block_split_code_", "block_ix_", "block_len_", "entropy_ix_", "depths_", "bits_"]
    _hx_methods = ["BuildAndStoreBlockSwitchEntropyCodes", "BuildAndStoreEntropyCodes", "StoreSymbol", "StoreSymbolWithContext"]

    def __init__(self,alphabet_size,num_block_types,block_types,block_lengths):
        self.bits_ = None
        self.depths_ = None
        self.block_split_code_ = encode_brotli_bit_stream_BlockSplitCode()
        self.alphabet_size_ = alphabet_size
        self.num_block_types_ = num_block_types
        self.block_types_ = block_types
        self.block_lengths_ = block_lengths
        self.block_ix_ = 0
        self.block_len_ = (0 if ((len(block_lengths) == 0)) else (block_lengths[0] if 0 < len(block_lengths) else None))
        self.entropy_ix_ = 0

    def BuildAndStoreBlockSwitchEntropyCodes(self,storage_ix,storage):
        encode_Brotli_bit_stream.BuildAndStoreBlockSplitCode(self.block_types_,self.block_lengths_,self.num_block_types_,self.block_split_code_,storage_ix,storage)

    def BuildAndStoreEntropyCodes(self,histograms,storage_ix,storage):
        self.depths_ = FunctionMalloc.mallocUInt((len(histograms) * self.alphabet_size_))
        self.bits_ = FunctionMalloc.mallocUInt((len(histograms) * self.alphabet_size_))
        _g1 = 0
        _g = len(histograms)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            ix = (i * self.alphabet_size_)
            encode_Brotli_bit_stream.BuildAndStoreHuffmanTree((histograms[i] if i >= 0 and i < len(histograms) else None).data_,self.alphabet_size_,self.depths_,ix,self.bits_,ix,storage_ix,storage)

    def StoreSymbol(self,symbol,storage_ix,storage):
        if (self.block_len_ == 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.block_ix_
            _hx_local_0.block_ix_ = (_hx_local_1 + 1)
            _hx_local_0.block_ix_
            self.block_len_ = python_internal_ArrayImpl._get(self.block_lengths_, self.block_ix_)
            self.entropy_ix_ = (python_internal_ArrayImpl._get(self.block_types_, self.block_ix_) * self.alphabet_size_)
            encode_Brotli_bit_stream.StoreBlockSwitch(self.block_split_code_,self.block_ix_,storage_ix,storage)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.block_len_
        _hx_local_2.block_len_ = (_hx_local_3 - 1)
        _hx_local_2.block_len_
        ix = (self.entropy_ix_ + symbol)
        encode_Write_bits.WriteBits(self.depths_[ix],self.bits_[ix],storage_ix,storage)

    def StoreSymbolWithContext(self,kContextBits,symbol,context,context_map,storage_ix,storage):
        if (self.block_len_ == 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.block_ix_
            _hx_local_0.block_ix_ = (_hx_local_1 + 1)
            _hx_local_0.block_ix_
            self.block_len_ = python_internal_ArrayImpl._get(self.block_lengths_, self.block_ix_)
            self.entropy_ix_ = (python_internal_ArrayImpl._get(self.block_types_, self.block_ix_) << kContextBits)
            encode_Brotli_bit_stream.StoreBlockSwitch(self.block_split_code_,self.block_ix_,storage_ix,storage)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.block_len_
        _hx_local_2.block_len_ = (_hx_local_3 - 1)
        _hx_local_2.block_len_
        ix = ((context_map[(self.entropy_ix_ + context)] * self.alphabet_size_) + symbol)
        encode_Write_bits.WriteBits(self.depths_[ix],self.bits_[ix],storage_ix,storage)



class encode_brotli_bit_stream_BlockSplitCode:
    _hx_class_name = "encode.brotli_bit_stream.BlockSplitCode"
    __slots__ = ("type_code", "length_prefix", "length_nextra", "length_extra", "type_depths", "type_bits", "length_depths", "length_bits")
    _hx_fields = ["type_code", "length_prefix", "length_nextra", "length_extra", "type_depths", "type_bits", "length_depths", "length_bits"]

    def __init__(self):
        self.length_bits = None
        self.length_depths = None
        self.type_bits = None
        self.type_depths = None
        self.length_extra = None
        self.length_nextra = None
        self.length_prefix = None
        self.type_code = None



class encode_cluster_HistogramPair:
    _hx_class_name = "encode.cluster.HistogramPair"
    __slots__ = ("idx1", "idx2", "valid", "cost_combo", "cost_diff")
    _hx_fields = ["idx1", "idx2", "valid", "cost_combo", "cost_diff"]

    def __init__(self):
        self.cost_diff = None
        self.cost_combo = None
        self.valid = None
        self.idx2 = None
        self.idx1 = None



class encode_command_Command:
    _hx_class_name = "encode.command.Command"
    __slots__ = ("insert_len_", "copy_len_", "cmd_prefix_", "dist_prefix_", "cmd_extra_", "dist_extra_")
    _hx_fields = ["insert_len_", "copy_len_", "cmd_prefix_", "dist_prefix_", "cmd_extra_", "dist_extra_"]
    _hx_methods = ["Command0", "Command4", "Command1", "DistanceCode", "DistanceContext"]

    def __init__(self):
        self.copy_len_ = None
        self.insert_len_ = None
        self.dist_extra_ = list()
        self.cmd_extra_ = list()
        self.dist_prefix_ = list()
        self.cmd_prefix_ = list()

    def Command0(self):
        pass

    def Command4(self,insertlen,copylen,copylen_code,distance_code):
        self.insert_len_ = insertlen
        self.copy_len_ = copylen
        encode_Command_functions.GetDistCode(distance_code,self.dist_prefix_,self.dist_extra_)
        encode_Command_functions.GetLengthCode(insertlen,copylen_code,(self.dist_prefix_[0] if 0 < len(self.dist_prefix_) else None),self.cmd_prefix_,self.cmd_extra_)

    def Command1(self,insertlen):
        self.insert_len_ = insertlen
        self.copy_len_ = 0
        python_internal_ArrayImpl._set(self.dist_prefix_, 0, 16)
        python_internal_ArrayImpl._set(self.dist_extra_, 0, 0)
        encode_Command_functions.GetLengthCode(insertlen,4,(self.dist_prefix_[0] if 0 < len(self.dist_prefix_) else None),self.cmd_prefix_,self.cmd_extra_)

    def DistanceCode(self):
        a = (self.dist_prefix_[0] if 0 < len(self.dist_prefix_) else None)
        if (False if ((False != ((a < 0)))) else (16 > a)):
            return (self.dist_prefix_[0] if 0 < len(self.dist_prefix_) else None)
        nbits = HxOverrides.rshift((self.dist_extra_[0] if 0 < len(self.dist_extra_) else None), 24)
        return (((((((self.dist_prefix_[0] if 0 < len(self.dist_prefix_) else None) - 12) - (2 * nbits)) << nbits)) + (((self.dist_extra_[0] if 0 < len(self.dist_extra_) else None) & 16777215))) + 12)

    def DistanceContext(self):
        c = ((self.cmd_prefix_[0] if 0 < len(self.cmd_prefix_) else None) & 7)
        r = HxOverrides.rshift((self.cmd_prefix_[0] if 0 < len(self.cmd_prefix_) else None), 6)
        if ((((((r == 0) or ((r == 2))) or ((r == 4))) or ((r == 7)))) and ((c <= 2))):
            return c
        return 3



class encode_encode_BrotliCompressor:
    _hx_class_name = "encode.encode.BrotliCompressor"
    __slots__ = ("params_", "max_backward_distance_", "hashers_", "hash_type_", "input_pos_", "ringbuffer_", "literal_cost_", "literal_cost_mask_", "cmd_buffer_size_", "commands_", "num_commands_", "num_literals_", "last_insert_len_", "last_flush_pos_", "last_processed_pos_", "dist_cache_", "saved_dist_cache_", "last_byte_", "last_byte_bits_", "prev_byte_", "prev_byte2_", "storage_size_", "storage_")
    _hx_fields = ["params_", "max_backward_distance_", "hashers_", "hash_type_", "input_pos_", "ringbuffer_", "literal_cost_", "literal_cost_mask_", "cmd_buffer_size_", "commands_", "num_commands_", "num_literals_", "last_insert_len_", "last_flush_pos_", "last_processed_pos_", "dist_cache_", "saved_dist_cache_", "last_byte_", "last_byte_bits_", "prev_byte_", "prev_byte2_", "storage_size_", "storage_"]
    _hx_methods = ["GetBrotliStorage", "input_block_size", "CopyInputToRingBuffer", "BrotliSetCustomDictionary", "WriteBrotliData", "WriteMetaBlockInternal"]

    def __init__(self,params):
        self.storage_ = None
        self.last_byte_bits_ = None
        self.last_byte_ = None
        self.commands_ = None
        self.cmd_buffer_size_ = None
        self.literal_cost_mask_ = None
        self.literal_cost_ = None
        self.ringbuffer_ = None
        self.hash_type_ = None
        self.max_backward_distance_ = None
        self.saved_dist_cache_ = [None]*4
        self.dist_cache_ = [None]*4
        self.params_ = params
        self.hashers_ = encode_hash_Hashers()
        self.input_pos_ = 0
        self.num_commands_ = 0
        self.num_literals_ = 0
        self.last_insert_len_ = 0
        self.last_flush_pos_ = 0
        self.last_processed_pos_ = 0
        self.prev_byte_ = 0
        self.prev_byte2_ = 0
        self.storage_size_ = 0
        b = self.params_.quality
        x = (1 if (python_lib_Math.isnan(1)) else (b if (python_lib_Math.isnan(b)) else max(1,b)))
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        self.params_.quality = tmp
        if (self.params_.lgwin < encode_Encode.kMinWindowBits):
            self.params_.lgwin = encode_Encode.kMinWindowBits
        elif (self.params_.lgwin > encode_Encode.kMaxWindowBits):
            self.params_.lgwin = encode_Encode.kMaxWindowBits
        if (self.params_.lgblock == 0):
            self.params_.lgblock = (14 if ((self.params_.quality < encode_Encode.kMinQualityForBlockSplit)) else 16)
            if ((self.params_.quality >= 9) and ((self.params_.lgwin > self.params_.lgblock))):
                b1 = self.params_.lgwin
                x1 = (21 if (python_lib_Math.isnan(21)) else (b1 if (python_lib_Math.isnan(b1)) else min(21,b1)))
                tmp1 = None
                try:
                    tmp1 = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    tmp1 = None
                self.params_.lgblock = tmp1
        else:
            a = encode_Encode.kMaxInputBlockBits
            a1 = encode_Encode.kMinInputBlockBits
            b2 = self.params_.lgblock
            b3 = (a1 if (python_lib_Math.isnan(a1)) else (b2 if (python_lib_Math.isnan(b2)) else max(a1,b2)))
            x2 = (a if (python_lib_Math.isnan(a)) else (b3 if (python_lib_Math.isnan(b3)) else min(a,b3)))
            tmp2 = None
            try:
                tmp2 = int(x2)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                tmp2 = None
            self.params_.lgblock = tmp2
        self.max_backward_distance_ = (((1 << self.params_.lgwin)) - 16)
        a2 = (self.params_.lgwin + 1)
        b4 = (self.params_.lgblock + 1)
        x3 = (a2 if (python_lib_Math.isnan(a2)) else (b4 if (python_lib_Math.isnan(b4)) else max(a2,b4)))
        ringbuffer_bits = None
        try:
            ringbuffer_bits = int(x3)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e3 = _hx_e1
            ringbuffer_bits = None
        self.ringbuffer_ = encode_RingBuffer(ringbuffer_bits,self.params_.lgblock)
        if (self.params_.quality > 9):
            self.literal_cost_mask_ = (((1 << self.params_.lgblock)) - 1)
            self.literal_cost_ = FunctionMalloc.mallocFloat((self.literal_cost_mask_ + 1))
        b5 = (1 << self.params_.lgblock)
        x4 = (262144 if (python_lib_Math.isnan(262144)) else (b5 if (python_lib_Math.isnan(b5)) else max(262144,b5)))
        tmp3 = None
        try:
            tmp3 = int(x4)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e4 = _hx_e1
            tmp3 = None
        self.cmd_buffer_size_ = tmp3
        self.commands_ = list()
        if (self.params_.lgwin == 16):
            self.last_byte_ = 0
            self.last_byte_bits_ = 1
        elif (self.params_.lgwin == 17):
            self.last_byte_ = 1
            self.last_byte_bits_ = 7
        else:
            self.last_byte_ = (((self.params_.lgwin - 17) << 1) | 1)
            self.last_byte_bits_ = 4
        self.dist_cache_[0] = 4
        self.dist_cache_[1] = 11
        self.dist_cache_[2] = 15
        self.dist_cache_[3] = 16
        DefaultFunctions.memcpy_Int(self.saved_dist_cache_,0,self.dist_cache_,0,len(self.dist_cache_))
        b6 = self.params_.quality
        x5 = (9 if (python_lib_Math.isnan(9)) else (b6 if (python_lib_Math.isnan(b6)) else min(9,b6)))
        tmp4 = None
        try:
            tmp4 = int(x5)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e5 = _hx_e1
            tmp4 = None
        self.hash_type_ = tmp4
        self.hashers_.Init(self.hash_type_)

    def GetBrotliStorage(self,size):
        if (self.storage_size_ < size):
            self.storage_ = FunctionMalloc.mallocUInt(size)
            self.storage_size_ = size
        return self.storage_

    def input_block_size(self):
        return (1 << self.params_.lgblock)

    def CopyInputToRingBuffer(self,input_size,input_buffer):
        self.ringbuffer_.Write(input_buffer,input_size)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.input_pos_
        _hx_local_0.input_pos_ = (_hx_local_1 + input_size)
        _hx_local_0.input_pos_
        pos = self.ringbuffer_.position()
        if (pos <= self.ringbuffer_.mask()):
            DefaultFunctions.memset_UInt(self.ringbuffer_.start(),pos,0,3)

    def BrotliSetCustomDictionary(self,size,_hx_dict):
        self.CopyInputToRingBuffer(size,_hx_dict)
        self.last_flush_pos_ = size
        self.last_processed_pos_ = size
        if (size > 0):
            self.prev_byte_ = _hx_dict[(size - 1)]
        if (size > 1):
            self.prev_byte2_ = _hx_dict[(size - 2)]
        self.hashers_.PrependCustomDictionary(self.hash_type_,size,_hx_dict)

    def WriteBrotliData(self,is_last,force_flush,out_size,output):
        _hx_bytes = (self.input_pos_ - self.last_processed_pos_)
        data = self.ringbuffer_.start()
        mask = self.ringbuffer_.mask()
        if (_hx_bytes > self.input_block_size()):
            return False
        utf8_mode = ((self.params_.quality >= 9) and encode_Encode.IsMostlyUTF8(data,(self.last_processed_pos_ & mask),_hx_bytes,encode_Encode.kMinUTF8Ratio))
        if (self.literal_cost_ is not None):
            if utf8_mode:
                encode_Literal_cost.EstimateBitCostsForLiteralsUTF8(self.last_processed_pos_,_hx_bytes,mask,self.literal_cost_mask_,data,self.literal_cost_)
            else:
                encode_Literal_cost.EstimateBitCostsForLiterals(self.last_processed_pos_,_hx_bytes,mask,self.literal_cost_mask_,data,self.literal_cost_)
        last_insert_len = [self.last_insert_len_]
        num_commands = [self.num_commands_]
        num_literals = [self.num_literals_]
        encode_Backward_references.CreateBackwardReferences(_hx_bytes,self.last_processed_pos_,data,mask,self.literal_cost_,self.literal_cost_mask_,self.max_backward_distance_,self.params_.quality,self.hashers_,self.hash_type_,self.dist_cache_,last_insert_len,self.commands_,(num_commands[0] if 0 < len(num_commands) else None),num_commands,num_literals)
        self.last_insert_len_ = (last_insert_len[0] if 0 < len(last_insert_len) else None)
        self.num_commands_ = (num_commands[0] if 0 < len(num_commands) else None)
        self.num_literals_ = (num_literals[0] if 0 < len(num_literals) else None)
        a = (mask + 1)
        b = (1 << encode_Encode.kMaxInputBlockBits)
        x = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        max_length = None
        try:
            max_length = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            max_length = None
        if (((((not is_last) and (not force_flush)) and (((self.params_.quality >= encode_Encode.kMinQualityForBlockSplit) or (((self.num_literals_ + self.num_commands_) < 12287))))) and (((self.num_commands_ + ((self.input_block_size() >> 1))) < self.cmd_buffer_size_))) and (((self.input_pos_ + self.input_block_size()) <= ((self.last_flush_pos_ + max_length))))):
            self.last_processed_pos_ = self.input_pos_
            python_internal_ArrayImpl._set(out_size, 0, 0)
            return True
        if (self.last_insert_len_ > 0):
            command = encode_command_Command()
            command.Command1(self.last_insert_len_)
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.num_commands_
                _hx_local_0.num_commands_ = (_hx_local_1 + 1)
                return _hx_local_1
            python_internal_ArrayImpl._set(self.commands_, _hx_local_2(), command)
            _hx_local_3 = self
            _hx_local_4 = _hx_local_3.num_literals_
            _hx_local_3.num_literals_ = (_hx_local_4 + self.last_insert_len_)
            _hx_local_3.num_literals_
            self.last_insert_len_ = 0
        return self.WriteMetaBlockInternal(is_last,utf8_mode,out_size,output)

    def WriteMetaBlockInternal(self,is_last,utf8_mode,out_size,output):
        _hx_bytes = (self.input_pos_ - self.last_flush_pos_)
        data = self.ringbuffer_.start()
        mask = self.ringbuffer_.mask()
        storage = self.GetBrotliStorage(((2 * _hx_bytes) + 500))
        val = self.last_byte_
        storage[0] = val
        storage_ix = [self.last_byte_bits_]
        uncompressed = False
        if (self.num_commands_ < ((((_hx_bytes >> 8)) + 2))):
            if (self.num_literals_ > ((0.99 * _hx_bytes))):
                literal_histo = FunctionMalloc.mallocInt(256)
                kBitCostThreshold = ((_hx_bytes * 7.92) / 13)
                i = self.last_flush_pos_
                while (i < self.input_pos_):
                    _g = data[(i & mask)]
                    val1 = (literal_histo[_g] + 1)
                    literal_histo[_g] = val1
                    i = (i + 13)
                if (encode_Bit_cost.BitsEntropy(literal_histo,0,256) > kBitCostThreshold):
                    uncompressed = True
        if (_hx_bytes == 0):
            if (not encode_Brotli_bit_stream.StoreCompressedMetaBlockHeader(is_last,0,storage_ix,storage)):
                return False
            python_internal_ArrayImpl._set(storage_ix, 0, (((storage_ix[0] if 0 < len(storage_ix) else None) + 7) & -8))
        elif uncompressed:
            DefaultFunctions.memcpy_Int(self.dist_cache_,0,self.saved_dist_cache_,0,len(self.dist_cache_))
            if (not encode_Brotli_bit_stream.StoreUncompressedMetaBlock(is_last,data,self.last_flush_pos_,mask,_hx_bytes,storage_ix,storage,0)):
                return False
        else:
            num_direct_distance_codes = 0
            distance_postfix_bits = 0
            if ((self.params_.quality > 9) and ((self.params_.mode == 2))):
                num_direct_distance_codes = 12
                distance_postfix_bits = 1
                encode_Encode.RecomputeDistancePrefixes(self.commands_,self.num_commands_,12,1)
            if (self.params_.quality < encode_Encode.kMinQualityForBlockSplit):
                if (not encode_Brotli_bit_stream.StoreMetaBlockTrivial(data,self.last_flush_pos_,_hx_bytes,mask,is_last,self.commands_,self.num_commands_,storage_ix,storage,0)):
                    return False
            else:
                mb = encode_metablock_MetaBlockSplit()
                literal_context_mode = [(2 if utf8_mode else 3)]
                if (self.params_.quality <= 9):
                    num_literal_contexts = [1]
                    literal_context_map = [[-1]]
                    encode_Encode.DecideOverLiteralContextModeling(data,self.last_flush_pos_,_hx_bytes,mask,self.params_.quality,literal_context_mode,num_literal_contexts,literal_context_map)
                    if (python_internal_ArrayImpl._get((literal_context_map[0] if 0 < len(literal_context_map) else None), 0) == -1):
                        encode_Metablock.BuildMetaBlockGreedy(data,self.last_flush_pos_,mask,self.commands_,self.num_commands_,mb)
                    else:
                        encode_Metablock.BuildMetaBlockGreedyWithContexts(data,self.last_flush_pos_,mask,self.prev_byte_,self.prev_byte2_,(literal_context_mode[0] if 0 < len(literal_context_mode) else None),(num_literal_contexts[0] if 0 < len(num_literal_contexts) else None),(literal_context_map[0] if 0 < len(literal_context_map) else None),self.commands_,self.num_commands_,mb)
                else:
                    encode_Metablock.BuildMetaBlock(data,self.last_flush_pos_,mask,self.prev_byte_,self.prev_byte2_,self.commands_,self.num_commands_,(literal_context_mode[0] if 0 < len(literal_context_mode) else None),mb)
                if (self.params_.quality >= encode_Encode.kMinQualityForOptimizeHistograms):
                    encode_Metablock.OptimizeHistograms(num_direct_distance_codes,distance_postfix_bits,mb)
                if (not encode_Brotli_bit_stream.StoreMetaBlock(data,self.last_flush_pos_,_hx_bytes,mask,self.prev_byte_,self.prev_byte2_,is_last,num_direct_distance_codes,distance_postfix_bits,(literal_context_mode[0] if 0 < len(literal_context_mode) else None),self.commands_,self.num_commands_,mb,storage_ix,storage)):
                    return False
            if ((_hx_bytes + 4) < (((storage_ix[0] if 0 < len(storage_ix) else None) >> 3))):
                DefaultFunctions.memcpy_Int(self.dist_cache_,0,self.saved_dist_cache_,0,len(self.dist_cache_))
                val2 = self.last_byte_
                storage[0] = val2
                python_internal_ArrayImpl._set(storage_ix, 0, self.last_byte_bits_)
                if (not encode_Brotli_bit_stream.StoreUncompressedMetaBlock(is_last,data,self.last_flush_pos_,mask,_hx_bytes,storage_ix,storage,0)):
                    return False
        self.last_byte_ = storage[((storage_ix[0] if 0 < len(storage_ix) else None) >> 3)]
        self.last_byte_bits_ = ((storage_ix[0] if 0 < len(storage_ix) else None) & 7)
        self.last_flush_pos_ = self.input_pos_
        self.last_processed_pos_ = self.input_pos_
        self.prev_byte_ = data[((self.last_flush_pos_ - 1) & mask)]
        self.prev_byte2_ = data[((self.last_flush_pos_ - 2) & mask)]
        self.num_commands_ = 0
        self.num_literals_ = 0
        DefaultFunctions.memcpy_Int(self.saved_dist_cache_,0,self.dist_cache_,0,len(self.dist_cache_))
        python_internal_ArrayImpl._set(output, 0, storage)
        python_internal_ArrayImpl._set(out_size, 0, ((storage_ix[0] if 0 < len(storage_ix) else None) >> 3))
        return True



class encode_encode_BrotliParams:
    _hx_class_name = "encode.encode.BrotliParams"
    __slots__ = ("mode", "quality", "lgwin", "lgblock", "enable_dictionary", "enable_transforms", "greedy_block_split", "enable_context_modeling")
    _hx_fields = ["mode", "quality", "lgwin", "lgblock", "enable_dictionary", "enable_transforms", "greedy_block_split", "enable_context_modeling"]

    def __init__(self):
        self.mode = 0
        self.quality = 11
        self.lgwin = 22
        self.lgblock = 0
        self.enable_dictionary = True
        self.enable_transforms = False
        self.greedy_block_split = False
        self.enable_context_modeling = True



class encode_entropy_encode_EntropyCode:
    _hx_class_name = "encode.entropy_encode.EntropyCode"
    __slots__ = ("depth_", "bits_", "count_", "symbols_")
    _hx_fields = ["depth_", "bits_", "count_", "symbols_"]

    def __init__(self,kSize):
        self.count_ = None
        self.symbols_ = FunctionMalloc.mallocUInt(4)
        self.depth_ = FunctionMalloc.mallocUInt(kSize)
        self.bits_ = FunctionMalloc.mallocUInt(kSize)



class encode_entropy_encode_HuffmanTree:
    _hx_class_name = "encode.entropy_encode.HuffmanTree"
    __slots__ = ("total_count_", "index_left_", "index_right_or_value_")
    _hx_fields = ["total_count_", "index_left_", "index_right_or_value_"]
    _hx_methods = ["HuffmanTree3"]

    def __init__(self):
        self.index_right_or_value_ = None
        self.index_left_ = None
        self.total_count_ = None

    def HuffmanTree3(self,count,left,right):
        self.total_count_ = count
        self.index_left_ = left
        self.index_right_or_value_ = right



class encode_hash_BackwardMatch:
    _hx_class_name = "encode.hash.BackwardMatch"
    __slots__ = ("distance", "length_and_code")
    _hx_fields = ["distance", "length_and_code"]
    _hx_methods = ["BackwardMatch0", "BackwardMatch2", "BackwardMatch3", "length", "length_code"]

    def __init__(self):
        self.length_and_code = None
        self.distance = None

    def BackwardMatch0(self):
        self.distance = 0
        self.length_and_code = 0

    def BackwardMatch2(self,dist,_hx_len):
        self.distance = dist
        self.length_and_code = (_hx_len << 5)

    def BackwardMatch3(self,dist,_hx_len,len_code):
        self.distance = dist
        self.length_and_code = ((_hx_len << 5) | ((0 if ((_hx_len == len_code)) else len_code)))

    def length(self):
        return (self.length_and_code >> 5)

    def length_code(self):
        code = (self.length_and_code & 31)
        if (code > 0):
            return code
        else:
            return self.length()



class encode_hash_HashLongestMatch:
    _hx_class_name = "encode.hash.HashLongestMatch"
    __slots__ = ("kBucketBits", "kBlockBits", "kNumLastDistancesToCheck", "kBucketSize", "kBlockSize", "kBlockMask", "num_", "buckets_", "num_dict_lookups_", "num_dict_matches_")
    _hx_fields = ["kBucketBits", "kBlockBits", "kNumLastDistancesToCheck", "kBucketSize", "kBlockSize", "kBlockMask", "num_", "buckets_", "num_dict_lookups_", "num_dict_matches_"]
    _hx_methods = ["Reset", "Store", "FindLongestMatch", "FindAllMatches"]

    def __init__(self,kBucketBits,kBlockBits,kNumLastDistancesToCheck):
        self.num_dict_matches_ = None
        self.num_dict_lookups_ = None
        self.buckets_ = None
        self.num_ = None
        self.kBucketBits = kBucketBits
        self.kBlockBits = kBlockBits
        self.kNumLastDistancesToCheck = kNumLastDistancesToCheck
        self.kBucketSize = (1 << kBucketBits)
        self.kBlockSize = (1 << kBlockBits)
        self.kBlockMask = (((1 << kBlockBits)) - 1)
        self.num_ = [None]*self.kBucketSize
        self.buckets_ = [None]*self.kBucketSize
        _g1 = 0
        _g = self.kBucketSize
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            this1 = self.buckets_
            this2 = [None]*self.kBlockSize
            this1[i] = this2
        self.Reset()

    def Reset(self):
        DefaultFunctions.memset_UInt(self.num_,0,0,len(self.num_))
        self.num_dict_lookups_ = 0
        self.num_dict_matches_ = 0

    def Store(self,data,data_off,ix):
        key = encode_Hash.Hash_(self.kBucketBits,data,data_off)
        minor_ix = (self.num_[key] & self.kBlockMask)
        if (self.buckets_[key] is None):
            this1 = self.buckets_
            this2 = [None]*self.kBlockSize
            this1[key] = this2
        self.buckets_[key][minor_ix] = ix
        this3 = self.num_
        val = (self.num_[key] + 1)
        this3[key] = val

    def FindLongestMatch(self,data,ring_buffer_mask,distance_cache,cur_ix,max_length,max_backward,best_len_out,best_len_code_out,best_distance_out,best_score_out):
        python_internal_ArrayImpl._set(best_len_code_out, 0, 0)
        cur_ix_masked = (cur_ix & ring_buffer_mask)
        match_found = False
        best_score = (best_score_out[0] if 0 < len(best_score_out) else None)
        best_len = (best_len_out[0] if 0 < len(best_len_out) else None)
        python_internal_ArrayImpl._set(best_len_out, 0, 0)
        _g1 = 0
        _g = self.kNumLastDistancesToCheck
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            backward = (distance_cache[python_internal_ArrayImpl._get(encode_Hash.kDistanceCacheIndex, i)] + python_internal_ArrayImpl._get(encode_Hash.kDistanceCacheOffset, i))
            prev_ix = (cur_ix - backward)
            aNeg = (prev_ix < 0)
            if (aNeg if ((aNeg != ((cur_ix < 0)))) else (prev_ix >= cur_ix)):
                continue
            aNeg1 = (backward < 0)
            if (aNeg1 if ((aNeg1 != ((max_backward < 0)))) else (backward > max_backward)):
                continue
            prev_ix = (prev_ix & ring_buffer_mask)
            tmp = None
            tmp1 = None
            if ((cur_ix_masked + best_len) <= ring_buffer_mask):
                a = (prev_ix + best_len)
                aNeg2 = (a < 0)
                if (aNeg2 != ((ring_buffer_mask < 0))):
                    tmp1 = aNeg2
                else:
                    tmp1 = (a > ring_buffer_mask)
            else:
                tmp1 = True
            if (not tmp1):
                tmp = (data[(cur_ix_masked + best_len)] != data[(prev_ix + best_len)])
            else:
                tmp = True
            if tmp:
                continue
            _hx_len = encode_Find_match_length.FindMatchLengthWithLimit(data,prev_ix,data,cur_ix_masked,max_length)
            if ((_hx_len >= 3) or (((_hx_len == 2) and ((i < 2))))):
                score = encode_Hash.BackwardReferenceScoreUsingLastDistance(_hx_len,i)
                if (best_score < score):
                    best_score = score
                    best_len = _hx_len
                    python_internal_ArrayImpl._set(best_len_out, 0, _hx_len)
                    python_internal_ArrayImpl._set(best_len_code_out, 0, _hx_len)
                    python_internal_ArrayImpl._set(best_distance_out, 0, backward)
                    python_internal_ArrayImpl._set(best_score_out, 0, score)
                    match_found = True
        key = encode_Hash.Hash_(self.kBucketBits,data,cur_ix_masked)
        bucket = self.buckets_[key]
        down = None
        a1 = self.num_[key]
        b = self.kBlockSize
        aNeg3 = (a1 < 0)
        if (aNeg3 if ((aNeg3 != ((b < 0)))) else (a1 > b)):
            down = (self.num_[key] - self.kBlockSize)
        else:
            down = 0
        i1 = (self.num_[key] - 1)
        while (i1 >= down):
            prev_ix1 = bucket[(i1 & self.kBlockMask)]
            if ((prev_ix1 != -1) and ((prev_ix1 >= 0))):
                backward1 = (cur_ix - prev_ix1)
                aNeg4 = (backward1 < 0)
                if (aNeg4 if ((aNeg4 != ((max_backward < 0)))) else (backward1 > max_backward)):
                    break
                prev_ix1 = (prev_ix1 & ring_buffer_mask)
                if ((((cur_ix_masked + best_len) > ring_buffer_mask) or (((prev_ix1 + best_len) > ring_buffer_mask))) or ((data[(cur_ix_masked + best_len)] != data[(prev_ix1 + best_len)]))):
                    i1 = (i1 - 1)
                    continue
                len1 = encode_Find_match_length.FindMatchLengthWithLimit(data,prev_ix1,data,cur_ix_masked,max_length)
                if (len1 >= 4):
                    score1 = encode_Hash.BackwardReferenceScore(len1,backward1)
                    if (best_score < score1):
                        best_score = score1
                        best_len = len1
                        python_internal_ArrayImpl._set(best_len_out, 0, len1)
                        python_internal_ArrayImpl._set(best_len_code_out, 0, len1)
                        python_internal_ArrayImpl._set(best_distance_out, 0, backward1)
                        python_internal_ArrayImpl._set(best_score_out, 0, score1)
                        match_found = True
            i1 = (i1 - 1)
        if ((not match_found) and ((self.num_dict_matches_ >= ((self.num_dict_lookups_ >> 7))))):
            key1 = (encode_Hash.Hash_(14,data,cur_ix_masked) << 1)
            _g2 = 0
            while (_g2 < 2):
                _g2 = (_g2 + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.num_dict_lookups_
                _hx_local_4.num_dict_lookups_ = (_hx_local_5 + 1)
                _hx_local_4.num_dict_lookups_
                v = python_internal_ArrayImpl._get(encode_Dictionary_hash.kStaticDictionaryHash, key1)
                aNeg5 = (v < 0)
                if (aNeg5 if ((aNeg5 != False)) else (v > 0)):
                    len2 = (v & 31)
                    dist = HxOverrides.rshift(v, 5)
                    aNeg6 = (max_length < 0)
                    if (aNeg6 if ((aNeg6 != ((len2 < 0)))) else (max_length >= len2)):
                        if (encode_Find_match_length.FindMatchLengthWithLimit(data,cur_ix_masked,encode_Dictionary.kBrotliDictionary,(python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionaryOffsetsByLength, len2) + ((len2 * dist))),len2) == len2):
                            backward2 = ((max_backward + dist) + 1)
                            score2 = encode_Hash.BackwardReferenceScore(len2,backward2)
                            if (best_score < score2):
                                _hx_local_6 = self
                                _hx_local_7 = _hx_local_6.num_dict_matches_
                                _hx_local_6.num_dict_matches_ = (_hx_local_7 + 1)
                                _hx_local_6.num_dict_matches_
                                python_internal_ArrayImpl._set(best_len_out, 0, len2)
                                python_internal_ArrayImpl._set(best_len_code_out, 0, len2)
                                python_internal_ArrayImpl._set(best_distance_out, 0, backward2)
                                python_internal_ArrayImpl._set(best_score_out, 0, score2)
                                match_found = True
                                break
                key1 = (key1 + 1)
        return match_found

    def FindAllMatches(self,data,ring_buffer_mask,cur_ix,max_length,max_backward,num_matches,num_matches_off,matches,matches_off):
        orig_matches = matches
        orig_matches_off = matches_off
        cur_ix_masked = (cur_ix & ring_buffer_mask)
        best_len = 1
        stop = (cur_ix - 64)
        if (stop < 0):
            stop = 0
        i = (cur_ix - 1)
        while ((i > stop) and ((best_len <= 2))):
            prev_ix = i
            backward = (cur_ix - prev_ix)
            aNeg = (backward < 0)
            if (aNeg if ((aNeg != ((max_backward < 0)))) else (backward > max_backward)):
                break
            prev_ix = (prev_ix & ring_buffer_mask)
            if ((data[cur_ix_masked] != data[prev_ix]) or ((data[(cur_ix_masked + 1)] != data[(prev_ix + 1)]))):
                i = (i - 1)
                continue
            _hx_len = encode_Find_match_length.FindMatchLengthWithLimit(data,prev_ix,data,cur_ix_masked,max_length)
            if (_hx_len > best_len):
                best_len = _hx_len
                if (_hx_len > 325):
                    matches = orig_matches
                match = encode_hash_BackwardMatch()
                match.BackwardMatch2(backward,_hx_len)
                tmp = matches_off
                matches_off = (matches_off + 1)
                python_internal_ArrayImpl._set(matches, tmp, match)
            i = (i - 1)
        key = encode_Hash.Hash_(self.kBucketBits,data,cur_ix_masked)
        bucket = self.buckets_[key]
        down = None
        a = self.num_[key]
        b = self.kBlockSize
        aNeg1 = (a < 0)
        if (aNeg1 if ((aNeg1 != ((b < 0)))) else (a > b)):
            down = (self.num_[key] - self.kBlockSize)
        else:
            down = 0
        i1 = (self.num_[key] - 1)
        while (i1 >= down):
            prev_ix1 = bucket[(i1 & self.kBlockMask)]
            if (prev_ix1 >= 0):
                backward1 = (cur_ix - prev_ix1)
                aNeg2 = (backward1 < 0)
                if (aNeg2 if ((aNeg2 != ((max_backward < 0)))) else (backward1 > max_backward)):
                    break
                prev_ix1 = (prev_ix1 & ring_buffer_mask)
                if ((((cur_ix_masked + best_len) > ring_buffer_mask) or (((prev_ix1 + best_len) > ring_buffer_mask))) or ((data[(cur_ix_masked + best_len)] != data[(prev_ix1 + best_len)]))):
                    i1 = (i1 - 1)
                    continue
                len1 = encode_Find_match_length.FindMatchLengthWithLimit(data,prev_ix1,data,cur_ix_masked,max_length)
                if (len1 > best_len):
                    best_len = len1
                    if (len1 > 325):
                        matches_off = orig_matches_off
                    match1 = encode_hash_BackwardMatch()
                    match1.BackwardMatch2(backward1,len1)
                    tmp1 = matches_off
                    matches_off = (matches_off + 1)
                    python_internal_ArrayImpl._set(matches, tmp1, match1)
            i1 = (i1 - 1)
        dict_matches = FunctionMalloc.mallocInt(38)
        DefaultFunctions.memset_Int(dict_matches,0,268435455,len(dict_matches))
        b1 = (best_len + 1)
        x = (4 if (python_lib_Math.isnan(4)) else (b1 if (python_lib_Math.isnan(b1)) else max(4,b1)))
        minlen = None
        try:
            minlen = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            minlen = None
        if encode_Static_dict.FindAllStaticDictionaryMatches(data,cur_ix_masked,minlen,dict_matches,0):
            b2 = None
            _hx_int = max_length
            if (_hx_int < 0):
                b2 = (4294967296.0 + _hx_int)
            else:
                b2 = (_hx_int + 0.0)
            x1 = (37 if (python_lib_Math.isnan(37)) else (b2 if (python_lib_Math.isnan(b2)) else min(37,b2)))
            maxlen = None
            try:
                maxlen = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                maxlen = None
            _g1 = minlen
            _g = maxlen
            while (_g1 < _g):
                l = _g1
                _g1 = (_g1 + 1)
                dict_id = dict_matches[l]
                if (dict_id < 268435455):
                    match2 = encode_hash_BackwardMatch()
                    match2.BackwardMatch3(((max_backward + ((dict_id >> 5))) + 1),l,(dict_id & 31))
                    tmp2 = matches_off
                    matches_off = (matches_off + 1)
                    python_internal_ArrayImpl._set(matches, tmp2, match2)
        val = (num_matches[num_matches_off] + ((matches_off - orig_matches_off)))
        num_matches[num_matches_off] = val



class encode_hash_HashLongestMatchQuickly:
    _hx_class_name = "encode.hash.HashLongestMatchQuickly"
    __slots__ = ("kBucketBits", "kBucketSweep", "kUseDictionary", "kBucketSize", "buckets_", "num_dict_lookups_", "num_dict_matches_")
    _hx_fields = ["kBucketBits", "kBucketSweep", "kUseDictionary", "kBucketSize", "buckets_", "num_dict_lookups_", "num_dict_matches_"]
    _hx_methods = ["Reset", "Store", "FindLongestMatch"]

    def __init__(self,kBucketBits,kBucketSweep,kUseDictionary):
        self.num_dict_matches_ = None
        self.num_dict_lookups_ = None
        self.buckets_ = None
        self.kBucketBits = kBucketBits
        self.kBucketSweep = kBucketSweep
        self.kUseDictionary = kUseDictionary
        self.kBucketSize = (1 << kBucketBits)
        self.buckets_ = [None]*(self.kBucketSize + kBucketSweep)
        self.Reset()

    def Reset(self):
        DefaultFunctions.memset_UInt(self.buckets_,0,0,len(self.buckets_))
        self.num_dict_lookups_ = 0
        self.num_dict_matches_ = 0

    def Store(self,data,data_off,ix):
        key = encode_Hash.Hash_(self.kBucketBits,data,data_off)
        self.buckets_[(key + HxOverrides.mod(((ix >> 3)), self.kBucketSweep))] = ix

    def FindLongestMatch(self,ring_buffer,ring_buffer_mask,distance_cache,cur_ix,max_length,max_backward,best_len_out,best_len_code_out,best_distance_out,best_score_out):
        best_len_in = (best_len_out[0] if 0 < len(best_len_out) else None)
        cur_ix_masked = (cur_ix & ring_buffer_mask)
        compare_char = ring_buffer[(cur_ix_masked + best_len_in)]
        best_score = (best_score_out[0] if 0 < len(best_score_out) else None)
        best_len = best_len_in
        backward = distance_cache[0]
        prev_ix = (cur_ix - backward)
        match_found = False
        aNeg = (cur_ix < 0)
        if (aNeg if ((aNeg != ((prev_ix < 0)))) else (cur_ix > prev_ix)):
            prev_ix = (prev_ix & ring_buffer_mask)
            if (compare_char == ring_buffer[(prev_ix + best_len_in)]):
                _hx_len = encode_Find_match_length.FindMatchLengthWithLimit(ring_buffer,prev_ix,ring_buffer,cur_ix_masked,max_length)
                if (_hx_len >= 4):
                    best_score = encode_Hash.BackwardReferenceScoreUsingLastDistance(_hx_len,0)
                    best_len = _hx_len
                    python_internal_ArrayImpl._set(best_len_out, 0, _hx_len)
                    python_internal_ArrayImpl._set(best_len_code_out, 0, _hx_len)
                    python_internal_ArrayImpl._set(best_distance_out, 0, backward)
                    python_internal_ArrayImpl._set(best_score_out, 0, best_score)
                    compare_char = ring_buffer[(cur_ix_masked + _hx_len)]
                    if (self.kBucketSweep == 1):
                        return True
                    else:
                        match_found = True
        key = encode_Hash.Hash_(self.kBucketBits,ring_buffer,cur_ix_masked)
        if (self.kBucketSweep == 1):
            prev_ix = self.buckets_[key]
            backward = (cur_ix - prev_ix)
            prev_ix = (prev_ix & ring_buffer_mask)
            if (compare_char != ring_buffer[(prev_ix + best_len_in)]):
                return False
            if ((backward == 0) or ((backward > max_backward))):
                return False
            len1 = encode_Find_match_length.FindMatchLengthWithLimit(ring_buffer,prev_ix,ring_buffer,cur_ix_masked,max_length)
            if (len1 >= 4):
                python_internal_ArrayImpl._set(best_len_out, 0, len1)
                python_internal_ArrayImpl._set(best_len_code_out, 0, len1)
                python_internal_ArrayImpl._set(best_distance_out, 0, backward)
                python_internal_ArrayImpl._set(best_score_out, 0, encode_Hash.BackwardReferenceScore(len1,backward))
                return True
        else:
            bucket = self.buckets_
            bucket_off = (0 + key)
            _g1 = 0
            _g = self.kBucketSweep
            while (_g1 < _g):
                _g1 = (_g1 + 1)
                index = bucket_off
                bucket_off = (bucket_off + 1)
                prev_ix = bucket[index]
                backward1 = (cur_ix - prev_ix)
                prev_ix = (prev_ix & ring_buffer_mask)
                if (compare_char != ring_buffer[(prev_ix + best_len)]):
                    continue
                if ((backward1 == 0) or ((backward1 > max_backward))):
                    continue
                len2 = encode_Find_match_length.FindMatchLengthWithLimit(ring_buffer,prev_ix,ring_buffer,cur_ix_masked,max_length)
                if (len2 >= 4):
                    score = encode_Hash.BackwardReferenceScore(len2,backward1)
                    if (best_score < score):
                        best_score = score
                        best_len = len2
                        python_internal_ArrayImpl._set(best_len_out, 0, len2)
                        python_internal_ArrayImpl._set(best_len_code_out, 0, len2)
                        python_internal_ArrayImpl._set(best_distance_out, 0, backward1)
                        python_internal_ArrayImpl._set(best_score_out, 0, score)
                        compare_char = ring_buffer[(cur_ix_masked + len2)]
                        match_found = True
        if ((self.kUseDictionary and (not match_found)) and ((self.num_dict_matches_ >= ((self.num_dict_lookups_ >> 7))))):
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.num_dict_lookups_
            _hx_local_1.num_dict_lookups_ = (_hx_local_2 + 1)
            _hx_local_1.num_dict_lookups_
            key1 = (encode_Hash.Hash_(14,ring_buffer,cur_ix_masked) << 1)
            v = python_internal_ArrayImpl._get(encode_Dictionary_hash.kStaticDictionaryHash, key1)
            aNeg1 = (v < 0)
            if (aNeg1 if ((aNeg1 != False)) else (v > 0)):
                len3 = (v & 31)
                dist = HxOverrides.rshift(v, 5)
                if (len3 <= max_length):
                    if (encode_Find_match_length.FindMatchLengthWithLimit(ring_buffer,cur_ix_masked,encode_Dictionary.kBrotliDictionary,(python_internal_ArrayImpl._get(encode_Dictionary.kBrotliDictionaryOffsetsByLength, len3) + ((len3 * dist))),len3) == len3):
                        backward2 = ((max_backward + dist) + 1)
                        score1 = encode_Hash.BackwardReferenceScore(len3,backward2)
                        if (best_score < score1):
                            _hx_local_3 = self
                            _hx_local_4 = _hx_local_3.num_dict_matches_
                            _hx_local_3.num_dict_matches_ = (_hx_local_4 + 1)
                            _hx_local_3.num_dict_matches_
                            python_internal_ArrayImpl._set(best_len_out, 0, len3)
                            python_internal_ArrayImpl._set(best_len_code_out, 0, len3)
                            python_internal_ArrayImpl._set(best_distance_out, 0, backward2)
                            python_internal_ArrayImpl._set(best_score_out, 0, score1)
                            return True
        return match_found



class encode_hash_Hashers:
    _hx_class_name = "encode.hash.Hashers"
    __slots__ = ("hash_h1", "hash_h2", "hash_h3", "hash_h4", "hash_h5", "hash_h6", "hash_h7", "hash_h8", "hash_h9")
    _hx_fields = ["hash_h1", "hash_h2", "hash_h3", "hash_h4", "hash_h5", "hash_h6", "hash_h7", "hash_h8", "hash_h9"]
    _hx_methods = ["Init", "WarmupHashHashLongestMatchQuickly", "WarmupHashHashLongestMatch", "PrependCustomDictionary"]

    def __init__(self):
        self.hash_h9 = None
        self.hash_h8 = None
        self.hash_h7 = None
        self.hash_h6 = None
        self.hash_h5 = None
        self.hash_h4 = None
        self.hash_h3 = None
        self.hash_h2 = None
        self.hash_h1 = None

    def Init(self,_hx_type):
        if (_hx_type == 1):
            self.hash_h1 = encode_hash_HashLongestMatchQuickly(16,1,True)
        elif (_hx_type == 2):
            self.hash_h2 = encode_hash_HashLongestMatchQuickly(16,2,False)
        elif (_hx_type == 3):
            self.hash_h3 = encode_hash_HashLongestMatchQuickly(16,4,False)
        elif (_hx_type == 4):
            self.hash_h4 = encode_hash_HashLongestMatchQuickly(17,4,True)
        elif (_hx_type == 5):
            self.hash_h5 = encode_hash_HashLongestMatch(14,4,4)
        elif (_hx_type == 6):
            self.hash_h6 = encode_hash_HashLongestMatch(14,5,4)
        elif (_hx_type == 7):
            self.hash_h7 = encode_hash_HashLongestMatch(15,6,10)
        elif (_hx_type == 8):
            self.hash_h8 = encode_hash_HashLongestMatch(15,7,10)
        elif (_hx_type == 9):
            self.hash_h9 = encode_hash_HashLongestMatch(15,8,16)
        else:
            pass

    def WarmupHashHashLongestMatchQuickly(self,size,_hx_dict,hasher):
        _g1 = 0
        while (_g1 < size):
            i = _g1
            _g1 = (_g1 + 1)
            hasher.Store(_hx_dict,0,i)

    def WarmupHashHashLongestMatch(self,size,_hx_dict,hasher):
        _g1 = 0
        while (_g1 < size):
            i = _g1
            _g1 = (_g1 + 1)
            hasher.Store(_hx_dict,0,i)

    def PrependCustomDictionary(self,_hx_type,size,_hx_dict):
        if (_hx_type == 1):
            self.WarmupHashHashLongestMatchQuickly(size,_hx_dict,self.hash_h1)
        elif (_hx_type == 2):
            self.WarmupHashHashLongestMatchQuickly(size,_hx_dict,self.hash_h2)
        elif (_hx_type == 3):
            self.WarmupHashHashLongestMatchQuickly(size,_hx_dict,self.hash_h3)
        elif (_hx_type == 4):
            self.WarmupHashHashLongestMatchQuickly(size,_hx_dict,self.hash_h4)
        elif (_hx_type == 5):
            self.WarmupHashHashLongestMatch(size,_hx_dict,self.hash_h5)
        elif (_hx_type == 6):
            self.WarmupHashHashLongestMatch(size,_hx_dict,self.hash_h6)
        elif (_hx_type == 7):
            self.WarmupHashHashLongestMatch(size,_hx_dict,self.hash_h7)
        elif (_hx_type == 8):
            self.WarmupHashHashLongestMatch(size,_hx_dict,self.hash_h8)
        elif (_hx_type == 9):
            self.WarmupHashHashLongestMatch(size,_hx_dict,self.hash_h9)
        else:
            pass



class encode_histogram_Histogram:
    _hx_class_name = "encode.histogram.Histogram"
    __slots__ = ("kDataSize", "data_", "total_count_", "bit_cost_")
    _hx_fields = ["kDataSize", "data_", "total_count_", "bit_cost_"]
    _hx_methods = ["Clear", "Add1", "Remove", "Add2", "AddHistogram"]

    def __init__(self,kDataSize):
        self.bit_cost_ = None
        self.total_count_ = None
        self.kDataSize = kDataSize
        self.data_ = [None]*kDataSize
        self.Clear()

    def Clear(self):
        DefaultFunctions.memset_Int(self.data_,0,0,len(self.data_))
        self.total_count_ = 0

    def Add1(self,val):
        this1 = self.data_
        val1 = (self.data_[val] + 1)
        this1[val] = val1
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.total_count_
        _hx_local_0.total_count_ = (_hx_local_1 + 1)
        _hx_local_0.total_count_

    def Remove(self,val):
        this1 = self.data_
        val1 = (self.data_[val] - 1)
        this1[val] = val1
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.total_count_
        _hx_local_0.total_count_ = (_hx_local_1 - 1)
        _hx_local_0.total_count_

    def Add2(self,p,p_off,n):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.total_count_
        _hx_local_0.total_count_ = (_hx_local_1 + n)
        _hx_local_0.total_count_
        n = (n + 1)
        while True:
            n = (n - 1)
            tmp = n
            if (not ((tmp > 0))):
                break
            _g = p_off
            p_off = (p_off + 1)
            _g1 = (p[_g] if _g >= 0 and _g < len(p) else None)
            this1 = self.data_
            val = (self.data_[_g1] + 1)
            this1[_g1] = val

    def AddHistogram(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.total_count_
        _hx_local_0.total_count_ = (_hx_local_1 + v.total_count_)
        _hx_local_0.total_count_
        _g1 = 0
        _g = self.kDataSize
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            this1 = self.data_
            val = (self.data_[i] + v.data_[i])
            this1[i] = val



class encode_metablock_BlockSplit:
    _hx_class_name = "encode.metablock.BlockSplit"
    __slots__ = ("num_types", "types", "lengths")
    _hx_fields = ["num_types", "types", "lengths"]

    def __init__(self):
        self.lengths = list()
        self.types = list()
        self.num_types = 0



class encode_metablock_BlockSplitter:
    _hx_class_name = "encode.metablock.BlockSplitter"
    __slots__ = ("HistogramTypeInt", "alphabet_size_", "min_block_size_", "split_threshold_", "num_blocks_", "split_", "histograms_", "target_block_size_", "block_size_", "curr_histogram_ix_", "last_histogram_ix_", "last_entropy_", "merge_last_count_")
    _hx_fields = ["HistogramTypeInt", "alphabet_size_", "min_block_size_", "split_threshold_", "num_blocks_", "split_", "histograms_", "target_block_size_", "block_size_", "curr_histogram_ix_", "last_histogram_ix_", "last_entropy_", "merge_last_count_"]
    _hx_methods = ["AddSymbol", "FinishBlock"]
    _hx_statics = ["kMaxBlockTypes"]

    def __init__(self,HistogramTypeInt,alphabet_size,min_block_size,split_threshold,num_symbols,split,histograms):
        self.last_entropy_ = list()
        self.last_histogram_ix_ = list()
        self.HistogramTypeInt = HistogramTypeInt
        self.alphabet_size_ = alphabet_size
        self.min_block_size_ = min_block_size
        self.split_threshold_ = split_threshold
        self.num_blocks_ = 0
        self.split_ = split
        self.histograms_ = histograms
        self.target_block_size_ = min_block_size
        self.block_size_ = 0
        self.curr_histogram_ix_ = 0
        self.merge_last_count_ = 0
        max_num_blocks = None
        try:
            max_num_blocks = int((num_symbols / min_block_size))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            max_num_blocks = None
        max_num_blocks1 = (max_num_blocks + 1)
        b = (encode_metablock_BlockSplitter.kMaxBlockTypes + 1)
        x = (max_num_blocks1 if (python_lib_Math.isnan(max_num_blocks1)) else (b if (python_lib_Math.isnan(b)) else min(max_num_blocks1,b)))
        max_num_types = None
        try:
            max_num_types = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            max_num_types = None
        self.split_.lengths = list()
        self.split_.types = list()
        _g1 = 0
        _g = max_num_types
        while (_g1 < _g):
            _g1 = (_g1 + 1)
            _this = self.histograms_
            x1 = encode_histogram_Histogram(HistogramTypeInt)
            _this.append(x1)
        python_internal_ArrayImpl._set(self.last_histogram_ix_, 1, 0)
        python_internal_ArrayImpl._set(self.last_histogram_ix_, 0, 0)

    def AddSymbol(self,symbol):
        python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).Add1(symbol)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.block_size_
        _hx_local_0.block_size_ = (_hx_local_1 + 1)
        _hx_local_0.block_size_
        if (self.block_size_ == self.target_block_size_):
            self.FinishBlock(False)

    def FinishBlock(self,is_final):
        if (self.block_size_ < self.min_block_size_):
            self.block_size_ = self.min_block_size_
        if (self.num_blocks_ == 0):
            python_internal_ArrayImpl._set(self.split_.lengths, 0, self.block_size_)
            python_internal_ArrayImpl._set(self.split_.types, 0, 0)
            python_internal_ArrayImpl._set(self.last_entropy_, 0, encode_Bit_cost.BitsEntropy((self.histograms_[0] if 0 < len(self.histograms_) else None).data_,0,self.alphabet_size_))
            python_internal_ArrayImpl._set(self.last_entropy_, 1, (self.last_entropy_[0] if 0 < len(self.last_entropy_) else None))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.num_blocks_
            _hx_local_0.num_blocks_ = (_hx_local_1 + 1)
            _hx_local_0.num_blocks_
            _hx_local_2 = self.split_
            _hx_local_3 = _hx_local_2.num_types
            _hx_local_2.num_types = (_hx_local_3 + 1)
            _hx_local_2.num_types
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.curr_histogram_ix_
            _hx_local_4.curr_histogram_ix_ = (_hx_local_5 + 1)
            _hx_local_4.curr_histogram_ix_
            self.block_size_ = 0
        elif (self.block_size_ > 0):
            entropy = encode_Bit_cost.BitsEntropy(python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).data_,0,self.alphabet_size_)
            combined_histo = [encode_histogram_Histogram(self.HistogramTypeInt), encode_histogram_Histogram(self.HistogramTypeInt)]
            combined_entropy = FunctionMalloc.mallocFloat(2)
            diff = FunctionMalloc.mallocFloat(2)
            _g = 0
            while (_g < 2):
                j = _g
                _g = (_g + 1)
                last_histogram_ix = (self.last_histogram_ix_[j] if j >= 0 and j < len(self.last_histogram_ix_) else None)
                (combined_histo[j] if j >= 0 and j < len(combined_histo) else None).bit_cost_ = python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).bit_cost_
                _g2 = 0
                _g1 = len(python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).data_)
                while (_g2 < _g1):
                    a = _g2
                    _g2 = (_g2 + 1)
                    this1 = (combined_histo[j] if j >= 0 and j < len(combined_histo) else None).data_
                    val = python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).data_[a]
                    this1[a] = val
                (combined_histo[j] if j >= 0 and j < len(combined_histo) else None).kDataSize = python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).kDataSize
                (combined_histo[j] if j >= 0 and j < len(combined_histo) else None).total_count_ = python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).total_count_
                (combined_histo[j] if j >= 0 and j < len(combined_histo) else None).AddHistogram((self.histograms_[last_histogram_ix] if last_histogram_ix >= 0 and last_histogram_ix < len(self.histograms_) else None))
                val1 = encode_Bit_cost.BitsEntropy((combined_histo[j] if j >= 0 and j < len(combined_histo) else None).data_,0,self.alphabet_size_)
                combined_entropy[j] = val1
                val2 = ((combined_entropy[j] - entropy) - (self.last_entropy_[j] if j >= 0 and j < len(self.last_entropy_) else None))
                diff[j] = val2
            if (((self.split_.num_types < encode_metablock_BlockSplitter.kMaxBlockTypes) and ((diff[0] > self.split_threshold_))) and ((diff[1] > self.split_threshold_))):
                python_internal_ArrayImpl._set(self.split_.lengths, self.num_blocks_, self.block_size_)
                python_internal_ArrayImpl._set(self.split_.types, self.num_blocks_, self.split_.num_types)
                python_internal_ArrayImpl._set(self.last_histogram_ix_, 1, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None))
                python_internal_ArrayImpl._set(self.last_histogram_ix_, 0, self.split_.num_types)
                python_internal_ArrayImpl._set(self.last_entropy_, 1, (self.last_entropy_[0] if 0 < len(self.last_entropy_) else None))
                python_internal_ArrayImpl._set(self.last_entropy_, 0, entropy)
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.num_blocks_
                _hx_local_6.num_blocks_ = (_hx_local_7 + 1)
                _hx_local_6.num_blocks_
                _hx_local_8 = self.split_
                _hx_local_9 = _hx_local_8.num_types
                _hx_local_8.num_types = (_hx_local_9 + 1)
                _hx_local_8.num_types
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.curr_histogram_ix_
                _hx_local_10.curr_histogram_ix_ = (_hx_local_11 + 1)
                _hx_local_10.curr_histogram_ix_
                self.block_size_ = 0
                self.merge_last_count_ = 0
                self.target_block_size_ = self.min_block_size_
            elif (diff[1] < ((diff[0] - 20.0))):
                python_internal_ArrayImpl._set(self.split_.lengths, self.num_blocks_, self.block_size_)
                python_internal_ArrayImpl._set(self.split_.types, self.num_blocks_, python_internal_ArrayImpl._get(self.split_.types, (self.num_blocks_ - 2)))
                t = (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)
                python_internal_ArrayImpl._set(self.last_histogram_ix_, 0, (self.last_histogram_ix_[1] if 1 < len(self.last_histogram_ix_) else None))
                python_internal_ArrayImpl._set(self.last_histogram_ix_, 1, t)
                python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).bit_cost_ = (combined_histo[1] if 1 < len(combined_histo) else None).bit_cost_
                _g11 = 0
                _g3 = len((combined_histo[1] if 1 < len(combined_histo) else None).data_)
                while (_g11 < _g3):
                    a1 = _g11
                    _g11 = (_g11 + 1)
                    this2 = python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).data_
                    val3 = (combined_histo[1] if 1 < len(combined_histo) else None).data_[a1]
                    this2[a1] = val3
                python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).kDataSize = (combined_histo[1] if 1 < len(combined_histo) else None).kDataSize
                python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).total_count_ = (combined_histo[1] if 1 < len(combined_histo) else None).total_count_
                python_internal_ArrayImpl._set(self.last_entropy_, 1, (self.last_entropy_[0] if 0 < len(self.last_entropy_) else None))
                python_internal_ArrayImpl._set(self.last_entropy_, 0, combined_entropy[1])
                _hx_local_12 = self
                _hx_local_13 = _hx_local_12.num_blocks_
                _hx_local_12.num_blocks_ = (_hx_local_13 + 1)
                _hx_local_12.num_blocks_
                self.block_size_ = 0
                python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).Clear()
                self.merge_last_count_ = 0
                self.target_block_size_ = self.min_block_size_
            else:
                _hx_local_14 = self.split_.lengths
                _hx_local_15 = (self.num_blocks_ - 1)
                _hx_local_16 = (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)
                python_internal_ArrayImpl._set(_hx_local_14, _hx_local_15, (_hx_local_16 + self.block_size_))
                (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)
                python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).bit_cost_ = (combined_histo[0] if 0 < len(combined_histo) else None).bit_cost_
                _g12 = 0
                _g4 = len((combined_histo[0] if 0 < len(combined_histo) else None).data_)
                while (_g12 < _g4):
                    a2 = _g12
                    _g12 = (_g12 + 1)
                    this3 = python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).data_
                    val4 = (combined_histo[0] if 0 < len(combined_histo) else None).data_[a2]
                    this3[a2] = val4
                python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).kDataSize = (combined_histo[0] if 0 < len(combined_histo) else None).kDataSize
                python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] if 0 < len(self.last_histogram_ix_) else None)).total_count_ = (combined_histo[0] if 0 < len(combined_histo) else None).total_count_
                python_internal_ArrayImpl._set(self.last_entropy_, 0, combined_entropy[0])
                if (self.split_.num_types == 1):
                    python_internal_ArrayImpl._set(self.last_entropy_, 1, (self.last_entropy_[0] if 0 < len(self.last_entropy_) else None))
                self.block_size_ = 0
                python_internal_ArrayImpl._get(self.histograms_, self.curr_histogram_ix_).Clear()
                def _hx_local_19():
                    _hx_local_17 = self
                    _hx_local_18 = _hx_local_17.merge_last_count_
                    _hx_local_17.merge_last_count_ = (_hx_local_18 + 1)
                    return _hx_local_17.merge_last_count_
                tmp = (_hx_local_19() > 1)
                if tmp:
                    _hx_local_20 = self
                    _hx_local_21 = _hx_local_20.target_block_size_
                    _hx_local_20.target_block_size_ = (_hx_local_21 + self.min_block_size_)
                    _hx_local_20.target_block_size_
        if is_final:
            while (len(self.histograms_) > self.split_.num_types):
                _this = self.histograms_
                if (len(_this) != 0):
                    _this.pop()
            while (len(self.split_.types) > self.num_blocks_):
                _this1 = self.split_.types
                if (len(_this1) != 0):
                    _this1.pop()
            while (len(self.split_.lengths) > self.num_blocks_):
                _this2 = self.split_.lengths
                if (len(_this2) != 0):
                    _this2.pop()



class encode_metablock_ContextBlockSplitter:
    _hx_class_name = "encode.metablock.ContextBlockSplitter"
    __slots__ = ("HistogramTypeInt", "alphabet_size_", "num_contexts_", "max_block_types_", "min_block_size_", "split_threshold_", "num_blocks_", "split_", "histograms_", "target_block_size_", "block_size_", "curr_histogram_ix_", "last_histogram_ix_", "last_entropy_", "merge_last_count_")
    _hx_fields = ["HistogramTypeInt", "alphabet_size_", "num_contexts_", "max_block_types_", "min_block_size_", "split_threshold_", "num_blocks_", "split_", "histograms_", "target_block_size_", "block_size_", "curr_histogram_ix_", "last_histogram_ix_", "last_entropy_", "merge_last_count_"]
    _hx_methods = ["AddSymbol", "FinishBlock"]
    _hx_statics = ["kMaxBlockTypes"]

    def __init__(self,HistogramTypeInt,alphabet_size,num_contexts,min_block_size,split_threshold,num_symbols,split,histograms):
        self.last_histogram_ix_ = [None]*2
        self.HistogramTypeInt = HistogramTypeInt
        self.alphabet_size_ = alphabet_size
        self.num_contexts_ = num_contexts
        x = (encode_metablock_ContextBlockSplitter.kMaxBlockTypes / num_contexts)
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        self.max_block_types_ = tmp
        self.min_block_size_ = min_block_size
        self.split_threshold_ = split_threshold
        self.num_blocks_ = 0
        self.split_ = split
        self.histograms_ = histograms
        self.target_block_size_ = min_block_size
        self.block_size_ = 0
        self.curr_histogram_ix_ = 0
        self.last_entropy_ = FunctionMalloc.mallocFloat((2 * num_contexts))
        self.merge_last_count_ = 0
        max_num_blocks = None
        try:
            max_num_blocks = int((num_symbols / min_block_size))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            max_num_blocks = None
        max_num_blocks1 = (max_num_blocks + 1)
        b = (self.max_block_types_ + 1)
        x1 = (max_num_blocks1 if (python_lib_Math.isnan(max_num_blocks1)) else (b if (python_lib_Math.isnan(b)) else min(max_num_blocks1,b)))
        max_num_types = None
        try:
            max_num_types = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e2 = _hx_e1
            max_num_types = None
        self.split_.lengths = list()
        self.split_.types = list()
        _g1 = 0
        _g = (max_num_types * num_contexts)
        while (_g1 < _g):
            _g1 = (_g1 + 1)
            _this = self.histograms_
            x2 = encode_histogram_Histogram(HistogramTypeInt)
            _this.append(x2)
        this1 = self.last_histogram_ix_
        self.last_histogram_ix_[1] = 0
        this1[0] = 0

    def AddSymbol(self,symbol,context):
        python_internal_ArrayImpl._get(self.histograms_, (self.curr_histogram_ix_ + context)).Add1(symbol)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.block_size_
        _hx_local_0.block_size_ = (_hx_local_1 + 1)
        _hx_local_0.block_size_
        if (self.block_size_ == self.target_block_size_):
            self.FinishBlock(False)

    def FinishBlock(self,is_final):
        if (self.block_size_ < self.min_block_size_):
            self.block_size_ = self.min_block_size_
        if (self.num_blocks_ == 0):
            python_internal_ArrayImpl._set(self.split_.lengths, 0, self.block_size_)
            python_internal_ArrayImpl._set(self.split_.types, 0, 0)
            _g1 = 0
            _g = self.num_contexts_
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                this1 = self.last_entropy_
                val = encode_Bit_cost.BitsEntropy((self.histograms_[i] if i >= 0 and i < len(self.histograms_) else None).data_,0,self.alphabet_size_)
                this1[i] = val
                this2 = self.last_entropy_
                index = (self.num_contexts_ + i)
                val1 = self.last_entropy_[i]
                this2[index] = val1
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.num_blocks_
            _hx_local_0.num_blocks_ = (_hx_local_1 + 1)
            _hx_local_0.num_blocks_
            _hx_local_2 = self.split_
            _hx_local_3 = _hx_local_2.num_types
            _hx_local_2.num_types = (_hx_local_3 + 1)
            _hx_local_2.num_types
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.curr_histogram_ix_
            _hx_local_4.curr_histogram_ix_ = (_hx_local_5 + self.num_contexts_)
            _hx_local_4.curr_histogram_ix_
            self.block_size_ = 0
        elif (self.block_size_ > 0):
            entropy = [None]*self.num_contexts_
            combined_histo = [None]*(2 * self.num_contexts_)
            _g11 = 0
            _g2 = (2 * self.num_contexts_)
            while (_g11 < _g2):
                i1 = _g11
                _g11 = (_g11 + 1)
                val2 = encode_histogram_Histogram(self.HistogramTypeInt)
                combined_histo[i1] = val2
            combined_entropy = [None]*(2 * self.num_contexts_)
            diff = [0.0, 0.0]
            _g12 = 0
            _g3 = self.num_contexts_
            while (_g12 < _g3):
                i2 = _g12
                _g12 = (_g12 + 1)
                curr_histo_ix = (self.curr_histogram_ix_ + i2)
                val3 = encode_Bit_cost.BitsEntropy((self.histograms_[curr_histo_ix] if curr_histo_ix >= 0 and curr_histo_ix < len(self.histograms_) else None).data_,0,self.alphabet_size_)
                entropy[i2] = val3
                _g21 = 0
                while (_g21 < 2):
                    j = _g21
                    _g21 = (_g21 + 1)
                    jx = ((j * self.num_contexts_) + i2)
                    last_histogram_ix = (self.last_histogram_ix_[j] + i2)
                    combined_histo[jx].bit_cost_ = (self.histograms_[curr_histo_ix] if curr_histo_ix >= 0 and curr_histo_ix < len(self.histograms_) else None).bit_cost_
                    _g4 = 0
                    _g31 = len((self.histograms_[curr_histo_ix] if curr_histo_ix >= 0 and curr_histo_ix < len(self.histograms_) else None).data_)
                    while (_g4 < _g31):
                        a = _g4
                        _g4 = (_g4 + 1)
                        this3 = combined_histo[jx].data_
                        val4 = (self.histograms_[curr_histo_ix] if curr_histo_ix >= 0 and curr_histo_ix < len(self.histograms_) else None).data_[a]
                        this3[a] = val4
                    combined_histo[jx].kDataSize = (self.histograms_[curr_histo_ix] if curr_histo_ix >= 0 and curr_histo_ix < len(self.histograms_) else None).kDataSize
                    combined_histo[jx].total_count_ = (self.histograms_[curr_histo_ix] if curr_histo_ix >= 0 and curr_histo_ix < len(self.histograms_) else None).total_count_
                    combined_histo[jx].AddHistogram((self.histograms_[last_histogram_ix] if last_histogram_ix >= 0 and last_histogram_ix < len(self.histograms_) else None))
                    val5 = encode_Bit_cost.BitsEntropy(combined_histo[jx].data_,0,self.alphabet_size_)
                    combined_entropy[jx] = val5
                    python_internal_ArrayImpl._set(diff, j, ((diff[j] if j >= 0 and j < len(diff) else None) + (((combined_entropy[jx] - entropy[i2]) - self.last_entropy_[jx]))))
            if (((self.split_.num_types < self.max_block_types_) and (((diff[0] if 0 < len(diff) else None) > self.split_threshold_))) and (((diff[1] if 1 < len(diff) else None) > self.split_threshold_))):
                python_internal_ArrayImpl._set(self.split_.lengths, self.num_blocks_, self.block_size_)
                python_internal_ArrayImpl._set(self.split_.types, self.num_blocks_, self.split_.num_types)
                this4 = self.last_histogram_ix_
                val6 = self.last_histogram_ix_[0]
                this4[1] = val6
                val7 = (self.split_.num_types * self.num_contexts_)
                self.last_histogram_ix_[0] = val7
                _g13 = 0
                _g5 = self.num_contexts_
                while (_g13 < _g5):
                    i3 = _g13
                    _g13 = (_g13 + 1)
                    this5 = self.last_entropy_
                    index1 = (self.num_contexts_ + i3)
                    val8 = self.last_entropy_[i3]
                    this5[index1] = val8
                    this6 = self.last_entropy_
                    val9 = entropy[i3]
                    this6[i3] = val9
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.num_blocks_
                _hx_local_7.num_blocks_ = (_hx_local_8 + 1)
                _hx_local_7.num_blocks_
                _hx_local_9 = self.split_
                _hx_local_10 = _hx_local_9.num_types
                _hx_local_9.num_types = (_hx_local_10 + 1)
                _hx_local_9.num_types
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.curr_histogram_ix_
                _hx_local_11.curr_histogram_ix_ = (_hx_local_12 + self.num_contexts_)
                _hx_local_11.curr_histogram_ix_
                self.block_size_ = 0
                self.merge_last_count_ = 0
                self.target_block_size_ = self.min_block_size_
            elif ((diff[1] if 1 < len(diff) else None) < (((diff[0] if 0 < len(diff) else None) - 20.0))):
                python_internal_ArrayImpl._set(self.split_.lengths, self.num_blocks_, self.block_size_)
                python_internal_ArrayImpl._set(self.split_.types, self.num_blocks_, python_internal_ArrayImpl._get(self.split_.types, (self.num_blocks_ - 2)))
                t = self.last_histogram_ix_[0]
                this7 = self.last_histogram_ix_
                val10 = self.last_histogram_ix_[1]
                this7[0] = val10
                self.last_histogram_ix_[1] = t
                _g14 = 0
                _g6 = self.num_contexts_
                while (_g14 < _g6):
                    i4 = _g14
                    _g14 = (_g14 + 1)
                    tmp = self.histograms_
                    tmp1 = (self.last_histogram_ix_[0] + i4)
                    tmp2 = combined_histo[(self.num_contexts_ + i4)]
                    (tmp[tmp1] if tmp1 >= 0 and tmp1 < len(tmp) else None).bit_cost_ = tmp2.bit_cost_
                    _g32 = 0
                    _g22 = len(combined_histo[(self.num_contexts_ + i4)].data_)
                    while (_g32 < _g22):
                        a1 = _g32
                        _g32 = (_g32 + 1)
                        this8 = python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] + i4)).data_
                        val11 = combined_histo[(self.num_contexts_ + i4)].data_[a1]
                        this8[a1] = val11
                    tmp3 = self.histograms_
                    tmp4 = (self.last_histogram_ix_[0] + i4)
                    tmp5 = combined_histo[(self.num_contexts_ + i4)]
                    (tmp3[tmp4] if tmp4 >= 0 and tmp4 < len(tmp3) else None).kDataSize = tmp5.kDataSize
                    tmp6 = self.histograms_
                    tmp7 = (self.last_histogram_ix_[0] + i4)
                    tmp8 = combined_histo[(self.num_contexts_ + i4)]
                    (tmp6[tmp7] if tmp7 >= 0 and tmp7 < len(tmp6) else None).total_count_ = tmp8.total_count_
                    this9 = self.last_entropy_
                    index2 = (self.num_contexts_ + i4)
                    val12 = self.last_entropy_[i4]
                    this9[index2] = val12
                    this10 = self.last_entropy_
                    val13 = combined_entropy[(self.num_contexts_ + i4)]
                    this10[i4] = val13
                    python_internal_ArrayImpl._get(self.histograms_, (self.curr_histogram_ix_ + i4)).Clear()
                _hx_local_13 = self
                _hx_local_14 = _hx_local_13.num_blocks_
                _hx_local_13.num_blocks_ = (_hx_local_14 + 1)
                _hx_local_13.num_blocks_
                self.block_size_ = 0
                self.merge_last_count_ = 0
                self.target_block_size_ = self.min_block_size_
            else:
                _hx_local_15 = self.split_.lengths
                _hx_local_16 = (self.num_blocks_ - 1)
                _hx_local_17 = (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
                python_internal_ArrayImpl._set(_hx_local_15, _hx_local_16, (_hx_local_17 + self.block_size_))
                (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
                _g15 = 0
                _g7 = self.num_contexts_
                while (_g15 < _g7):
                    i5 = _g15
                    _g15 = (_g15 + 1)
                    python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] + i5)).bit_cost_ = combined_histo[i5].bit_cost_
                    _g33 = 0
                    _g23 = len(combined_histo[i5].data_)
                    while (_g33 < _g23):
                        a2 = _g33
                        _g33 = (_g33 + 1)
                        this11 = python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] + i5)).data_
                        val14 = combined_histo[i5].data_[a2]
                        this11[a2] = val14
                    python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] + i5)).kDataSize = combined_histo[i5].kDataSize
                    python_internal_ArrayImpl._get(self.histograms_, (self.last_histogram_ix_[0] + i5)).total_count_ = combined_histo[i5].total_count_
                    this12 = self.last_entropy_
                    val15 = combined_entropy[i5]
                    this12[i5] = val15
                    if (self.split_.num_types == 1):
                        this13 = self.last_entropy_
                        index3 = (self.num_contexts_ + i5)
                        val16 = self.last_entropy_[i5]
                        this13[index3] = val16
                    python_internal_ArrayImpl._get(self.histograms_, (self.curr_histogram_ix_ + i5)).Clear()
                self.block_size_ = 0
                def _hx_local_20():
                    _hx_local_18 = self
                    _hx_local_19 = _hx_local_18.merge_last_count_
                    _hx_local_18.merge_last_count_ = (_hx_local_19 + 1)
                    return _hx_local_18.merge_last_count_
                tmp9 = (_hx_local_20() > 1)
                if tmp9:
                    _hx_local_21 = self
                    _hx_local_22 = _hx_local_21.target_block_size_
                    _hx_local_21.target_block_size_ = (_hx_local_22 + self.min_block_size_)
                    _hx_local_21.target_block_size_
        if is_final:
            while (len(self.histograms_) > ((self.split_.num_types * self.num_contexts_))):
                _this = self.histograms_
                if (len(_this) != 0):
                    _this.pop()
            while (len(self.split_.types) > self.num_blocks_):
                _this1 = self.split_.types
                if (len(_this1) != 0):
                    _this1.pop()
            while (len(self.split_.lengths) > self.num_blocks_):
                _this2 = self.split_.lengths
                if (len(_this2) != 0):
                    _this2.pop()



class encode_metablock_MetaBlockSplit:
    _hx_class_name = "encode.metablock.MetaBlockSplit"
    __slots__ = ("literal_split", "command_split", "distance_split", "literal_context_map", "distance_context_map", "literal_histograms", "command_histograms", "distance_histograms")
    _hx_fields = ["literal_split", "command_split", "distance_split", "literal_context_map", "distance_context_map", "literal_histograms", "command_histograms", "distance_histograms"]

    def __init__(self):
        self.distance_histograms = list()
        self.command_histograms = list()
        self.literal_histograms = list()
        self.distance_context_map = [None]*0
        self.literal_context_map = [None]*0
        self.distance_split = encode_metablock_BlockSplit()
        self.command_split = encode_metablock_BlockSplit()
        self.literal_split = encode_metablock_BlockSplit()



class encode_static_dict_lut_DictWord:
    _hx_class_name = "encode.static_dict_lut.DictWord"
    __slots__ = ("len", "transform", "idx")
    _hx_fields = ["len", "transform", "idx"]

    def __init__(self,_hx_len,transform,idx):
        self.len = _hx_len
        self.transform = transform
        self.idx = idx



class encode_streams_BrotliIn:
    _hx_class_name = "encode.streams.BrotliIn"
    __slots__ = ("f_", "buffer_", "buffer_size_")
    _hx_fields = ["f_", "buffer_", "buffer_size_"]
    _hx_methods = ["Read"]

    def __init__(self,f,max_read_size):
        self.f_ = f
        self.buffer_ = FunctionMalloc.mallocUInt(max_read_size)
        self.buffer_size_ = max_read_size

    def Read(self,n,bytes_read):
        if (self.buffer_ is None):
            python_internal_ArrayImpl._set(bytes_read, 0, 0)
            return None
        if (n > self.buffer_size_):
            n = self.buffer_size_
        elif (n == 0):
            if self.f_.eof():
                return None
            else:
                return self.buffer_
        if self.f_.eof():
            return None
        _hx_bytes = haxe_io_Bytes.alloc(n)
        try:
            size = self.f_.readBytes(_hx_bytes,0,n)
            _g1 = 0
            while (_g1 < size):
                i = _g1
                _g1 = (_g1 + 1)
                this1 = self.buffer_
                val = _hx_bytes.b[i]
                this1[i] = val
            python_internal_ArrayImpl._set(bytes_read, 0, size)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                    pass
            else:
                raise _hx_e
        if ((bytes_read[0] if 0 < len(bytes_read) else None) == 0):
            return None
        else:
            return self.buffer_



class encode_streams_BrotliMemIn:
    _hx_class_name = "encode.streams.BrotliMemIn"
    __slots__ = ("buf_", "len_", "pos_")
    _hx_fields = ["buf_", "len_", "pos_"]
    _hx_methods = ["position", "Reset", "Read"]

    def __init__(self,buf,_hx_len):
        self.buf_ = buf
        self.len_ = _hx_len
        self.pos_ = 0

    def position(self):
        return self.pos_

    def Reset(self,buf,_hx_len):
        self.buf_ = buf
        self.len_ = _hx_len
        self.pos_ = 0

    def Read(self,n,output):
        if (self.pos_ == self.len_):
            return None
        if (n > ((self.len_ - self.pos_))):
            n = (self.len_ - self.pos_)
        p = [None]*n
        DefaultFunctions.memcpyVectorArray(p,0,self.buf_,self.pos_,n)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos_
        _hx_local_0.pos_ = (_hx_local_1 + n)
        _hx_local_0.pos_
        python_internal_ArrayImpl._set(output, 0, n)
        return p



class encode_streams_BrotliMemOut:
    _hx_class_name = "encode.streams.BrotliMemOut"
    __slots__ = ("buf_", "pos_")
    _hx_fields = ["buf_", "pos_"]
    _hx_methods = ["position", "Reset", "Write"]

    def __init__(self,buf):
        self.buf_ = buf
        self.pos_ = 0

    def position(self):
        return self.pos_

    def Reset(self,buf,_hx_len):
        self.buf_ = buf
        self.pos_ = 0

    def Write(self,buf,n):
        DefaultFunctions.memcpyArrayVector(self.buf_,self.pos_,buf,0,n)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos_
        _hx_local_0.pos_ = (_hx_local_1 + n)
        _hx_local_0.pos_
        return True



class encode_streams_BrotliOut:
    _hx_class_name = "encode.streams.BrotliOut"
    __slots__ = ("f_",)
    _hx_fields = ["f_"]
    _hx_methods = ["Write"]

    def __init__(self,f):
        self.f_ = f

    def Write(self,buf,n):
        _hx_bytes = haxe_io_Bytes.alloc(n)
        _g1 = 0
        while (_g1 < n):
            i = _g1
            _g1 = (_g1 + 1)
            v = buf[i]
            _hx_bytes.b[i] = (v & 255)
        self.f_.write(_hx_bytes)
        return True



class haxe__Int32_Int32_Impl_:
    _hx_class_name = "haxe._Int32.Int32_Impl_"
    __slots__ = ()
    _hx_statics = ["ucompare"]

    @staticmethod
    def ucompare(a,b):
        if (a < 0):
            if (b < 0):
                return (((~b - ~a) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            else:
                return 1
        if (b < 0):
            return -1
        else:
            return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]

    def __init__(self,high,low):
        self.high = high
        self.low = low



class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set"]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value



class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "getString"]
    _hx_statics = ["alloc", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def getString(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len];#.decode('UTF-8','replace')

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)



class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b



class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "set_bigEndian", "write"]

    def writeByte(self,c):
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)



class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if isinstance(o,int):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        _hx_local_0 = len(field)
        if (_hx_local_0 == 10):
            if (field == "charCodeAt"):
                if isinstance(o,str):
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field == "lastIndexOf"):
                if isinstance(o,str):
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field == "toLowerCase"):
                if isinstance(o,str):
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field == "toUpperCase"):
                if isinstance(o,str):
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field == "substring"):
                if isinstance(o,str):
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field == "copy"):
                if isinstance(o,list):
                    def _hx_local_7():
                        return list(o)
                    return _hx_local_7
            elif (field == "join"):
                if isinstance(o,list):
                    def _hx_local_8(sep):
                        return sep.join([python_Boot.toString1(x1,'') for x1 in o])
                    return _hx_local_8
            elif (field == "push"):
                if isinstance(o,list):
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field == "sort"):
                if isinstance(o,list):
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field == "shift"):
                if isinstance(o,list):
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field == "slice"):
                if isinstance(o,list):
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field == "split"):
                if isinstance(o,str):
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field == "indexOf"):
                if isinstance(o,str):
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field == "reverse"):
                if isinstance(o,list):
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field == "unshift"):
                if isinstance(o,list):
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field == "map"):
                if isinstance(o,list):
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field == "pop"):
                if isinstance(o,list):
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field == "iterator"):
                if isinstance(o,list):
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field == "toString"):
                if isinstance(o,str):
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field == "charAt"):
                if isinstance(o,str):
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field == "concat"):
                if isinstance(o,list):
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field == "filter"):
                if isinstance(o,list):
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field == "insert"):
                if isinstance(o,list):
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field == "length"):
                if isinstance(o,str):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field == "remove"):
                if isinstance(o,list):
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field == "splice"):
                if isinstance(o,list):
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field == "substr"):
                if isinstance(o,str):
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (c._hx_fields if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["print", "println", "anonToDict", "anonAsDict", "dictAsAnon"]

    @staticmethod
    def print_(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def println(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.write((("" + ("null" if _hx_str is None else _hx_str)) + "\n").encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None

    @staticmethod
    def dictAsAnon(d):
        return _hx_AnonObject(d)


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["get_length", "concat", "iterator", "indexOf", "lastIndexOf", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def get_length(x):
        return len(x)

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g1 = l
        while (_g1 < _hx_len):
            i = _g1
            _g1 = (_g1 + 1)
            if (a[i] == x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if (a[l] == x):
                return l
        return -1

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        super().__init__(str(val))
        self.val = val



class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "rshift", "modf", "mod", "arrayGet", "mapKwArgs"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        return float('nan') if (b == 0.0) else a % b if a >= 0 else -(-a % b)

    @staticmethod
    def mod(a,b):
        return a % b if a >= 0 else -(-a % b)

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def mapKwArgs(a,v):
        a1 = python_Lib.dictAsAnon(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if hasattr(a1,k1):
                setattr(a1,val,getattr(a1,k1))
                delattr(a1,k1)
        return a1


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["tell", "throwEof", "eof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

    def tell(self):
        return self.stream.tell()

    def throwEof(self):
        self.wasEof = True
        raise _HxException(haxe_io_Eof())

    def eof(self):
        return self.wasEof

    def readinto(self,b):
        raise _HxException("abstract method, should be overriden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret



class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "readBytes"]


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readinto"]
    _hx_statics = []
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readinto(self,b):
        return self.stream.readinto(b)



class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_methods = ["tell", "eof"]


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["tell"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def tell(self):
        return self.stream.tell()



class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))



class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "write"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_methods = ["tell"]


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readinto"]
    _hx_statics = []
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readinto(self,b):
        return self.stream.buffer.readinto(b)



class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))



class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "createFileOutputFromText", "createFileOutputFromBytes"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getBytes", "read", "write"]

    @staticmethod
    def getBytes(path):
        f = open(path,"rb",-1)
        b = haxe_io_Bytes.ofData(f.read(-1))
        f.close()
        return b

    @staticmethod
    def read(path,binary = True):
        if (binary is None):
            binary = True
        f = open(path,("rb" if binary else "r"),-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def write(path,binary = True):
        if (binary is None):
            binary = True
        f = open(path,("wb" if binary else "w"),-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "tell", "eof", "readBytes"]
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return Reflect.field(self.impl,"set_bigEndian")(b)

    def tell(self):
        return self.impl.tell()

    def eof(self):
        return self.impl.eof()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)



class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["tell", "set_bigEndian", "writeByte", "writeBytes", "write"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def tell(self):
        return self.impl.tell()

    def set_bigEndian(self,b):
        return Reflect.field(self.impl,"set_bigEndian")(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def write(self,s):
        self.impl.write(s)



class sys_net_Socket:
    _hx_class_name = "sys.net.Socket"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["fileno"]

    def fileno(self):
        return self._hx___s.fileno()


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

decode_Decode.kDefaultCodeLength = 8
decode_Decode.kCodeLengthRepeatCode = 16
decode_Decode.kNumLiteralCodes = 256
decode_Decode.kNumInsertAndCopyCodes = 704
decode_Decode.kNumBlockLengthCodes = 26
decode_Decode.kLiteralContextBits = 6
decode_Decode.kDistanceContextBits = 2
decode_Decode.HUFFMAN_TABLE_BITS = 8
decode_Decode.HUFFMAN_TABLE_MASK = 255
decode_Decode.CODE_LENGTH_CODES = 18
decode_Decode.kCodeLengthCodeOrder = [1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15]
decode_Decode.NUM_DISTANCE_SHORT_CODES = 16
decode_Decode.kDistanceShortCodeIndexOffset = [3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2]
decode_Decode.kDistanceShortCodeValueOffset = [0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3]
decode_BitReader.BROTLI_MAX_NUM_BIT_READ = 25
decode_BitReader.BROTLI_READ_SIZE = 4096
decode_BitReader.BROTLI_IBUF_SIZE = 8320
decode_BitReader.BROTLI_IBUF_MASK = 8191
decode_BitReader.kBitMask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215]
decode_Context.kContextLookup = [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 56, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
decode_Context.kContextLookupOffsets = [1024, 1536, 1280, 1536, 0, 256, 768, 512]
decode_Dictionary.kBrotliDictionaryOffsetsByLength = [0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536, 115968, 118528, 119872, 121280, 122016]
decode_Dictionary.kBrotliDictionarySizeBitsByLength = [0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7, 7, 6, 6, 5, 5]
decode_Dictionary.kMinDictionaryWordLength = 4
decode_Dictionary.kMaxDictionaryWordLength = 24
decode_Huffman.BROTLI_HUFFMAN_MAX_TABLE_SIZE = 1080
decode_Huffman.MAX_LENGTH = 15
decode_Huffman.MAX_CODE_LENGTHS_SIZE = 704
decode_Prefix.kBlockLengthPrefixCode = [decode_prefix_PrefixCodeRange(1,2), decode_prefix_PrefixCodeRange(5,2), decode_prefix_PrefixCodeRange(9,2), decode_prefix_PrefixCodeRange(13,2), decode_prefix_PrefixCodeRange(17,3), decode_prefix_PrefixCodeRange(25,3), decode_prefix_PrefixCodeRange(33,3), decode_prefix_PrefixCodeRange(41,3), decode_prefix_PrefixCodeRange(49,4), decode_prefix_PrefixCodeRange(65,4), decode_prefix_PrefixCodeRange(81,4), decode_prefix_PrefixCodeRange(97,4), decode_prefix_PrefixCodeRange(113,5), decode_prefix_PrefixCodeRange(145,5), decode_prefix_PrefixCodeRange(177,5), decode_prefix_PrefixCodeRange(209,5), decode_prefix_PrefixCodeRange(241,6), decode_prefix_PrefixCodeRange(305,6), decode_prefix_PrefixCodeRange(369,7), decode_prefix_PrefixCodeRange(497,8), decode_prefix_PrefixCodeRange(753,9), decode_prefix_PrefixCodeRange(1265,10), decode_prefix_PrefixCodeRange(2289,11), decode_prefix_PrefixCodeRange(4337,12), decode_prefix_PrefixCodeRange(8433,13), decode_prefix_PrefixCodeRange(16625,24)]
decode_Prefix.kInsertLengthPrefixCode = [decode_prefix_PrefixCodeRange(0,0), decode_prefix_PrefixCodeRange(1,0), decode_prefix_PrefixCodeRange(2,0), decode_prefix_PrefixCodeRange(3,0), decode_prefix_PrefixCodeRange(4,0), decode_prefix_PrefixCodeRange(5,0), decode_prefix_PrefixCodeRange(6,1), decode_prefix_PrefixCodeRange(8,1), decode_prefix_PrefixCodeRange(10,2), decode_prefix_PrefixCodeRange(14,2), decode_prefix_PrefixCodeRange(18,3), decode_prefix_PrefixCodeRange(26,3), decode_prefix_PrefixCodeRange(34,4), decode_prefix_PrefixCodeRange(50,4), decode_prefix_PrefixCodeRange(66,5), decode_prefix_PrefixCodeRange(98,5), decode_prefix_PrefixCodeRange(130,6), decode_prefix_PrefixCodeRange(194,7), decode_prefix_PrefixCodeRange(322,8), decode_prefix_PrefixCodeRange(578,9), decode_prefix_PrefixCodeRange(1090,10), decode_prefix_PrefixCodeRange(2114,12), decode_prefix_PrefixCodeRange(6210,14), decode_prefix_PrefixCodeRange(22594,24)]
decode_Prefix.kCopyLengthPrefixCode = [decode_prefix_PrefixCodeRange(2,0), decode_prefix_PrefixCodeRange(3,0), decode_prefix_PrefixCodeRange(4,0), decode_prefix_PrefixCodeRange(5,0), decode_prefix_PrefixCodeRange(6,0), decode_prefix_PrefixCodeRange(7,0), decode_prefix_PrefixCodeRange(8,0), decode_prefix_PrefixCodeRange(9,0), decode_prefix_PrefixCodeRange(10,1), decode_prefix_PrefixCodeRange(12,1), decode_prefix_PrefixCodeRange(14,2), decode_prefix_PrefixCodeRange(18,2), decode_prefix_PrefixCodeRange(22,3), decode_prefix_PrefixCodeRange(30,3), decode_prefix_PrefixCodeRange(38,4), decode_prefix_PrefixCodeRange(54,4), decode_prefix_PrefixCodeRange(70,5), decode_prefix_PrefixCodeRange(102,5), decode_prefix_PrefixCodeRange(134,6), decode_prefix_PrefixCodeRange(198,7), decode_prefix_PrefixCodeRange(326,8), decode_prefix_PrefixCodeRange(582,9), decode_prefix_PrefixCodeRange(1094,10), decode_prefix_PrefixCodeRange(2118,24)]
decode_Prefix.kInsertRangeLut = [0, 0, 8, 8, 0, 16, 8, 16, 16]
decode_Prefix.kCopyRangeLut = [0, 8, 0, 8, 16, 0, 16, 8, 16]
decode_Transforms.kIdentity = 0
decode_Transforms.kOmitLast1 = 1
decode_Transforms.kOmitLast2 = 2
decode_Transforms.kOmitLast3 = 3
decode_Transforms.kOmitLast4 = 4
decode_Transforms.kOmitLast5 = 5
decode_Transforms.kOmitLast6 = 6
decode_Transforms.kOmitLast7 = 7
decode_Transforms.kOmitLast8 = 8
decode_Transforms.kOmitLast9 = 9
decode_Transforms.kUppercaseFirst = 10
decode_Transforms.kUppercaseAll = 11
decode_Transforms.kOmitFirst1 = 12
decode_Transforms.kOmitFirst2 = 13
decode_Transforms.kOmitFirst3 = 14
decode_Transforms.kOmitFirst4 = 15
decode_Transforms.kOmitFirst5 = 16
decode_Transforms.kOmitFirst6 = 17
decode_Transforms.kOmitFirst7 = 18
decode_Transforms.kOmitFirst8 = 19
decode_Transforms.kOmitFirst9 = 20
decode_Transforms.kTransforms = [decode_transform_Transform("",decode_Transforms.kIdentity,""), decode_transform_Transform("",decode_Transforms.kIdentity," "), decode_transform_Transform(" ",decode_Transforms.kIdentity," "), decode_transform_Transform("",decode_Transforms.kOmitFirst1,""), decode_transform_Transform("",decode_Transforms.kUppercaseFirst," "), decode_transform_Transform("",decode_Transforms.kIdentity," the "), decode_transform_Transform(" ",decode_Transforms.kIdentity,""), decode_transform_Transform("s ",decode_Transforms.kIdentity," "), decode_transform_Transform("",decode_Transforms.kIdentity," of "), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,""), decode_transform_Transform("",decode_Transforms.kIdentity," and "), decode_transform_Transform("",decode_Transforms.kOmitFirst2,""), decode_transform_Transform("",decode_Transforms.kOmitLast1,""), decode_transform_Transform(", ",decode_Transforms.kIdentity," "), decode_transform_Transform("",decode_Transforms.kIdentity,", "), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst," "), decode_transform_Transform("",decode_Transforms.kIdentity," in "), decode_transform_Transform("",decode_Transforms.kIdentity," to "), decode_transform_Transform("e ",decode_Transforms.kIdentity," "), decode_transform_Transform("",decode_Transforms.kIdentity,"\""), decode_transform_Transform("",decode_Transforms.kIdentity,"."), decode_transform_Transform("",decode_Transforms.kIdentity,"\">"), decode_transform_Transform("",decode_Transforms.kIdentity,"\n"), decode_transform_Transform("",decode_Transforms.kOmitLast3,""), decode_transform_Transform("",decode_Transforms.kIdentity,"]"), decode_transform_Transform("",decode_Transforms.kIdentity," for "), decode_transform_Transform("",decode_Transforms.kOmitFirst3,""), decode_transform_Transform("",decode_Transforms.kOmitLast2,""), decode_transform_Transform("",decode_Transforms.kIdentity," a "), decode_transform_Transform("",decode_Transforms.kIdentity," that "), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst,""), decode_transform_Transform("",decode_Transforms.kIdentity,". "), decode_transform_Transform(".",decode_Transforms.kIdentity,""), decode_transform_Transform(" ",decode_Transforms.kIdentity,", "), decode_transform_Transform("",decode_Transforms.kOmitFirst4,""), decode_transform_Transform("",decode_Transforms.kIdentity," with "), decode_transform_Transform("",decode_Transforms.kIdentity,"'"), decode_transform_Transform("",decode_Transforms.kIdentity," from "), decode_transform_Transform("",decode_Transforms.kIdentity," by "), decode_transform_Transform("",decode_Transforms.kOmitFirst5,""), decode_transform_Transform("",decode_Transforms.kOmitFirst6,""), decode_transform_Transform(" the ",decode_Transforms.kIdentity,""), decode_transform_Transform("",decode_Transforms.kOmitLast4,""), decode_transform_Transform("",decode_Transforms.kIdentity,". The "), decode_transform_Transform("",decode_Transforms.kUppercaseAll,""), decode_transform_Transform("",decode_Transforms.kIdentity," on "), decode_transform_Transform("",decode_Transforms.kIdentity," as "), decode_transform_Transform("",decode_Transforms.kIdentity," is "), decode_transform_Transform("",decode_Transforms.kOmitLast7,""), decode_transform_Transform("",decode_Transforms.kOmitLast1,"ing "), decode_transform_Transform("",decode_Transforms.kIdentity,"\n\t"), decode_transform_Transform("",decode_Transforms.kIdentity,":"), decode_transform_Transform(" ",decode_Transforms.kIdentity,". "), decode_transform_Transform("",decode_Transforms.kIdentity,"ed "), decode_transform_Transform("",decode_Transforms.kOmitFirst9,""), decode_transform_Transform("",decode_Transforms.kOmitFirst7,""), decode_transform_Transform("",decode_Transforms.kOmitLast6,""), decode_transform_Transform("",decode_Transforms.kIdentity,"("), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,", "), decode_transform_Transform("",decode_Transforms.kOmitLast8,""), decode_transform_Transform("",decode_Transforms.kIdentity," at "), decode_transform_Transform("",decode_Transforms.kIdentity,"ly "), decode_transform_Transform(" the ",decode_Transforms.kIdentity," of "), decode_transform_Transform("",decode_Transforms.kOmitLast5,""), decode_transform_Transform("",decode_Transforms.kOmitLast9,""), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst,", "), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,"\""), decode_transform_Transform(".",decode_Transforms.kIdentity,"("), decode_transform_Transform("",decode_Transforms.kUppercaseAll," "), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,"\">"), decode_transform_Transform("",decode_Transforms.kIdentity,"=\""), decode_transform_Transform(" ",decode_Transforms.kIdentity,"."), decode_transform_Transform(".com/",decode_Transforms.kIdentity,""), decode_transform_Transform(" the ",decode_Transforms.kIdentity," of the "), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,"'"), decode_transform_Transform("",decode_Transforms.kIdentity,". This "), decode_transform_Transform("",decode_Transforms.kIdentity,","), decode_transform_Transform(".",decode_Transforms.kIdentity," "), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,"("), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,"."), decode_transform_Transform("",decode_Transforms.kIdentity," not "), decode_transform_Transform(" ",decode_Transforms.kIdentity,"=\""), decode_transform_Transform("",decode_Transforms.kIdentity,"er "), decode_transform_Transform(" ",decode_Transforms.kUppercaseAll," "), decode_transform_Transform("",decode_Transforms.kIdentity,"al "), decode_transform_Transform(" ",decode_Transforms.kUppercaseAll,""), decode_transform_Transform("",decode_Transforms.kIdentity,"='"), decode_transform_Transform("",decode_Transforms.kUppercaseAll,"\""), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,". "), decode_transform_Transform(" ",decode_Transforms.kIdentity,"("), decode_transform_Transform("",decode_Transforms.kIdentity,"ful "), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst,". "), decode_transform_Transform("",decode_Transforms.kIdentity,"ive "), decode_transform_Transform("",decode_Transforms.kIdentity,"less "), decode_transform_Transform("",decode_Transforms.kUppercaseAll,"'"), decode_transform_Transform("",decode_Transforms.kIdentity,"est "), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst,"."), decode_transform_Transform("",decode_Transforms.kUppercaseAll,"\">"), decode_transform_Transform(" ",decode_Transforms.kIdentity,"='"), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,","), decode_transform_Transform("",decode_Transforms.kIdentity,"ize "), decode_transform_Transform("",decode_Transforms.kUppercaseAll,"."), decode_transform_Transform(" ",decode_Transforms.kIdentity,""), decode_transform_Transform(" ",decode_Transforms.kIdentity,","), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,"=\""), decode_transform_Transform("",decode_Transforms.kUppercaseAll,"=\""), decode_transform_Transform("",decode_Transforms.kIdentity,"ous "), decode_transform_Transform("",decode_Transforms.kUppercaseAll,", "), decode_transform_Transform("",decode_Transforms.kUppercaseFirst,"='"), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst,","), decode_transform_Transform(" ",decode_Transforms.kUppercaseAll,"=\""), decode_transform_Transform(" ",decode_Transforms.kUppercaseAll,", "), decode_transform_Transform("",decode_Transforms.kUppercaseAll,","), decode_transform_Transform("",decode_Transforms.kUppercaseAll,"("), decode_transform_Transform("",decode_Transforms.kUppercaseAll,". "), decode_transform_Transform(" ",decode_Transforms.kUppercaseAll,"."), decode_transform_Transform("",decode_Transforms.kUppercaseAll,"='"), decode_transform_Transform(" ",decode_Transforms.kUppercaseAll,". "), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst,"=\""), decode_transform_Transform(" ",decode_Transforms.kUppercaseAll,"='"), decode_transform_Transform(" ",decode_Transforms.kUppercaseFirst,"='")]
decode_Transforms.kNumTransforms = len(decode_Transforms.kTransforms)
encode_Backward_references.kInfinity = Math.POSITIVE_INFINITY
encode_Block_splitter.kMaxLiteralHistograms = 100
encode_Block_splitter.kMaxCommandHistograms = 50
encode_Block_splitter.kLiteralBlockSwitchCost = 28.1
encode_Block_splitter.kCommandBlockSwitchCost = 13.5
encode_Block_splitter.kDistanceBlockSwitchCost = 14.6
encode_Block_splitter.kLiteralStrideLength = 70
encode_Block_splitter.kCommandStrideLength = 40
encode_Block_splitter.kSymbolsPerLiteralHistogram = 544
encode_Block_splitter.kSymbolsPerCommandHistogram = 530
encode_Block_splitter.kSymbolsPerDistanceHistogram = 544
encode_Block_splitter.kMinLengthForBlockSplitting = 128
encode_Block_splitter.kIterMulForRefining = 2
encode_Block_splitter.kMinItersForRefining = 100
encode_Command_functions.insbase = [0, 1, 2, 3, 4, 5, 6, 8, 10, 14, 18, 26, 34, 50, 66, 98, 130, 194, 322, 578, 1090, 2114, 6210, 22594]
encode_Command_functions.insextra = [0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 12, 14, 24]
encode_Command_functions.copybase = [2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 18, 22, 30, 38, 54, 70, 102, 134, 198, 326, 582, 1094, 2118]
encode_Command_functions.copyextra = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 24]
encode_Context.kUTF8ContextLookup = [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
encode_Context.kSigned3BitContextLookup = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7]
encode_Context.CONTEXT_LSB6 = 0
encode_Context.CONTEXT_MSB6 = 1
encode_Context.CONTEXT_UTF8 = 2
encode_Context.CONTEXT_SIGNED = 3
encode_Dictionary.kBrotliDictionaryOffsetsByLength = [0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536, 115968, 118528, 119872, 121280, 122016]
encode_Dictionary.kBrotliDictionarySizeBitsByLength = [0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7, 7, 6, 6, 5, 5]
encode_Dictionary.kMinDictionaryWordLength = 4
encode_Dictionary.kMaxDictionaryWordLength = 24
encode_Dictionary_hash.kStaticDictionaryHash = []
encode_Encode.kMaxWindowBits = 24
encode_Encode.kMinWindowBits = 16
encode_Encode.kMinInputBlockBits = 16
encode_Encode.kMaxInputBlockBits = 24
encode_Encode.kMinUTF8Ratio = 0.75
encode_Encode.kMinQualityForBlockSplit = 4
encode_Encode.kMinQualityForContextModeling = 5
encode_Encode.kMinQualityForOptimizeHistograms = 4
encode_Entropy_encode.kCodeLengthCodes = 18
encode_Fast_log.kLog2Table = [0.0000000000000000, 0.0000000000000000, 1.0000000000000000, 1.5849625007211563, 2.0000000000000000, 2.3219280948873622, 2.5849625007211561, 2.8073549220576042, 3.0000000000000000, 3.1699250014423126, 3.3219280948873626, 3.4594316186372978, 3.5849625007211565, 3.7004397181410922, 3.8073549220576037, 3.9068905956085187, 4.0000000000000000, 4.0874628412503400, 4.1699250014423122, 4.2479275134435852, 4.3219280948873626, 4.3923174227787607, 4.4594316186372973, 4.5235619560570131, 4.5849625007211570, 4.6438561897747244, 4.7004397181410926, 4.7548875021634691, 4.8073549220576037, 4.8579809951275728, 4.9068905956085187, 4.9541963103868758, 5.0000000000000000, 5.0443941193584534, 5.0874628412503400, 5.1292830169449664, 5.1699250014423122, 5.2094533656289501, 5.2479275134435852, 5.2854022188622487, 5.3219280948873626, 5.3575520046180838, 5.3923174227787607, 5.4262647547020979, 5.4594316186372973, 5.4918530963296748, 5.5235619560570131, 5.5545888516776376, 5.5849625007211570, 5.6147098441152083, 5.6438561897747244, 5.6724253419714961, 5.7004397181410926, 5.7279204545631996, 5.7548875021634691, 5.7813597135246599, 5.8073549220576046, 5.8328900141647422, 5.8579809951275719, 5.8826430493618416, 5.9068905956085187, 5.9307373375628867, 5.9541963103868758, 5.9772799234999168, 6.0000000000000000, 6.0223678130284544, 6.0443941193584534, 6.0660891904577721, 6.0874628412503400, 6.1085244567781700, 6.1292830169449672, 6.1497471195046822, 6.1699250014423122, 6.1898245588800176, 6.2094533656289510, 6.2288186904958804, 6.2479275134435861, 6.2667865406949019, 6.2854022188622487, 6.3037807481771031, 6.3219280948873617, 6.3398500028846252, 6.3575520046180847, 6.3750394313469254, 6.3923174227787598, 6.4093909361377026, 6.4262647547020979, 6.4429434958487288, 6.4594316186372982, 6.4757334309663976, 6.4918530963296748, 6.5077946401986964, 6.5235619560570131, 6.5391588111080319, 6.5545888516776376, 6.5698556083309478, 6.5849625007211561, 6.5999128421871278, 6.6147098441152092, 6.6293566200796095, 6.6438561897747253, 6.6582114827517955, 6.6724253419714952, 6.6865005271832185, 6.7004397181410917, 6.7142455176661224, 6.7279204545631988, 6.7414669864011465, 6.7548875021634691, 6.7681843247769260, 6.7813597135246599, 6.7944158663501062, 6.8073549220576037, 6.8201789624151887, 6.8328900141647422, 6.8454900509443757, 6.8579809951275719, 6.8703647195834048, 6.8826430493618416, 6.8948177633079437, 6.9068905956085187, 6.9188632372745955, 6.9307373375628867, 6.9425145053392399, 6.9541963103868758, 6.9657842846620879, 6.9772799234999168, 6.9886846867721664, 7.0000000000000000, 7.0112272554232540, 7.0223678130284544, 7.0334230015374501, 7.0443941193584534, 7.0552824355011898, 7.0660891904577721, 7.0768155970508317, 7.0874628412503400, 7.0980320829605272, 7.1085244567781700, 7.1189410727235076, 7.1292830169449664, 7.1395513523987937, 7.1497471195046822, 7.1598713367783891, 7.1699250014423130, 7.1799090900149345, 7.1898245588800176, 7.1996723448363644, 7.2094533656289492, 7.2191685204621621, 7.2288186904958804, 7.2384047393250794, 7.2479275134435861, 7.2573878426926521, 7.2667865406949019, 7.2761244052742384, 7.2854022188622487, 7.2946207488916270, 7.3037807481771031, 7.3128829552843557, 7.3219280948873617, 7.3309168781146177, 7.3398500028846243, 7.3487281542310781, 7.3575520046180847, 7.3663222142458151, 7.3750394313469254, 7.3837042924740528, 7.3923174227787607, 7.4008794362821844, 7.4093909361377026, 7.4178525148858991, 7.4262647547020979, 7.4346282276367255, 7.4429434958487288, 7.4512111118323299, 7.4594316186372973, 7.4676055500829976, 7.4757334309663976, 7.4838157772642564, 7.4918530963296748, 7.4998458870832057, 7.5077946401986964, 7.5156998382840436, 7.5235619560570131, 7.5313814605163119, 7.5391588111080319, 7.5468944598876373, 7.5545888516776376, 7.5622424242210728, 7.5698556083309478, 7.5774288280357487, 7.5849625007211561, 7.5924570372680806, 7.5999128421871278, 7.6073303137496113, 7.6147098441152075, 7.6220518194563764, 7.6293566200796095, 7.6366246205436488, 7.6438561897747244, 7.6510516911789290, 7.6582114827517955, 7.6653359171851765, 7.6724253419714952, 7.6794800995054464, 7.6865005271832185, 7.6934869574993252, 7.7004397181410926, 7.7073591320808825, 7.7142455176661224, 7.7210991887071856, 7.7279204545631996, 7.7347096202258392, 7.7414669864011465, 7.7481928495894596, 7.7548875021634691, 7.7615512324444795, 7.7681843247769260, 7.7747870596011737, 7.7813597135246608, 7.7879025593914317, 7.7944158663501062, 7.8008998999203047, 7.8073549220576037, 7.8137811912170374, 7.8201789624151887, 7.8265484872909159, 7.8328900141647422, 7.8392037880969445, 7.8454900509443757, 7.8517490414160571, 7.8579809951275719, 7.8641861446542798, 7.8703647195834048, 7.8765169465650002, 7.8826430493618425, 7.8887432488982601, 7.8948177633079446, 7.9008668079807496, 7.9068905956085187, 7.9128893362299619, 7.9188632372745955, 7.9248125036057813, 7.9307373375628867, 7.9366379390025719, 7.9425145053392399, 7.9483672315846778, 7.9541963103868758, 7.9600019320680806, 7.9657842846620870, 7.9715435539507720, 7.9772799234999168, 7.9829935746943104, 7.9886846867721664, 7.9943534368588578]
encode_Hash.kDistanceCacheIndex = [0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
encode_Hash.kDistanceCacheOffset = [0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3]
encode_Hash.kHashMul32 = 506832829
encode_Hash.kMaxZopfliLen = 325
encode_Histogram_functions.HistogramLiteralInt = 256
encode_Histogram_functions.HistogramCommandInt = 704
encode_Histogram_functions.HistogramDistanceInt = 520
encode_Histogram_functions.HistogramBlockLengthInt = 26
encode_Histogram_functions.HistogramContextMapInt = 272
encode_Histogram_functions.HistogramBlockTypeInt = 258
encode_Histogram_functions.kLiteralContextBits = 6
encode_Histogram_functions.kDistanceContextBits = 2
encode_Prefix.kNumInsertLenPrefixes = 24
encode_Prefix.kNumCopyLenPrefixes = 24
encode_Prefix.kNumCommandPrefixes = 704
encode_Prefix.kNumBlockLenPrefixes = 26
encode_Prefix.kNumDistanceShortCodes = 16
encode_Prefix.kNumDistancePrefixes = 520
encode_Prefix.kBlockLengthPrefixCode = [encode_prefix_PrefixCodeRange(1,2), encode_prefix_PrefixCodeRange(5,2), encode_prefix_PrefixCodeRange(9,2), encode_prefix_PrefixCodeRange(13,2), encode_prefix_PrefixCodeRange(17,3), encode_prefix_PrefixCodeRange(25,3), encode_prefix_PrefixCodeRange(33,3), encode_prefix_PrefixCodeRange(41,3), encode_prefix_PrefixCodeRange(49,4), encode_prefix_PrefixCodeRange(65,4), encode_prefix_PrefixCodeRange(81,4), encode_prefix_PrefixCodeRange(97,4), encode_prefix_PrefixCodeRange(113,5), encode_prefix_PrefixCodeRange(145,5), encode_prefix_PrefixCodeRange(177,5), encode_prefix_PrefixCodeRange(209,5), encode_prefix_PrefixCodeRange(241,6), encode_prefix_PrefixCodeRange(305,6), encode_prefix_PrefixCodeRange(369,7), encode_prefix_PrefixCodeRange(497,8), encode_prefix_PrefixCodeRange(753,9), encode_prefix_PrefixCodeRange(1265,10), encode_prefix_PrefixCodeRange(2289,11), encode_prefix_PrefixCodeRange(4337,12), encode_prefix_PrefixCodeRange(8433,13), encode_prefix_PrefixCodeRange(16625,24)]
encode_Static_dict.kMaxDictionaryMatchLen = 37
encode_Static_dict.kInvalidMatch = 268435455
encode_Static_dict_lut.kDictNumBits = 15
encode_Static_dict_lut.kDictHashMul32 = 506832829
encode_Static_dict_lut.kStaticDictionaryBuckets = []
encode_Static_dict_lut.kStaticDictionaryWords = []
encode_Transform.kOmitLastNTransforms = [0, 12, 27, 23, 42, 63, 56, 48, 59, 64]
encode_metablock_BlockSplitter.kMaxBlockTypes = 256
encode_metablock_ContextBlockSplitter.kMaxBlockTypes = 256
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
